{"level":"ERROR","timestamp":"2025-05-15T11:01:44.413988","namespace":"mcp_agent.llm.augmented_llm","message":"Error: Error code: 429 - {'message': 'Too many tokens, please wait before trying again.'}","data":{"data":[{"request":{"method":"POST","url":{"_uri_reference":["https","","bedrock-runtime.us-west-2.amazonaws.com",null,"/model/us.anthropic.claude-3-7-sonnet-20250219-v1:0/invoke",null,null]},"headers":["connection","host","accept-encoding","x-stainless-timeout","accept","content-type","user-agent","x-stainless-lang","x-stainless-package-version","x-stainless-os","x-stainless-arch","x-stainless-runtime","x-stainless-runtime-version","x-stainless-retry-count","x-stainless-read-timeout","content-length","x-amz-date","x-amz-security-token","authorization"],"extensions":{"timeout":{"connect":5.0,"read":600,"write":"600","pool":"600"}},"stream":[{"capitalize":"<callable: capitalize>","center":"<callable: center>","count":"<callable: count>","decode":"<callable: decode>","endswith":"<callable: endswith>","expandtabs":"<callable: expandtabs>","find":"<callable: find>","fromhex":"<callable: fromhex>","hex":"<callable: hex>","index":"<callable: index>","isalnum":"<callable: isalnum>","isalpha":"<callable: isalpha>","isascii":"<callable: isascii>","isdigit":"<callable: isdigit>","islower":"<callable: islower>","isspace":"<callable: isspace>","istitle":"<callable: istitle>","isupper":"<callable: isupper>","join":"<callable: join>","ljust":"<callable: ljust>","lower":"<callable: lower>","lstrip":"<callable: lstrip>","maketrans":"<callable: maketrans>","partition":"<callable: partition>","removeprefix":"<callable: removeprefix>","removesuffix":"<callable: removesuffix>","replace":"<callable: replace>","rfind":"<callable: rfind>","rindex":"<callable: rindex>","rjust":"<callable: rjust>","rpartition":"<callable: rpartition>","rsplit":"<callable: rsplit>","rstrip":"<callable: rstrip>","split":"<callable: split>","splitlines":"<callable: splitlines>","startswith":"<callable: startswith>","strip":"<callable: strip>","swapcase":"<callable: swapcase>","title":"<callable: title>","translate":"<callable: translate>","upper":"<callable: upper>","zfill":"<callable: zfill>"}],"_content":"b'{\"max_tokens\":4096,\"messages\":[{\"role\":\"user\",\"content\":[{\"type\":\"text\",\"text\":\"please review https://github.com/awslabs/aws-c-s3/pull/519\"}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"I\\'ll help you review the GitHub pull request for memory management issues, particularly focusing on memory leaks and safety. Let me first get the details of the PR to understand what we\\'re looking at.\"},{\"type\":\"tool_use\",\"name\":\"github-get_pull_request\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"pull_number\":519},\"id\":\"toolu_bdrk_01WyBeiBN55uq6Twq9narrbi\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01WyBeiBN55uq6Twq9narrbi\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\n  \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/pulls/519\\\\\",\\\\n  \\\\\"id\\\\\": 2520395028,\\\\n  \\\\\"node_id\\\\\": \\\\\"PR_kwDOEJB4Sc6WOi0U\\\\\",\\\\n  \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519\\\\\",\\\\n  \\\\\"diff_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519.diff\\\\\",\\\\n  \\\\\"patch_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519.patch\\\\\",\\\\n  \\\\\"issue_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/issues/519\\\\\",\\\\n  \\\\\"number\\\\\": 519,\\\\n  \\\\\"state\\\\\": \\\\\"open\\\\\",\\\\n  \\\\\"locked\\\\\": false,\\\\n  \\\\\"title\\\\\": \\\\\"dummy test\\\\\",\\\\n  \\\\\"user\\\\\": {\\\\n    \\\\\"login\\\\\": \\\\\"TingDaoK\\\\\",\\\\n    \\\\\"id\\\\\": 26829806,\\\\n    \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/26829806?v=4\\\\\",\\\\n    \\\\\"url\\\\\": \\\\\"https://api.github.com/users/TingDaoK\\\\\",\\\\n    \\\\\"html_url\\\\\": \\\\\"https://github.com/TingDaoK\\\\\"\\\\n  },\\\\n  \\\\\"body\\\\\": \\\\\"*Issue #, if available:*\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n*Description of changes:*\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.\\\\\\\\r\\\\\\\\n\\\\\",\\\\n  \\\\\"created_at\\\\\": \\\\\"2025-05-14T21:35:46Z\\\\\",\\\\n  \\\\\"updated_at\\\\\": \\\\\"2025-05-14T23:38:00Z\\\\\",\\\\n  \\\\\"closed_at\\\\\": null,\\\\n  \\\\\"merged_at\\\\\": null,\\\\n  \\\\\"merge_commit_sha\\\\\": \\\\\"b8fc1c78ceeba7906b6ac56483199a3faaf5e9cd\\\\\",\\\\n  \\\\\"assignee\\\\\": null,\\\\n  \\\\\"assignees\\\\\": [],\\\\n  \\\\\"requested_reviewers\\\\\": [],\\\\n  \\\\\"labels\\\\\": [],\\\\n  \\\\\"head\\\\\": {\\\\n    \\\\\"label\\\\\": \\\\\"awslabs:dummy-delete-me\\\\\",\\\\n    \\\\\"ref\\\\\": \\\\\"dummy-delete-me\\\\\",\\\\n    \\\\\"sha\\\\\": \\\\\"e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6\\\\\",\\\\n    \\\\\"user\\\\\": {\\\\n      \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n      \\\\\"id\\\\\": 3299148,\\\\n      \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\"\\\\n    },\\\\n    \\\\\"repo\\\\\": {\\\\n      \\\\\"id\\\\\": 277903433,\\\\n      \\\\\"node_id\\\\\": \\\\\"MDEwOlJlcG9zaXRvcnkyNzc5MDM0MzM=\\\\\",\\\\n      \\\\\"name\\\\\": \\\\\"aws-c-s3\\\\\",\\\\n      \\\\\"full_name\\\\\": \\\\\"awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"private\\\\\": false,\\\\n      \\\\\"owner\\\\\": {\\\\n        \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n        \\\\\"id\\\\\": 3299148,\\\\n        \\\\\"node_id\\\\\": \\\\\"MDEyOk9yZ2FuaXphdGlvbjMyOTkxNDg=\\\\\",\\\\n        \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n        \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n        \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\",\\\\n        \\\\\"type\\\\\": \\\\\"Organization\\\\\"\\\\n      },\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"description\\\\\": \\\\\"C99 library implementation for communicating with the S3 service, designed for maximizing throughput on high bandwidth EC2 instances.\\\\\",\\\\n      \\\\\"fork\\\\\": false,\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"created_at\\\\\": \\\\\"2020-07-07T19:21:45Z\\\\\",\\\\n      \\\\\"updated_at\\\\\": \\\\\"2025-05-15T17:15:47Z\\\\\",\\\\n      \\\\\"pushed_at\\\\\": \\\\\"2025-05-15T17:16:08Z\\\\\",\\\\n      \\\\\"git_url\\\\\": \\\\\"git://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"ssh_url\\\\\": \\\\\"git@github.com:awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"clone_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"default_branch\\\\\": \\\\\"main\\\\\"\\\\n    }\\\\n  },\\\\n  \\\\\"base\\\\\": {\\\\n    \\\\\"label\\\\\": \\\\\"awslabs:main\\\\\",\\\\n    \\\\\"ref\\\\\": \\\\\"main\\\\\",\\\\n    \\\\\"sha\\\\\": \\\\\"7d2d4b3070109c882ff78e8719f60597c7ba0472\\\\\",\\\\n    \\\\\"user\\\\\": {\\\\n      \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n      \\\\\"id\\\\\": 3299148,\\\\n      \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\"\\\\n    },\\\\n    \\\\\"repo\\\\\": {\\\\n      \\\\\"id\\\\\": 277903433,\\\\n      \\\\\"node_id\\\\\": \\\\\"MDEwOlJlcG9zaXRvcnkyNzc5MDM0MzM=\\\\\",\\\\n      \\\\\"name\\\\\": \\\\\"aws-c-s3\\\\\",\\\\n      \\\\\"full_name\\\\\": \\\\\"awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"private\\\\\": false,\\\\n      \\\\\"owner\\\\\": {\\\\n        \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n        \\\\\"id\\\\\": 3299148,\\\\n        \\\\\"node_id\\\\\": \\\\\"MDEyOk9yZ2FuaXphdGlvbjMyOTkxNDg=\\\\\",\\\\n        \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n        \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n        \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\",\\\\n        \\\\\"type\\\\\": \\\\\"Organization\\\\\"\\\\n      },\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"description\\\\\": \\\\\"C99 library implementation for communicating with the S3 service, designed for maximizing throughput on high bandwidth EC2 instances.\\\\\",\\\\n      \\\\\"fork\\\\\": false,\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"created_at\\\\\": \\\\\"2020-07-07T19:21:45Z\\\\\",\\\\n      \\\\\"updated_at\\\\\": \\\\\"2025-05-15T17:15:47Z\\\\\",\\\\n      \\\\\"pushed_at\\\\\": \\\\\"2025-05-15T17:16:08Z\\\\\",\\\\n      \\\\\"git_url\\\\\": \\\\\"git://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"ssh_url\\\\\": \\\\\"git@github.com:awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"clone_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"default_branch\\\\\": \\\\\"main\\\\\"\\\\n    }\\\\n  }\\\\n}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now, let\\'s get the files that were changed in this PR:\"},{\"type\":\"tool_use\",\"name\":\"github-get_pull_request_files\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"pull_number\":519},\"id\":\"toolu_bdrk_01RhD5KsR5cx6H9BQMeaP8d3\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01RhD5KsR5cx6H9BQMeaP8d3\",\"content\":[{\"type\":\"text\",\"text\":\"[\\\\n  {\\\\n    \\\\\"sha\\\\\": \\\\\"dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n    \\\\\"filename\\\\\": \\\\\"tests/s3_data_plane_tests.c\\\\\",\\\\n    \\\\\"status\\\\\": \\\\\"modified\\\\\",\\\\n    \\\\\"additions\\\\\": 49,\\\\n    \\\\\"deletions\\\\\": 0,\\\\n    \\\\\"changes\\\\\": 49,\\\\n    \\\\\"blob_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6/tests%2Fs3_data_plane_tests.c\\\\\",\\\\n    \\\\\"raw_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/raw/e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6/tests%2Fs3_data_plane_tests.c\\\\\",\\\\n    \\\\\"contents_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests%2Fs3_data_plane_tests.c?ref=e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6\\\\\",\\\\n    \\\\\"patch\\\\\": \\\\\"@@ -8114,3 +8114,52 @@ static int s_test_s3_default_get_without_content_length(struct aws_allocator *al\\\\\\\\n \\\\\\\\n     return AWS_OP_SUCCESS;\\\\\\\\n }\\\\\\\\n+\\\\\\\\n+struct aws_string *test_helper(struct aws_allocator *allocator) {\\\\\\\\n+    struct aws_string *host_name =\\\\\\\\n+        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n+    return host_name;\\\\\\\\n+}\\\\\\\\n+\\\\\\\\n+AWS_TEST_CASE(test_s3_default_get, aws_test_s3_default_get)\\\\\\\\n+static int aws_test_s3_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n+    (void)ctx;\\\\\\\\n+\\\\\\\\n+    struct aws_s3_tester tester;\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n+\\\\\\\\n+    struct aws_s3_client *client = NULL;\\\\\\\\n+    struct aws_s3_tester_client_options client_options;\\\\\\\\n+    AWS_ZERO_STRUCT(client_options);\\\\\\\\n+\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n+    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n+    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n+\\\\\\\\n+    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n+    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n+\\\\\\\\n+    struct aws_string *hsot_name = test_helper(allocator);\\\\\\\\n+\\\\\\\\n+    /* Put together a simple S3 Get Object request. */\\\\\\\\n+    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n+        allocator, aws_byte_cursor_from_string(hsot_name), g_pre_existing_object_1MB);\\\\\\\\n+\\\\\\\\n+    struct aws_s3_meta_request_options options;\\\\\\\\n+    AWS_ZERO_STRUCT(options);\\\\\\\\n+    /* Send default type */\\\\\\\\n+    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n+    options.message = message;\\\\\\\\n+    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n+\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n+        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n+\\\\\\\\n+    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n+    aws_http_message_release(message);\\\\\\\\n+    aws_s3_client_release(client);\\\\\\\\n+    aws_s3_tester_clean_up(&tester);\\\\\\\\n+\\\\\\\\n+    return AWS_OP_SUCCESS;\\\\\\\\n+}\\\\\"\\\\n  }\\\\n]\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Let me examine the content of the file to understand the changes better:\"},{\"type\":\"tool_use\",\"name\":\"github-get_file_contents\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"path\":\"tests/s3_data_plane_tests.c\",\"branch\":\"dummy-delete-me\"},\"id\":\"toolu_bdrk_01K9BvZWpCfriwEYnPYW324f\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01K9BvZWpCfriwEYnPYW324f\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\n  \\\\\"name\\\\\": \\\\\"s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"path\\\\\": \\\\\"tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"sha\\\\\": \\\\\"dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n  \\\\\"size\\\\\": 319574,\\\\n  \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests/s3_data_plane_tests.c?ref=dummy-delete-me\\\\\",\\\\n  \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"git_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/git/blobs/dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n  \\\\\"download_url\\\\\": \\\\\"https://raw.githubusercontent.com/awslabs/aws-c-s3/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"type\\\\\": \\\\\"file\\\\\",\\\\n  \\\\\"content\\\\\": \\\\\"/**\\\\\\\\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\\\\\\\\n * SPDX-License-Identifier: Apache-2.0.\\\\\\\\n */\\\\\\\\n\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_checksums.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\"\\\\\\\\n#include <aws/common/byte_buf.h>\\\\\\\\n#include <aws/common/clock.h>\\\\\\\\n#include <aws/common/common.h>\\\\\\\\n#include <aws/common/encoding.h>\\\\\\\\n#include <aws/common/environment.h>\\\\\\\\n#include <aws/common/ref_count.h>\\\\\\\\n#include <aws/http/request_response.h>\\\\\\\\n#include <aws/http/status_code.h>\\\\\\\\n#include <aws/io/channel_bootstrap.h>\\\\\\\\n#include <aws/io/event_loop.h>\\\\\\\\n#include <aws/io/host_resolver.h>\\\\\\\\n#include <aws/io/stream.h>\\\\\\\\n#include <aws/io/tls_channel_handler.h>\\\\\\\\n#include <aws/io/uri.h>\\\\\\\\n#include <aws/testing/aws_test_harness.h>\\\\\\\\n#include <aws/testing/stream_tester.h>\\\\\\\\n#include <inttypes.h>\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_create_destroy, s_test_s3_client_create_destroy)\\\\\\\\nstatic int s_test_s3_client_create_destroy(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_create_error, s_test_s3_client_create_error)\\\\\\\\nstatic int s_test_s3_client_create_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    struct aws_http_proxy_options proxy_options = {\\\\\\\\n        .connection_type = AWS_HPCT_HTTP_LEGACY,\\\\\\\\n        .host = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"localhost\\\\\\\\\\\\\"),\\\\\\\\n        .port = 8899,\\\\\\\\n    };\\\\\\\\n    client_config.proxy_options = &proxy_options;\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_client_create_error_with_invalid_memory_limit_config,\\\\\\\\n    s_test_s3_client_create_error_with_invalid_memory_limit_config)\\\\\\\\nstatic int s_test_s3_client_create_error_with_invalid_memory_limit_config(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    client_config.memory_limit_in_bytes = 100;\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n    client_config.memory_limit_in_bytes = GB_TO_BYTES(1);\\\\\\\\n    client_config.max_part_size = GB_TO_BYTES(2);\\\\\\\\n    client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_client_create_error_with_invalid_network_interface,\\\\\\\\n    s_test_s3_client_create_error_with_invalid_network_interface)\\\\\\\\nstatic int s_test_s3_client_create_error_with_invalid_network_interface(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor *interface_names_array = aws_mem_calloc(allocator, 1, sizeof(struct aws_byte_cursor));\\\\\\\\n    interface_names_array[0] = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"invalid-nic\\\\\\\\\\\\\");\\\\\\\\n    client_config.network_interface_names_array = interface_names_array;\\\\\\\\n    client_config.num_network_interface_names = 1;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_mem_release(allocator, interface_names_array);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_monitoring_options_override, s_test_s3_client_monitoring_options_override)\\\\\\\\nstatic int s_test_s3_client_monitoring_options_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_http_connection_monitoring_options monitoring_options = {.minimum_throughput_bytes_per_second = 3000};\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.monitoring_options = &monitoring_options};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        client->monitoring_options.minimum_throughput_bytes_per_second ==\\\\\\\\n        client_config.monitoring_options->minimum_throughput_bytes_per_second);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_proxy_ev_settings_override, s_test_s3_client_proxy_ev_settings_override)\\\\\\\\nstatic int s_test_s3_client_proxy_ev_settings_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_tls_connection_options tls_conn_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_conn_options);\\\\\\\\n\\\\\\\\n    struct proxy_env_var_settings proxy_ev_settings = {\\\\\\\\n        .env_var_type = AWS_HPEV_ENABLE,\\\\\\\\n        .tls_options = &tls_conn_options,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.proxy_ev_settings = &proxy_ev_settings};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->proxy_ev_settings->env_var_type == client_config.proxy_ev_settings->env_var_type);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_tcp_keep_alive_options_override, s_test_s3_client_tcp_keep_alive_options_override)\\\\\\\\nstatic int s_test_s3_client_tcp_keep_alive_options_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tcp_keep_alive_options keep_alive_options = {.keep_alive_interval_sec = 20};\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.tcp_keep_alive_options = &keep_alive_options};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        client->tcp_keep_alive_options->keep_alive_interval_sec ==\\\\\\\\n        client_config.tcp_keep_alive_options->keep_alive_interval_sec);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_max_active_connections_override, s_test_s3_client_max_active_connections_override)\\\\\\\\nstatic int s_test_s3_client_max_active_connections_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .max_active_connections_override = 10,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->max_active_connections_override == client_config.max_active_connections_override);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_byo_crypto_no_options, s_test_s3_client_byo_crypto_no_options)\\\\\\\\nstatic int s_test_s3_client_byo_crypto_no_options(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .tls_mode = AWS_MR_TLS_ENABLED,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_last_error() == AWS_ERROR_INVALID_ARGUMENT);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_byo_crypto_with_options, s_test_s3_client_byo_crypto_with_options)\\\\\\\\nstatic int s_test_s3_client_byo_crypto_with_options(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_conn_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_conn_options);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n    client_config.tls_connection_options = &tls_conn_options;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nsize_t s_test_max_active_connections_host_count = 0;\\\\\\\\n\\\\\\\\nsize_t s_test_get_max_active_connections_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    return s_test_max_active_connections_host_count;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_get_max_active_connections, s_test_s3_client_get_max_active_connections)\\\\\\\\nstatic int s_test_s3_client_get_max_active_connections(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)allocator;\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_client_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_client_bootstrap);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    *((uint32_t *)&mock_client->max_active_connections_override) = 0;\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = 100;\\\\\\\\n    mock_client->client_bootstrap = &mock_client_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_get_max_active_connections_host_address_count;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_requests[AWS_S3_META_REQUEST_TYPE_MAX];\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n        /* Setup test data. */\\\\\\\\n        mock_meta_requests[i] = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n        mock_meta_requests[i]->type = i;\\\\\\\\n        mock_meta_requests[i]->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    s_test_max_active_connections_host_count = 2;\\\\\\\\n\\\\\\\\n    /* Behavior should not be affected by max_active_connections_override since it is 0, and should just be in relation\\\\\\\\n     * to ideal-connection-count. */\\\\\\\\n    {\\\\\\\\n        ASSERT_TRUE(aws_s3_client_get_max_active_connections(mock_client, NULL) == mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->ideal_connection_count);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Max active connections override should now cap the calculated amount of active connections. */\\\\\\\\n    {\\\\\\\\n        *((uint32_t *)&mock_client->max_active_connections_override) = 3;\\\\\\\\n\\\\\\\\n        /* Assert that override is low enough to have effect */\\\\\\\\n        ASSERT_TRUE(mock_client->max_active_connections_override < mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(\\\\\\\\n            aws_s3_client_get_max_active_connections(mock_client, NULL) ==\\\\\\\\n            mock_client->max_active_connections_override);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(mock_client->max_active_connections_override < mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->max_active_connections_override);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Max active connections override should be ignored since the calculated amount of max connections is less. */\\\\\\\\n    {\\\\\\\\n        *((uint32_t *)&mock_client->max_active_connections_override) = 100000;\\\\\\\\n\\\\\\\\n        /* Assert that override is NOT low enough to have effect */\\\\\\\\n        ASSERT_TRUE(mock_client->max_active_connections_override > mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(aws_s3_client_get_max_active_connections(mock_client, NULL) == mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(mock_client->max_active_connections_override > mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->ideal_connection_count);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n        mock_meta_requests[i] = aws_s3_meta_request_release(mock_meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_request_create_destroy, s_test_s3_request_create_destroy)\\\\\\\\nstatic int s_test_s3_request_create_destroy(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const int request_tag = 1234;\\\\\\\\n    const enum aws_s3_request_type request_type = AWS_S3_REQUEST_TYPE_LIST_PARTS;\\\\\\\\n    const uint32_t part_number = 5678;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n    meta_request->client = aws_s3_client_acquire(client);\\\\\\\\n\\\\\\\\n    struct aws_http_message *request_message = aws_s3_tester_dummy_http_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(request_message != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n        meta_request, request_tag, request_type, part_number, AWS_S3_REQUEST_FLAG_RECORD_RESPONSE_HEADERS);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->meta_request == meta_request);\\\\\\\\n    ASSERT_TRUE(request->part_number == part_number);\\\\\\\\n    ASSERT_TRUE(request->request_tag == request_tag);\\\\\\\\n    ASSERT_TRUE(request->request_type == request_type);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"ListParts\\\\\\\\\\\\\", aws_string_c_str(request->operation_name));\\\\\\\\n    ASSERT_TRUE(request->record_response_headers == true);\\\\\\\\n\\\\\\\\n    aws_s3_request_setup_send_data(request, request_message);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->send_data.message != NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers == NULL);\\\\\\\\n\\\\\\\\n    request->send_data.response_headers = aws_http_headers_new(allocator);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers != NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.metrics != NULL);\\\\\\\\n    request->send_data.metrics = aws_s3_request_metrics_release(request->send_data.metrics);\\\\\\\\n\\\\\\\\n    aws_s3_request_clean_up_send_data(request);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->send_data.message == NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers == NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_status == 0);\\\\\\\\n\\\\\\\\n    aws_s3_request_release(request);\\\\\\\\n    aws_http_message_release(request_message);\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct s3_test_body_streaming_user_data {\\\\\\\\n    struct aws_s3_tester *tester;\\\\\\\\n    struct aws_allocator *allocator;\\\\\\\\n    uint64_t expected_range_start;\\\\\\\\n    uint64_t received_body_size;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic int s_s3_meta_request_test_body_streaming_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)body;\\\\\\\\n    (void)range_start;\\\\\\\\n\\\\\\\\n    struct s3_test_body_streaming_user_data *body_streaming_user_data = user_data;\\\\\\\\n\\\\\\\\n    body_streaming_user_data->received_body_size += body->len;\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_streaming_user_data->expected_range_start == range_start);\\\\\\\\n    body_streaming_user_data->expected_range_start += body->len;\\\\\\\\n\\\\\\\\n    aws_s3_tester_inc_counter1(body_streaming_user_data->tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test the meta request body streaming functionality. */\\\\\\\\nAWS_TEST_CASE(test_s3_meta_request_body_streaming, s_test_s3_meta_request_body_streaming)\\\\\\\\nstatic int s_test_s3_meta_request_body_streaming(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const uint32_t part_range0_start = 1;\\\\\\\\n    const uint32_t part_range0_end = part_range0_start + 4;\\\\\\\\n\\\\\\\\n    const uint32_t part_range1_start = part_range0_end + 1;\\\\\\\\n    const uint32_t part_range1_end = part_range1_start + 4;\\\\\\\\n\\\\\\\\n    const size_t request_response_body_size = 16;\\\\\\\\n\\\\\\\\n    const uint64_t total_object_size = (uint64_t)part_range1_end * request_response_body_size;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf response_body_source_buffer;\\\\\\\\n    aws_byte_buf_init(&response_body_source_buffer, allocator, request_response_body_size);\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor test_byte_cursor = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"0\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < request_response_body_size; ++i) {\\\\\\\\n        aws_byte_buf_append(&response_body_source_buffer, &test_byte_cursor);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct s3_test_body_streaming_user_data body_streaming_user_data = {\\\\\\\\n        .tester = &tester,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_event_loop_group *event_loop_group = aws_event_loop_group_new_default(allocator, 0, NULL);\\\\\\\\n    meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    meta_request->user_data = &body_streaming_user_data;\\\\\\\\n    *((size_t *)&meta_request->part_size) = request_response_body_size;\\\\\\\\n    meta_request->body_callback = s_s3_meta_request_test_body_streaming_callback;\\\\\\\\n    meta_request->io_event_loop = aws_event_loop_group_get_next_loop(event_loop_group);\\\\\\\\n\\\\\\\\n    /* Queue the first range of parts in order. Each part should be flushed one-by-one. */\\\\\\\\n    {\\\\\\\\n        for (uint32_t part_number = part_range0_start; part_number <= part_range0_end; ++part_number) {\\\\\\\\n            struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n                meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_number, 0 /*flags*/);\\\\\\\\n\\\\\\\\n            aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n                0ULL,\\\\\\\\n                total_object_size - 1,\\\\\\\\n                request_response_body_size /*part_size*/,\\\\\\\\n                (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n                part_number,\\\\\\\\n                &request->part_range_start,\\\\\\\\n                &request->part_range_end);\\\\\\\\n\\\\\\\\n            aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n            aws_s3_tester_set_counter1_desired(&tester, part_number);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n            ASSERT_TRUE(aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == 0);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_tester_wait_for_counters(&tester);\\\\\\\\n\\\\\\\\n            aws_s3_request_release(request);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_set_counter1_desired(&tester, part_range1_end);\\\\\\\\n\\\\\\\\n    /* Queue parts for second range, but skip over the first part.*/\\\\\\\\n    {\\\\\\\\n        uint32_t num_parts_queued = 0;\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(part_range1_start != part_range1_end);\\\\\\\\n\\\\\\\\n        for (uint32_t part_number = part_range1_start + 1; part_number <= part_range1_end; ++part_number) {\\\\\\\\n            struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n                meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_number, 0 /*flags*/);\\\\\\\\n\\\\\\\\n            aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n                0ULL,\\\\\\\\n                total_object_size - 1,\\\\\\\\n                request_response_body_size /*part_size*/,\\\\\\\\n                (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n                part_number,\\\\\\\\n                &request->part_range_start,\\\\\\\\n                &request->part_range_end);\\\\\\\\n\\\\\\\\n            aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n            aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n            aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_request_release(request);\\\\\\\\n            ++num_parts_queued;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        ASSERT_TRUE(\\\\\\\\n            aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == num_parts_queued);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Stream the last part of the body, which should flush the priority queue. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n            meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_range1_start, 0 /*flags*/);\\\\\\\\n\\\\\\\\n        aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n            0ULL,\\\\\\\\n            total_object_size - 1,\\\\\\\\n            request_response_body_size /*part_size*/,\\\\\\\\n            (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n            part_range1_start,\\\\\\\\n            &request->part_range_start,\\\\\\\\n            &request->part_range_end);\\\\\\\\n\\\\\\\\n        aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        ASSERT_TRUE(aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == 0);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n        aws_s3_request_release(request);\\\\\\\\n\\\\\\\\n        aws_s3_tester_wait_for_counters(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_streaming_user_data.received_body_size == (request_response_body_size * part_range1_end));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_event_loop_group_release(event_loop_group);\\\\\\\\n    aws_byte_buf_clean_up(&response_body_source_buffer);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test aws_s3_client_queue_requests_threaded and aws_s3_client_dequeue_request_threaded */\\\\\\\\nAWS_TEST_CASE(test_s3_client_queue_requests, s_test_s3_client_queue_requests)\\\\\\\\nstatic int s_test_s3_client_queue_requests(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *pivot_request = aws_s3_request_new(mock_meta_request, 0, 0, 0, 0);\\\\\\\\n\\\\\\\\n    struct aws_linked_list pivot_request_list;\\\\\\\\n    aws_linked_list_init(&pivot_request_list);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *requests[] = {\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    const uint32_t num_requests = AWS_ARRAY_SIZE(requests);\\\\\\\\n\\\\\\\\n    struct aws_linked_list request_list;\\\\\\\\n    aws_linked_list_init(&request_list);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        aws_linked_list_push_back(&pivot_request_list, &pivot_request->node);\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &pivot_request_list, false);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 1);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n            aws_linked_list_push_back(&request_list, &requests[i]->node);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Move the requests to the back of the queue. */\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &request_list, false);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&request_list));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests + 1));\\\\\\\\n    ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        /* The first request should be the pivot request since the other requests were pushed to the back. */\\\\\\\\n        struct aws_s3_request *first_request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n        ASSERT_TRUE(first_request == pivot_request);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == num_requests);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        struct aws_s3_request *request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(request == requests[i]);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests - (i + 1)));\\\\\\\\n\\\\\\\\n        if (i < num_requests - 1) {\\\\\\\\n            ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        aws_linked_list_push_back(&pivot_request_list, &pivot_request->node);\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &pivot_request_list, false);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 1);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n            aws_linked_list_push_back(&request_list, &requests[i]->node);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Move the requests to the front of the queue. */\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &request_list, true);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&request_list));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests + 1));\\\\\\\\n    ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        struct aws_s3_request *request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(request == requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        /* The last request should be the pivot request since the other requests were pushed to the front. */\\\\\\\\n        struct aws_s3_request *last_request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n        ASSERT_TRUE(last_request == pivot_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        aws_s3_request_release(requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_request_release(pivot_request);\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct test_work_meta_request_update_user_data {\\\\\\\\n    bool has_work_remaining;\\\\\\\\n    uint32_t num_prepares;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic bool s_s3_test_work_meta_request_update(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    uint32_t flags,\\\\\\\\n    struct aws_s3_request **out_request) {\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data *user_data = meta_request->user_data;\\\\\\\\n\\\\\\\\n    if (out_request) {\\\\\\\\n        if (user_data->has_work_remaining) {\\\\\\\\n            *out_request = aws_s3_request_new(meta_request, 0, 0, 0, 0);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return user_data->has_work_remaining;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_work_meta_request_schedule_prepare_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    aws_s3_meta_request_prepare_request_callback_fn *callback,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)request;\\\\\\\\n    (void)callback;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data *test_user_data = meta_request->user_data;\\\\\\\\n    ++test_user_data->num_prepares;\\\\\\\\n\\\\\\\\n    aws_s3_request_release(request);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic size_t s_test_s3_update_meta_request_trigger_prepare_host_address_count = 0;\\\\\\\\n\\\\\\\\nstatic size_t s_test_s3_update_meta_request_trigger_prepare_get_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n    return s_test_s3_update_meta_request_trigger_prepare_host_address_count;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_validate_prepared_requests(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    size_t expected_num_being_prepared,\\\\\\\\n    struct aws_s3_meta_request *meta_request_with_work,\\\\\\\\n    struct aws_s3_meta_request *meta_request_without_work) {\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->threaded_data.request_queue_size == 0);\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&client->threaded_data.request_queue));\\\\\\\\n    ASSERT_TRUE(client->threaded_data.num_requests_being_prepared == expected_num_being_prepared);\\\\\\\\n    ASSERT_TRUE(aws_atomic_load_int(&client->stats.num_requests_in_flight) == expected_num_being_prepared);\\\\\\\\n\\\\\\\\n    uint32_t num_meta_requests_in_list = 0;\\\\\\\\n    bool meta_request_with_work_found = false;\\\\\\\\n\\\\\\\\n    for (struct aws_linked_list_node *node = aws_linked_list_begin(&client->threaded_data.meta_requests);\\\\\\\\n         node != aws_linked_list_end(&client->threaded_data.meta_requests);\\\\\\\\n         node = aws_linked_list_next(node)) {\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request *meta_request =\\\\\\\\n            AWS_CONTAINER_OF(node, struct aws_s3_meta_request, client_process_work_threaded_data);\\\\\\\\n\\\\\\\\n        if (meta_request == meta_request_with_work) {\\\\\\\\n            meta_request_with_work_found = true;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_request != meta_request_without_work);\\\\\\\\n\\\\\\\\n        ++num_meta_requests_in_list;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_with_work_found);\\\\\\\\n    ASSERT_TRUE(num_meta_requests_in_list == 1);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the client will prepare requests correctly. */\\\\\\\\nAWS_TEST_CASE(test_s3_update_meta_requests_trigger_prepare, s_test_s3_update_meta_requests_trigger_prepare)\\\\\\\\nstatic int s_test_s3_update_meta_requests_trigger_prepare(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_bootstrap);\\\\\\\\n\\\\\\\\n    const uint32_t ideal_connection_count = 100;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    mock_client->client_bootstrap = &mock_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_s3_update_meta_request_trigger_prepare_get_host_address_count;\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = ideal_connection_count;\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.meta_requests);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request_without_work = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request_without_work->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    mock_meta_request_without_work->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data mock_meta_request_without_work_data = {\\\\\\\\n        .has_work_remaining = false,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    mock_meta_request_without_work->user_data = &mock_meta_request_without_work_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *meta_request_without_work_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request_without_work, NULL);\\\\\\\\n    meta_request_without_work_vtable->update = s_s3_test_work_meta_request_update;\\\\\\\\n    meta_request_without_work_vtable->schedule_prepare_request = s_s3_test_work_meta_request_schedule_prepare_request;\\\\\\\\n\\\\\\\\n    /* Intentionally push this meta request first to test that it\\'s properly removed from the list. */\\\\\\\\n    aws_linked_list_push_back(\\\\\\\\n        &mock_client->threaded_data.meta_requests,\\\\\\\\n        &mock_meta_request_without_work->client_process_work_threaded_data.node);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_acquire(mock_meta_request_without_work);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request_with_work = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request_with_work->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    struct test_work_meta_request_update_user_data mock_meta_request_with_work_data = {\\\\\\\\n        .has_work_remaining = true,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    mock_meta_request_with_work->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n    mock_meta_request_with_work->user_data = &mock_meta_request_with_work_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *mock_meta_request_with_work_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request_with_work, NULL);\\\\\\\\n    mock_meta_request_with_work_vtable->update = s_s3_test_work_meta_request_update;\\\\\\\\n    mock_meta_request_with_work_vtable->schedule_prepare_request = s_s3_test_work_meta_request_schedule_prepare_request;\\\\\\\\n\\\\\\\\n    aws_linked_list_push_back(\\\\\\\\n        &mock_client->threaded_data.meta_requests,\\\\\\\\n        &mock_meta_request_with_work->client_process_work_threaded_data.node);\\\\\\\\n    aws_s3_meta_request_acquire(mock_meta_request_with_work);\\\\\\\\n\\\\\\\\n    /* With no known addresses, the amount of requests that can be prepared should be lower. */\\\\\\\\n    {\\\\\\\\n        s_test_s3_update_meta_request_trigger_prepare_host_address_count = 0;\\\\\\\\n        aws_s3_client_update_meta_requests_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(s_validate_prepared_requests(\\\\\\\\n            mock_client, g_min_num_connections, mock_meta_request_with_work, mock_meta_request_without_work));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* When the number of known addresses is 1+, the max number of requests should be reached. */\\\\\\\\n    {\\\\\\\\n        const uint32_t max_requests_prepare = aws_s3_client_get_max_requests_prepare(mock_client);\\\\\\\\n\\\\\\\\n        s_test_s3_update_meta_request_trigger_prepare_host_address_count = 1;\\\\\\\\n        aws_s3_client_update_meta_requests_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(s_validate_prepared_requests(\\\\\\\\n            mock_client, max_requests_prepare, mock_meta_request_with_work, mock_meta_request_without_work));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    while (!aws_linked_list_empty(&mock_client->threaded_data.meta_requests)) {\\\\\\\\n        struct aws_linked_list_node *meta_request_node =\\\\\\\\n            aws_linked_list_pop_front(&mock_client->threaded_data.meta_requests);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request *meta_request =\\\\\\\\n            AWS_CONTAINER_OF(meta_request_node, struct aws_s3_meta_request, client_process_work_threaded_data);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_release(meta_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request_without_work);\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request_with_work);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct s3_test_update_connections_finish_result_user_data {\\\\\\\\n    struct aws_s3_request *finished_request;\\\\\\\\n    struct aws_s3_request *create_connection_request;\\\\\\\\n\\\\\\\\n    uint32_t finished_request_call_counter;\\\\\\\\n    uint32_t create_connection_request_call_counter;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic void s_s3_test_meta_request_has_finish_result_finished_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    AWS_ASSERT(request);\\\\\\\\n    (void)error_code;\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data *user_data = meta_request->user_data;\\\\\\\\n    user_data->finished_request = request;\\\\\\\\n    ++user_data->finished_request_call_counter;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_meta_request_has_finish_result_client_create_connection_for_request(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    struct aws_s3_request *request) {\\\\\\\\n    (void)client;\\\\\\\\n    (void)request;\\\\\\\\n    AWS_ASSERT(client);\\\\\\\\n    AWS_ASSERT(request);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = request->meta_request;\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data *user_data = meta_request->user_data;\\\\\\\\n    user_data->create_connection_request = request;\\\\\\\\n    ++user_data->create_connection_request_call_counter;\\\\\\\\n}\\\\\\\\n\\\\\\\\nsize_t s_test_update_conns_finish_result_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    return 1;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the client will correctly discard requests for meta requests that are trying to finish. */\\\\\\\\nAWS_TEST_CASE(test_s3_client_update_connections_finish_result, s_test_s3_client_update_connections_finish_result)\\\\\\\\nstatic int s_test_s3_client_update_connections_finish_result(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_client_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_client_bootstrap);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    mock_client->client_bootstrap = &mock_client_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_update_conns_finish_result_host_address_count;\\\\\\\\n    mock_client->vtable->create_connection_for_request =\\\\\\\\n        s_s3_test_meta_request_has_finish_result_client_create_connection_for_request;\\\\\\\\n\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = 1;\\\\\\\\n\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data test_update_connections_finish_result_user_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_update_connections_finish_result_user_data);\\\\\\\\n\\\\\\\\n    /* Put together a mock meta request that is finished. */\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    mock_meta_request->synced_data.finish_result_set = true;\\\\\\\\n    mock_meta_request->user_data = &test_update_connections_finish_result_user_data;\\\\\\\\n    mock_meta_request->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *mock_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request, NULL);\\\\\\\\n    mock_meta_request_vtable->finished_request = s_s3_test_meta_request_has_finish_result_finished_request;\\\\\\\\n\\\\\\\\n    /* Verify that the request does not get sent because the meta request has finish-result. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request = aws_s3_request_new(mock_meta_request, 0, 0, 0, 0);\\\\\\\\n        aws_linked_list_push_back(&mock_client->threaded_data.request_queue, &request->node);\\\\\\\\n        ++mock_client->threaded_data.request_queue_size;\\\\\\\\n\\\\\\\\n        aws_s3_client_update_connections_threaded(mock_client);\\\\\\\\n\\\\\\\\n        /* Request should still have been dequeued, but immediately passed to the meta request finish function. */\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n        ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request == request);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request_call_counter == 1);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request == NULL);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request_call_counter == 0);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    AWS_ZERO_STRUCT(test_update_connections_finish_result_user_data);\\\\\\\\n\\\\\\\\n    /* Verify that a request with the \\'always send\\' flag still gets sent when the meta request has a finish-result. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request =\\\\\\\\n            aws_s3_request_new(mock_meta_request, 0, 0, 0, AWS_S3_REQUEST_FLAG_ALWAYS_SEND);\\\\\\\\n        aws_linked_list_push_back(&mock_client->threaded_data.request_queue, &request->node);\\\\\\\\n        ++mock_client->threaded_data.request_queue_size;\\\\\\\\n\\\\\\\\n        aws_s3_client_update_connections_threaded(mock_client);\\\\\\\\n\\\\\\\\n        /* Request should have been dequeued, and then sent on a connection. */\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n        ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request == NULL);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request_call_counter == 0);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request == request);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request_call_counter == 1);\\\\\\\\n\\\\\\\\n        aws_s3_request_release(request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_get_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    enum aws_s3_client_tls_usage tls_usage,\\\\\\\\n    uint32_t extra_meta_request_flag,\\\\\\\\n    struct aws_byte_cursor s3_path) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_connection_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_connection_options);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    struct aws_tls_ctx_options tls_context_options;\\\\\\\\n    aws_tls_ctx_options_init_default_client(&tls_context_options, allocator);\\\\\\\\n\\\\\\\\n    struct aws_tls_ctx *context = aws_tls_client_ctx_new(allocator, &tls_context_options);\\\\\\\\n    aws_tls_connection_options_init_from_ctx(&tls_connection_options, context);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    struct aws_string *endpoint =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n    struct aws_byte_cursor endpoint_cursor = aws_byte_cursor_from_string(endpoint);\\\\\\\\n\\\\\\\\n    tls_connection_options.server_name = aws_string_new_from_cursor(allocator, &endpoint_cursor);\\\\\\\\n\\\\\\\\n    switch (tls_usage) {\\\\\\\\n        case AWS_S3_TLS_ENABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n            client_config.tls_connection_options = &tls_connection_options;\\\\\\\\n            break;\\\\\\\\n        case AWS_S3_TLS_DISABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_DISABLED;\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS | extra_meta_request_flag;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_get_object_meta_request(&tester, client, s3_path, flags, NULL));\\\\\\\\n\\\\\\\\n    aws_string_destroy(endpoint);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    aws_tls_ctx_release(context);\\\\\\\\n    aws_tls_connection_options_clean_up(&tls_connection_options);\\\\\\\\n    aws_tls_ctx_options_clean_up(&tls_context_options);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_disabled, s_test_s3_get_object_tls_disabled)\\\\\\\\nstatic int s_test_s3_get_object_tls_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_DISABLED, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_enabled, s_test_s3_get_object_tls_enabled)\\\\\\\\nstatic int s_test_s3_get_object_tls_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_ENABLED, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_default, s_test_s3_get_object_tls_default)\\\\\\\\nstatic int s_test_s3_get_object_tls_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_DEFAULT, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_no_signing, s_test_s3_no_signing)\\\\\\\\nstatic int s_test_s3_no_signing(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_signing_override, s_test_s3_signing_override)\\\\\\\\nstatic int s_test_s3_signing_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    /* Getting without signing should fail since the client has no signing set up. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request.*/\\\\\\\\n        struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request(&tester, client, &options, &meta_request_test_results, 0));\\\\\\\\n        ASSERT_TRUE(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0) != AWS_OP_SUCCESS);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Getting with signing should succeed if we set up signing on the meta request. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n        options.signing_config = &tester.default_signing_config;\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request. */\\\\\\\\n        struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n            &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_less_than_part_size, s_test_s3_get_object_less_than_part_size)\\\\\\\\nstatic int s_test_s3_get_object_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_get_object_meta_request(\\\\\\\\n        &tester, client, g_pre_existing_object_1MB, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_with_part_remainder, s_test_s3_put_object_with_part_remainder)\\\\\\\\nstatic int s_test_s3_put_object_with_part_remainder(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Object size meant to be one megabyte larger than the part size of the client. */\\\\\\\\n                .object_size_mb = 6,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multiple, s_test_s3_get_object_multiple)\\\\\\\\nstatic int s_test_s3_get_object_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_requests[4];\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results[4];\\\\\\\\n    size_t num_meta_requests = AWS_ARRAY_SIZE(meta_requests);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(num_meta_requests == AWS_ARRAY_SIZE(meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        /* Put together a simple S3 Get Object request. */\\\\\\\\n        struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n            allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results[i], allocator);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results[i]));\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request. */\\\\\\\\n        meta_requests[i] = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_requests[i] != NULL);\\\\\\\\n\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        meta_requests[i] = aws_s3_meta_request_release(meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        aws_s3_tester_validate_get_object_results(&meta_request_test_results[i], 0);\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multiple_serial, s_test_s3_get_object_multiple_serial)\\\\\\\\nstatic int s_test_s3_get_object_multiple_serial(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-10MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < 4; ++i) {\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Sleep for some time to wait for the cleanup task to run */\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(7, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    /* BEGIN CRITICAL SECTION */\\\\\\\\n    aws_s3_client_lock_synced_data(client);\\\\\\\\n\\\\\\\\n    AWS_ASSERT(client->synced_data.num_endpoints_allocated == 0);\\\\\\\\n\\\\\\\\n    aws_s3_client_unlock_synced_data(client);\\\\\\\\n    /* END CRITICAL SECTION */\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path, s_test_s3_get_object_file_path)\\\\\\\\nstatic int s_test_s3_get_object_file_path(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_create_new, s_test_s3_get_object_file_path_create_new)\\\\\\\\nstatic int s_test_s3_get_object_file_path_create_new(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_CREATE_NEW,\\\\\\\\n                .pre_exist_file_length = 10,\\\\\\\\n                .recv_file_delete_on_failure = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_RECV_FILE_ALREADY_EXISTS, aws_last_error());\\\\\\\\n\\\\\\\\n    /* The request failed without invoking the finish callback. Reset the finish and shutdown count */\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_shutdown_count);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n    tester.synced_data.desired_meta_request_shutdown_count = 0;\\\\\\\\n    tester.synced_data.desired_meta_request_finish_count = 0;\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    get_options.validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS;\\\\\\\\n    get_options.get_options.pre_exist_file_length = 0;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_append, s_test_s3_get_object_file_path_append)\\\\\\\\nstatic int s_test_s3_get_object_file_path_append(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    uint64_t pre_exist_file_length = 10;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_CREATE_OR_APPEND,\\\\\\\\n                .pre_exist_file_length = pre_exist_file_length,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(pre_exist_file_length + MB_TO_BYTES(1), meta_request_test_results.received_file_size);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), meta_request_test_results.progress.total_bytes_transferred);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_to_position, s_test_s3_get_object_file_path_to_position)\\\\\\\\nstatic int s_test_s3_get_object_file_path_to_position(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    uint64_t pre_exist_file_length = 10;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_WRITE_TO_POSITION,\\\\\\\\n                .pre_exist_file_length = 0,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_RECV_FILE_NOT_FOUND, aws_last_error());\\\\\\\\n\\\\\\\\n    /* The request failed without invoking the finish callback. Reset the finish and shutdown count */\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_shutdown_count);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n    tester.synced_data.desired_meta_request_shutdown_count = 0;\\\\\\\\n    tester.synced_data.desired_meta_request_finish_count = 0;\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    get_options.validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS;\\\\\\\\n    get_options.get_options.pre_exist_file_length = pre_exist_file_length;\\\\\\\\n    get_options.get_options.recv_file_position = 20;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(\\\\\\\\n        get_options.get_options.recv_file_position + MB_TO_BYTES(1), meta_request_test_results.received_file_size);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), meta_request_test_results.progress.total_bytes_transferred);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_empty_object, s_test_s3_get_object_empty_default)\\\\\\\\nstatic int s_test_s3_get_object_empty_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    return (s_test_s3_get_object_helper(allocator, AWS_S3_TLS_ENABLED, 0, g_pre_existing_empty_object));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_sse_kms, s_test_s3_get_object_sse_kms)\\\\\\\\nstatic int s_test_s3_get_object_sse_kms(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Keep TLS enabled for SSE related download, or it will fail. */\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, AWS_S3_TESTER_SEND_META_REQUEST_SSE_KMS, g_pre_existing_object_kms_10MB);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_sse_aes256, s_test_s3_get_object_sse_aes256)\\\\\\\\nstatic int s_test_s3_get_object_sse_aes256(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Keep TLS enabled for SSE related download, or it will fail. */\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, AWS_S3_TESTER_SEND_META_REQUEST_SSE_AES256, g_pre_existing_object_aes256_10MB);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Assert that GetObject can download an object whose body is XML identical to an \\\\\\\\\\\\\"async error\\\\\\\\\\\\\" aka \\\\\\\\\\\\\"200 error\\\\\\\\\\\\\":\\\\\\\\n * <?xml version=\\\\\\\\\\\\\"1.0\\\\\\\\\\\\\" encoding=\\\\\\\\\\\\\"UTF-8\\\\\\\\\\\\\"?>\\\\\\\\\\\\\\\\n<Error><Code>InternalError</Code>... */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_looks_like_async_error_xml, s_test_s3_get_object_looks_like_async_error_xml)\\\\\\\\nstatic int s_test_s3_get_object_looks_like_async_error_xml(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, 0 /*extra_meta_request_flag*/, g_pre_existing_object_async_error_xml);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Same as above, but send the \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\" via AWS_S3_META_REQUEST_TYPE_DEFAULT\\\\\\\\n * (instead of the typical AWS_S3_META_REQUEST_TYPE_GET_OBJECT) */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_default_get_object_looks_like_async_error_xml,\\\\\\\\n    s_test_s3_default_get_object_looks_like_async_error_xml)\\\\\\\\nstatic int s_test_s3_default_get_object_looks_like_async_error_xml(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_async_error_xml,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test read-backpressure functionality by repeatedly:\\\\\\\\n * - letting the download stall\\\\\\\\n * - incrementing the read window\\\\\\\\n * - repeat...\\\\\\\\n */\\\\\\\\nstatic int s_apply_backpressure_until_meta_request_finish(\\\\\\\\n    struct aws_s3_tester *tester,\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results,\\\\\\\\n    size_t part_size,\\\\\\\\n    size_t window_initial_size,\\\\\\\\n    uint64_t window_increment_size) {\\\\\\\\n\\\\\\\\n    /* Remember the last time something happened (we received download data, or incremented read window) */\\\\\\\\n    uint64_t last_time_something_happened;\\\\\\\\n    ASSERT_SUCCESS(aws_sys_clock_get_ticks(&last_time_something_happened));\\\\\\\\n\\\\\\\\n    /* To ensure that backpressure is working, we wait a bit after download stalls\\\\\\\\n     * before incrementing the read window again.\\\\\\\\n     * This number also controls the max time we wait for bytes to start arriving\\\\\\\\n     * after incrementing the window.\\\\\\\\n     * If the magic number is too high the test will be slow,\\\\\\\\n     * if it\\'s too low the test will fail on slow networks */\\\\\\\\n    const uint64_t wait_duration_with_nothing_happening =\\\\\\\\n        aws_timestamp_convert(3, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL);\\\\\\\\n\\\\\\\\n    uint64_t accumulated_window_increments = window_initial_size;\\\\\\\\n    uint64_t accumulated_data_size = 0;\\\\\\\\n\\\\\\\\n    while (true) {\\\\\\\\n        /* Check if meta-request is done (don\\'t exit yet, we want to check some numbers first...) */\\\\\\\\n        aws_s3_tester_lock_synced_data(tester);\\\\\\\\n        bool done = tester->synced_data.meta_requests_finished != 0;\\\\\\\\n        aws_s3_tester_unlock_synced_data(tester);\\\\\\\\n\\\\\\\\n        /* Check how much data we\\'ve received */\\\\\\\\n        size_t received_body_size_delta = aws_atomic_exchange_int(&test_results->received_body_size_delta, 0);\\\\\\\\n        accumulated_data_size += (uint64_t)received_body_size_delta;\\\\\\\\n\\\\\\\\n        /* Check that we haven\\'t received more data than the window allows.\\\\\\\\n         * TODO: Stop allowing \\\\\\\\\\\\\"hacky wiggle room\\\\\\\\\\\\\". The current implementation\\\\\\\\n         *       may push more bytes to the user (up to 1 part) than they\\'ve asked for. */\\\\\\\\n        uint64_t hacky_wiggle_room = part_size;\\\\\\\\n        uint64_t max_data_allowed = accumulated_window_increments + hacky_wiggle_room;\\\\\\\\n        ASSERT_TRUE(accumulated_data_size <= max_data_allowed, \\\\\\\\\\\\\"Received more data than the read window allows\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        /* If we\\'re done, we\\'re done */\\\\\\\\n        if (done) {\\\\\\\\n            break;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Figure out how long it\\'s been since we last received data */\\\\\\\\n        uint64_t current_time;\\\\\\\\n        ASSERT_SUCCESS(aws_sys_clock_get_ticks(&current_time));\\\\\\\\n\\\\\\\\n        if (received_body_size_delta != 0) {\\\\\\\\n            last_time_something_happened = current_time;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        uint64_t duration_since_something_happened = current_time - last_time_something_happened;\\\\\\\\n\\\\\\\\n        /* If it seems like data has stopped flowing... */\\\\\\\\n        if (duration_since_something_happened >= wait_duration_with_nothing_happening) {\\\\\\\\n\\\\\\\\n            /* Assert that data stopped flowing because the window reached 0. */\\\\\\\\n            uint64_t current_window = aws_sub_u64_saturating(accumulated_window_increments, accumulated_data_size);\\\\\\\\n            ASSERT_INT_EQUALS(0, current_window, \\\\\\\\\\\\\"Data stopped flowing but read window isn\\'t 0 yet.\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n            /* Open the window a bit (this resets the \\\\\\\\\\\\\"something happened\\\\\\\\\\\\\" timer */\\\\\\\\n            accumulated_window_increments += window_increment_size;\\\\\\\\n            aws_s3_meta_request_increment_read_window(meta_request, window_increment_size);\\\\\\\\n\\\\\\\\n            last_time_something_happened = current_time;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Sleep a moment, and loop again... */\\\\\\\\n        aws_thread_current_sleep(aws_timestamp_convert(100, AWS_TIMESTAMP_MILLIS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_get_object_backpressure_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    size_t part_size,\\\\\\\\n    size_t window_initial_size,\\\\\\\\n    uint64_t window_increment_size,\\\\\\\\n    bool file_on_disk) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = part_size,\\\\\\\\n        .enable_read_backpressure = true,\\\\\\\\n        .initial_read_window = window_initial_size,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options = {\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .message = message,\\\\\\\\n    };\\\\\\\\n    struct aws_string *filepath_str = NULL;\\\\\\\\n    if (file_on_disk) {\\\\\\\\n        filepath_str = aws_s3_tester_create_file(allocator, g_pre_existing_object_1MB, NULL);\\\\\\\\n        options.recv_filepath = aws_byte_cursor_from_string(filepath_str);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Increment read window bit by bit until all data is downloaded */\\\\\\\\n    ASSERT_SUCCESS(s_apply_backpressure_until_meta_request_finish(\\\\\\\\n        &tester, meta_request, &meta_request_test_results, part_size, window_initial_size, window_increment_size));\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    /* Regression test:\\\\\\\\n     * Ensure that it\\'s safe to call increment-window even after the meta-request has finished */\\\\\\\\n    aws_s3_meta_request_increment_read_window(meta_request, 1024);\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    if (filepath_str) {\\\\\\\\n        aws_file_delete(filepath_str);\\\\\\\\n        aws_string_destroy(filepath_str);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_small_increments, s_test_s3_get_object_backpressure_small_increments)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_small_increments(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments smaller than part-size.\\\\\\\\n     * Only 1 part at a time should be in flight */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_big_increments, s_test_s3_get_object_backpressure_big_increments)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_big_increments(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments larger than part-size.\\\\\\\\n     * Multiple parts should be in flight at a time */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 8;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size * 3;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_initial_size_zero, s_test_s3_get_object_backpressure_initial_size_zero)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_initial_size_zero(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test with initial window size of zero */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 0;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_small_increments_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_small_increments_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_small_increments_recv_filepath(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    /* Test increments smaller than part-size.\\\\\\\\n     * Only 1 part at a time should be in flight */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_big_increments_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_big_increments_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_big_increments_recv_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments larger than part-size.\\\\\\\\n     * Multiple parts should be in flight at a time */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 8;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size * 3;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_initial_size_zero_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_initial_size_zero_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_initial_size_zero_recv_filepath(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    /* Test with initial window size of zero */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 0;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_part, s_test_s3_get_object_part)\\\\\\\\nstatic int s_test_s3_get_object_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/get_object_part_test\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /* GET FILE */\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_NO_VALIDATE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .part_number = 2,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_SUCCESS, meta_request_test_results.finished_error_code);\\\\\\\\n    /* Only one request was made to get the second part of the object */\\\\\\\\n    ASSERT_UINT_EQUALS(1, aws_array_list_length(&meta_request_test_results.synced_data.metrics));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    enum aws_s3_client_tls_usage tls_usage,\\\\\\\\n    uint32_t extra_meta_request_flag) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_connection_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_connection_options);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    struct aws_tls_ctx_options tls_context_options;\\\\\\\\n    aws_tls_ctx_options_init_default_client(&tls_context_options, allocator);\\\\\\\\n\\\\\\\\n    struct aws_tls_ctx *context = aws_tls_client_ctx_new(allocator, &tls_context_options);\\\\\\\\n    aws_tls_connection_options_init_from_ctx(&tls_connection_options, context);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    struct aws_string *endpoint =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n    struct aws_byte_cursor endpoint_cursor = aws_byte_cursor_from_string(endpoint);\\\\\\\\n\\\\\\\\n    tls_connection_options.server_name = aws_string_new_from_cursor(allocator, &endpoint_cursor);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    switch (tls_usage) {\\\\\\\\n        case AWS_S3_TLS_ENABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n            client_config.tls_connection_options = &tls_connection_options;\\\\\\\\n            break;\\\\\\\\n        case AWS_S3_TLS_DISABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_DISABLED;\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_put_object_meta_request(\\\\\\\\n        &tester, client, 10, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS | extra_meta_request_flag, NULL));\\\\\\\\n\\\\\\\\n    aws_string_destroy(endpoint);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    aws_tls_ctx_release(context);\\\\\\\\n    aws_tls_connection_options_clean_up(&tls_connection_options);\\\\\\\\n    aws_tls_ctx_options_clean_up(&tls_context_options);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_disabled, s_test_s3_put_object_tls_disabled)\\\\\\\\nstatic int s_test_s3_put_object_tls_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DISABLED, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_enabled, s_test_s3_put_object_tls_enabled)\\\\\\\\nstatic int s_test_s3_put_object_tls_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_ENABLED, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_default, s_test_s3_put_object_tls_default)\\\\\\\\nstatic int s_test_s3_put_object_tls_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DEFAULT, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_put_object_with_acl, s_test_s3_multipart_put_object_with_acl)\\\\\\\\nstatic int s_test_s3_multipart_put_object_with_acl(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DEFAULT, AWS_S3_TESTER_SEND_META_REQUEST_PUT_ACL));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_multiple_helper(struct aws_allocator *allocator, bool file_on_disk) {\\\\\\\\n\\\\\\\\n    enum s_numbers { NUM_REQUESTS = 5 };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_requests[NUM_REQUESTS];\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results[NUM_REQUESTS];\\\\\\\\n    struct aws_http_message *messages[NUM_REQUESTS];\\\\\\\\n    struct aws_input_stream *input_streams[NUM_REQUESTS];\\\\\\\\n    struct aws_byte_buf input_stream_buffers[NUM_REQUESTS];\\\\\\\\n    struct aws_string *filepath_str[NUM_REQUESTS];\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    size_t content_length = MB_TO_BYTES(10);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results[i], allocator);\\\\\\\\n        char object_path_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n        snprintf(\\\\\\\\n            object_path_buffer,\\\\\\\\n            sizeof(object_path_buffer),\\\\\\\\n            \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-10MB-%zu.txt\\\\\\\\\\\\\",\\\\\\\\n            AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n            i);\\\\\\\\n        AWS_ZERO_STRUCT(input_stream_buffers[i]);\\\\\\\\n        aws_s3_create_test_buffer(allocator, content_length, &input_stream_buffers[i]);\\\\\\\\n        struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&input_stream_buffers[i]);\\\\\\\\n        input_streams[i] = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n        struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(object_path_buffer);\\\\\\\\n        struct aws_byte_cursor host_cur = aws_byte_cursor_from_string(host_name);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT;\\\\\\\\n        if (file_on_disk) {\\\\\\\\n            filepath_str[i] = aws_s3_tester_create_file(allocator, test_object_path, input_streams[i]);\\\\\\\\n            messages[i] = aws_s3_test_put_object_request_new_without_body(\\\\\\\\n                allocator, &host_cur, g_test_body_content_type, test_object_path, content_length, 0 /*flags*/);\\\\\\\\n            options.send_filepath = aws_byte_cursor_from_string(filepath_str[i]);\\\\\\\\n        } else {\\\\\\\\n            filepath_str[i] = NULL;\\\\\\\\n            messages[i] = aws_s3_test_put_object_request_new(\\\\\\\\n                allocator, &host_cur, test_object_path, g_test_body_content_type, input_streams[i], 0);\\\\\\\\n        }\\\\\\\\n        options.message = messages[i];\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results[i]));\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Put Object request. */\\\\\\\\n        meta_requests[i] = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_requests[i] != NULL);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        meta_requests[i] = aws_s3_meta_request_release(meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_s3_tester_validate_get_object_results(&meta_request_test_results[i], 0);\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_http_message_release(messages[i]);\\\\\\\\n        aws_input_stream_release(input_streams[i]);\\\\\\\\n        aws_byte_buf_clean_up(&input_stream_buffers[i]);\\\\\\\\n        if (filepath_str[i]) {\\\\\\\\n            ASSERT_SUCCESS(aws_file_delete(filepath_str[i]));\\\\\\\\n            aws_string_destroy(filepath_str[i]);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multiple, s_test_s3_put_object_multiple)\\\\\\\\nstatic int s_test_s3_put_object_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_put_object_multiple_helper(allocator, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multiple_with_filepath, s_test_s3_put_object_multiple_with_filepath)\\\\\\\\nstatic int s_test_s3_put_object_multiple_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_put_object_multiple_helper(allocator, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_less_than_part_size, s_test_s3_put_object_less_than_part_size)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_buffer_pool_trim, s_test_s3_put_object_buffer_pool_trim)\\\\\\\\nstatic int s_test_s3_put_object_buffer_pool_trim(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 8 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 32,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    struct aws_s3_buffer_pool_usage_stats usage_before = aws_s3_buffer_pool_get_usage(client->buffer_pool);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(0 != usage_before.primary_num_blocks);\\\\\\\\n\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(6, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    struct aws_s3_buffer_pool_usage_stats usage_after = aws_s3_buffer_pool_get_usage(client->buffer_pool);\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(0, usage_after.primary_num_blocks);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_less_than_part_size_with_content_encoding,\\\\\\\\n    s_test_s3_put_object_less_than_part_size_with_content_encoding)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size_with_content_encoding(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor content_encoding_cursor = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"gzip\\\\\\\\\\\\\");\\\\\\\\n    uint32_t object_size_mb = 1;\\\\\\\\n    char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n    snprintf(\\\\\\\\n        object_path_sprintf_buffer,\\\\\\\\n        sizeof(object_path_sprintf_buffer),\\\\\\\\n        \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-content-encoding-%uMB.txt\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n        object_size_mb);\\\\\\\\n    struct aws_byte_cursor object_path_cursor = aws_byte_cursor_from_c_str(object_path_sprintf_buffer);\\\\\\\\n\\\\\\\\n    /*** put file with encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_SHA256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path_cursor,\\\\\\\\n                .content_encoding = content_encoding_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** get file and validate encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results get_object_result;\\\\\\\\n    aws_s3_meta_request_test_results_init(&get_object_result, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &get_object_result));\\\\\\\\n    struct aws_byte_cursor content_encoding_header_cursor;\\\\\\\\n    ASSERT_SUCCESS(aws_http_headers_get(\\\\\\\\n        get_object_result.response_headers, g_content_encoding_header_name, &content_encoding_header_cursor));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq(&content_encoding_cursor, &content_encoding_header_cursor));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&get_object_result);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_mpu_with_content_encoding, s_test_s3_put_object_mpu_with_content_encoding)\\\\\\\\nstatic int s_test_s3_put_object_mpu_with_content_encoding(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor content_encoding_cursor = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"gzip\\\\\\\\\\\\\");\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n    char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n    snprintf(\\\\\\\\n        object_path_sprintf_buffer,\\\\\\\\n        sizeof(object_path_sprintf_buffer),\\\\\\\\n        \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-content-encoding-%uMB.txt\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n        object_size_mb);\\\\\\\\n    struct aws_byte_cursor object_path_cursor = aws_byte_cursor_from_c_str(object_path_sprintf_buffer);\\\\\\\\n\\\\\\\\n    /*** put file with encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_SHA256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path_cursor,\\\\\\\\n                .content_encoding = content_encoding_cursor,\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** get file and validate encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results get_object_result;\\\\\\\\n    aws_s3_meta_request_test_results_init(&get_object_result, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &get_object_result));\\\\\\\\n    struct aws_byte_cursor content_encoding_header_cursor;\\\\\\\\n    ASSERT_SUCCESS(aws_http_headers_get(\\\\\\\\n        get_object_result.response_headers, g_content_encoding_header_name, &content_encoding_header_cursor));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq(&content_encoding_cursor, &content_encoding_header_cursor));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&get_object_result);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multipart_threshold, s_test_s3_put_object_multipart_threshold)\\\\\\\\nstatic int s_test_s3_put_object_multipart_threshold(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n        .multipart_upload_threshold = MB_TO_BYTES(15),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    /* First smaller than the part size */\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 5,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a single part upload, and have 0 as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(0, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    /* Second smaller than threshold and larger than part size */\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    put_options.put_options.object_size_mb = 10;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a single part upload, and have 0 as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(0, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    /* Third larger than threshold*/\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    put_options.put_options.object_size_mb = 20;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in multi-part upload, and have the real part size */\\\\\\\\n    ASSERT_UINT_EQUALS(client_config.part_size, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_threshold_less_than_part_size,\\\\\\\\n    s_test_s3_put_object_multipart_threshold_less_than_part_size)\\\\\\\\nstatic int s_test_s3_put_object_multipart_threshold_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n        .multipart_upload_threshold = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    /* First smaller than the part size */\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 6,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a one part of multipart upload, and have the content length as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(put_options.put_options.object_size_mb), meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_empty_object, s_test_s3_put_object_empty_object)\\\\\\\\nstatic int s_test_s3_put_object_empty_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 0,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s3_no_content_length_test_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    uint32_t object_size_in_mb,\\\\\\\\n    bool use_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = use_checksum ? AWS_SCA_CRC32 : AWS_SCA_NONE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_in_mb,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_no_content_length, s_test_s3_put_object_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 19, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_single_part_no_content_length, s_test_s3_put_object_single_part_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_single_part_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 5, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_zero_size_no_content_length, s_test_s3_put_object_zero_size_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_zero_size_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 0, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_large_object_no_content_length_with_checksum,\\\\\\\\n    s_test_s3_put_large_object_no_content_length_with_checksum)\\\\\\\\nstatic int s_test_s3_put_large_object_no_content_length_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 128, true));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Once upon a time, we have a bug that without content-length, we will schedule more requests to prepare than needed.\\\\\\\\n * And those extra request will be cleaned up, however, the client level count of `num_requests_being_prepared` will\\\\\\\\n * still keep record for those.\\\\\\\\n *\\\\\\\\n * To reproduce, we create bunch of requests with less than a part body. And then sleep for a while to let dns resolve\\\\\\\\n * purge all records. (Otherwise, we will always have one valid request to be available to send.) to trigger not going\\\\\\\\n * full speed code. And we will hang.\\\\\\\\n *\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_no_content_length_multiple, s_test_s3_put_object_no_content_length_multiple)\\\\\\\\nstatic int s_test_s3_put_object_no_content_length_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    aws_s3_set_dns_ttl(55);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    for (int i = 0; i < 6; i++) {\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    }\\\\\\\\n    /* Sleep more than the DNS ttl to purge all records. */\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(60, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    /* After sleep for a while, make another meta request */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream when we\\'re not doing multipart upload */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_singlepart, s_test_s3_put_object_async_singlepart)\\\\\\\\nstatic int s_test_s3_put_object_async_singlepart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 4,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream in multipart upload */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_multipart, s_test_s3_put_object_async_multipart)\\\\\\\\nstatic int s_test_s3_put_object_async_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 16,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, but the aws_async_input_stream_read() calls all complete synchronously */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_read_completes_synchronously,\\\\\\\\n    s_test_s3_put_object_async_read_completes_synchronously)\\\\\\\\nstatic int s_test_s3_put_object_async_read_completes_synchronously(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .async_read_strategy = AWS_ASYNC_READ_COMPLETES_IMMEDIATELY,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, where it takes multiple read() calls to fill each part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_small_reads, s_test_s3_put_object_async_small_reads)\\\\\\\\nstatic int s_test_s3_put_object_async_small_reads(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .max_bytes_per_read = KB_TO_BYTES(1001), /* something that doesn\\'t evenly divide into 8MB parts */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test synchronous input-stream, where it takes multiple read() calls to fill each part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_small_reads, s_test_s3_put_object_small_reads)\\\\\\\\nstatic int s_test_s3_put_object_small_reads(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .max_bytes_per_read = KB_TO_BYTES(1001), /* something that doesn\\'t evenly divide into 8MB parts */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that doesn\\'t end exactly on a part boundary */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_no_content_length_partial_part,\\\\\\\\n    s_test_s3_put_object_async_no_content_length_partial_part)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_partial_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 3,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that fills exactly 1 part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_no_content_length_1part, s_test_s3_put_object_async_no_content_length_1part)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_1part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 8,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that doesn\\'t realize\\\\\\\\n * it\\'s at EOF until it tries to read the 2nd part and gets 0 bytes */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_no_content_length_empty_part2,\\\\\\\\n    s_test_s3_put_object_async_no_content_length_empty_part2)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_empty_part2(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 8,             /* read 1 part\\'s worth of data */\\\\\\\\n                .eof_requires_extra_read = true, /* don\\'t report EOF until it tries to read 2nd part */\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that fills multiple parts */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_no_content_length_2parts, s_test_s3_put_object_async_no_content_length_2parts)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_2parts(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 16,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_fail_reading, s_test_s3_put_object_async_fail_reading)\\\\\\\\nstatic int s_test_s3_put_object_async_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(AWS_IO_STREAM_READ_FAILED, test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_validate_if_none_match_failure_response(struct aws_s3_meta_request_test_results *test_results) {\\\\\\\\n\\\\\\\\n    /**\\\\\\\\n     * response body should be like:\\\\\\\\n     * <Error>\\\\\\\\n     * <Code>PreconditionFailed</Code>\\\\\\\\n     * <Message>At least one of the pre-conditions you specified did not hold</Message>\\\\\\\\n     * <Condition>If-None-Match</Condition>\\\\\\\\n     * <RequestId></RequestId>\\\\\\\\n     * <HostId></HostId>\\\\\\\\n     * </Error>\\\\\\\\n     */\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor xml_doc = aws_byte_cursor_from_buf(&test_results->error_response_body);\\\\\\\\n    struct aws_byte_cursor error_code_string = {0};\\\\\\\\n    struct aws_byte_cursor condition_string = {0};\\\\\\\\n\\\\\\\\n    const char *error_code_path[] = {\\\\\\\\\\\\\"Error\\\\\\\\\\\\\", \\\\\\\\\\\\\"Code\\\\\\\\\\\\\", NULL};\\\\\\\\n    ASSERT_SUCCESS(aws_xml_get_body_at_path(test_results->allocator, xml_doc, error_code_path, &error_code_string));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq_c_str(&error_code_string, \\\\\\\\\\\\\"PreconditionFailed\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    const char *condition_path[] = {\\\\\\\\\\\\\"Error\\\\\\\\\\\\\", \\\\\\\\\\\\\"Condition\\\\\\\\\\\\\", NULL};\\\\\\\\n    ASSERT_SUCCESS(aws_xml_get_body_at_path(test_results->allocator, xml_doc, condition_path, &condition_string));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq_c_str(&condition_string, \\\\\\\\\\\\\"If-None-Match\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_if_none_match, s_test_s3_put_object_if_none_match)\\\\\\\\nstatic int s_test_s3_put_object_if_none_match(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n    struct aws_byte_cursor if_none_match_all = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Use pre_exist object so that the request should fail with the expected failure message. */\\\\\\\\n                .object_path_override = g_pre_existing_object_1MB,\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .if_none_match_header = if_none_match_all,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_HTTP_STATUS_CODE_412_PRECONDITION_FAILED, test_results.finished_response_status);\\\\\\\\n    ASSERT_SUCCESS(s_test_validate_if_none_match_failure_response(&test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_mpu_if_none_match, s_test_s3_put_object_mpu_if_none_match)\\\\\\\\nstatic int s_test_s3_put_object_mpu_if_none_match(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n    struct aws_byte_cursor if_none_match_all = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Use pre_exist object so that the request should fail with the expected failure message. */\\\\\\\\n                .object_path_override = g_pre_existing_object_10MB,\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .if_none_match_header = if_none_match_all,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /** Complete MPU can fail with 200 error */\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        AWS_HTTP_STATUS_CODE_412_PRECONDITION_FAILED == test_results.finished_response_status ||\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK == test_results.finished_response_status);\\\\\\\\n    ASSERT_SUCCESS(s_test_validate_if_none_match_failure_response(&test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_kms, s_test_s3_put_object_sse_kms)\\\\\\\\nstatic int s_test_s3_put_object_sse_kms(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_kms_multipart, s_test_s3_put_object_sse_kms_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_kms_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_aes256, s_test_s3_put_object_sse_aes256)\\\\\\\\nstatic int s_test_s3_put_object_sse_aes256(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_aes256_multipart, s_test_s3_put_object_sse_aes256_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_aes256_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_c_aes256_multipart, s_test_s3_put_object_sse_c_aes256_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_c_aes256_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    (void)allocator;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        tester.allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_sse_c.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_C_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_sse_c_aes256_multipart_with_checksum,\\\\\\\\n    s_test_s3_put_object_sse_c_aes256_multipart_with_checksum)\\\\\\\\nstatic int s_test_s3_put_object_sse_c_aes256_multipart_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        tester.allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_sse_c_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_C_AES256,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_content_md5_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    bool multipart_upload,\\\\\\\\n    uint32_t flags,\\\\\\\\n    enum aws_s3_meta_request_compute_content_md5 compute_content_md5) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    size_t part_size = 5 * 1024 * 1024;\\\\\\\\n    if (!multipart_upload) {\\\\\\\\n        /* content_length < part_size */\\\\\\\\n        part_size = 15 * 1024 * 1024;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = part_size,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    client_config.compute_content_md5 = compute_content_md5;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_put_object_meta_request(&tester, client, 10, flags, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_no_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_no_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_no_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_no_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_no_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_no_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_correct_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_correct_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_correct_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_correct_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_correct_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_correct_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_incorrect_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_incorrect_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_incorrect_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_incorrect_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_incorrect_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_incorrect_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_no_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_no_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_no_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_no_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_no_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_no_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_correct_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_correct_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_correct_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_correct_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_correct_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_correct_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_incorrect_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_incorrect_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_incorrect_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_incorrect_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_incorrect_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_incorrect_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_upload_part_message_helper(struct aws_allocator *allocator, bool should_compute_content_md5) {\\\\\\\\n\\\\\\\\n    aws_s3_library_init(allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n    /* base64 encoded md5 of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */\\\\\\\\n    struct aws_byte_cursor expected_content_md5 = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"+y3U+EY5uFXhVVmRoiJWyA==\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    uint32_t part_number = 1;\\\\\\\\n    struct aws_string *upload_id = aws_string_new_from_c_str(allocator, \\\\\\\\\\\\\"dummy_upload_id\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message = aws_s3_upload_part_message_new(\\\\\\\\n        allocator, base_message, &test_buffer, part_number, upload_id, should_compute_content_md5, NULL, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    if (should_compute_content_md5) {\\\\\\\\n        ASSERT_TRUE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n        struct aws_byte_cursor content_md5;\\\\\\\\n        aws_http_headers_get(new_headers, g_content_md5_header_name, &content_md5);\\\\\\\\n        ASSERT_BIN_ARRAYS_EQUALS(expected_content_md5.ptr, expected_content_md5.len, content_md5.ptr, content_md5.len);\\\\\\\\n    } else {\\\\\\\\n        ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(upload_id);\\\\\\\\n    upload_id = NULL;\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    aws_s3_library_clean_up();\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_part_message_with_content_md5, s_test_s3_upload_part_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_upload_part_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_upload_part_message_helper(allocator, true));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_part_message_without_content_md5, s_test_s3_upload_part_message_without_content_md5)\\\\\\\\nstatic int s_test_s3_upload_part_message_without_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_upload_part_message_helper(allocator, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_create_multipart_upload_message_with_content_md5,\\\\\\\\n    s_test_s3_create_multipart_upload_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_create_multipart_upload_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_md5_header = {\\\\\\\\n        .name = g_content_md5_header_name,\\\\\\\\n        .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_content_md5\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_http_message_add_header(base_message, content_md5_header));\\\\\\\\n\\\\\\\\n    struct aws_http_headers *base_headers = aws_http_message_get_headers(base_message);\\\\\\\\n    ASSERT_TRUE(aws_http_headers_has(base_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message = aws_s3_create_multipart_upload_message_new(allocator, base_message, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_complete_multipart_message_with_content_md5,\\\\\\\\n    s_test_s3_complete_multipart_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_complete_multipart_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_md5_header = {\\\\\\\\n        .name = g_content_md5_header_name,\\\\\\\\n        .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_content_md5\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_http_message_add_header(base_message, content_md5_header));\\\\\\\\n\\\\\\\\n    struct aws_http_headers *base_headers = aws_http_message_get_headers(base_message);\\\\\\\\n    ASSERT_TRUE(aws_http_headers_has(base_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf body_buffer;\\\\\\\\n    aws_byte_buf_init(&body_buffer, allocator, 512);\\\\\\\\n\\\\\\\\n    struct aws_string *upload_id = aws_string_new_from_c_str(allocator, \\\\\\\\\\\\\"dummy_upload_id\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_array_list parts;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_init_dynamic(&parts, allocator, 0, sizeof(struct aws_s3_mpu_part_info *)));\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message =\\\\\\\\n        aws_s3_complete_multipart_message_new(allocator, base_message, &body_buffer, upload_id, &parts, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_array_list_clean_up(&parts);\\\\\\\\n\\\\\\\\n    aws_string_destroy(upload_id);\\\\\\\\n    upload_id = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&body_buffer);\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_double_slashes, s_test_s3_put_object_double_slashes)\\\\\\\\nstatic int s_test_s3_put_object_double_slashes(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix//test.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip, s_test_s3_round_trip)\\\\\\\\nstatic int s_test_s3_round_trip(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get, s_test_s3_round_trip_default_get)\\\\\\\\nstatic int s_test_s3_round_trip_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_default.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_validate_headers_checksum_set(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)headers;\\\\\\\\n    struct aws_s3_meta_request_test_results *meta_request_test_results =\\\\\\\\n        (struct aws_s3_meta_request_test_results *)user_data;\\\\\\\\n    ASSERT_NOT_NULL(meta_request->meta_request_level_running_response_sum);\\\\\\\\n    ASSERT_INT_EQUALS(\\\\\\\\n        meta_request->meta_request_level_running_response_sum->algorithm, meta_request_test_results->algorithm);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_validate_headers_checksum_unset(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)user_data;\\\\\\\\n    ASSERT_NULL(meta_request->meta_request_level_running_response_sum);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nvoid s_s3_test_validate_checksum(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *result,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    struct aws_s3_meta_request_test_results *meta_request_test_results =\\\\\\\\n        (struct aws_s3_meta_request_test_results *)user_data;\\\\\\\\n    AWS_FATAL_ASSERT(result->did_validate);\\\\\\\\n    AWS_FATAL_ASSERT(result->validation_algorithm == meta_request_test_results->algorithm);\\\\\\\\n    AWS_FATAL_ASSERT(result->error_code == AWS_OP_SUCCESS);\\\\\\\\n}\\\\\\\\nvoid s_s3_test_no_validate_checksum(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *result,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)user_data;\\\\\\\\n    AWS_FATAL_ASSERT(!result->did_validate);\\\\\\\\n    AWS_FATAL_ASSERT(result->error_code == AWS_OP_SUCCESS);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* TODO: maybe refactor the fc -> flexible checksum tests to be less copy/paste */\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header,\\\\\\\\n    uint32_t object_size_mb,\\\\\\\\n    enum aws_s3_tester_full_object_checksum full_object_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_ARRAY_SIZE(s_checksum_algo_priority_list); i++) {\\\\\\\\n        enum aws_s3_checksum_algorithm algorithm = s_checksum_algo_priority_list[i];\\\\\\\\n        char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n        snprintf(\\\\\\\\n            object_path_sprintf_buffer,\\\\\\\\n            sizeof(object_path_sprintf_buffer),\\\\\\\\n            \\\\\\\\\\\\\"/prefix/round_trip/test_default_fc_%d_%d.txt\\\\\\\\\\\\\",\\\\\\\\n            algorithm,\\\\\\\\n            object_size_mb);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n            allocator, &path_buf, aws_byte_cursor_from_c_str(object_path_sprintf_buffer)));\\\\\\\\n        struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n        /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n        struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n            .client = client,\\\\\\\\n            .checksum_algorithm = algorithm,\\\\\\\\n            .validate_get_response_checksum = false,\\\\\\\\n            .checksum_via_header = via_header,\\\\\\\\n            .put_options =\\\\\\\\n                {\\\\\\\\n                    .object_size_mb = object_size_mb,\\\\\\\\n                    .object_path_override = object_path,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n        if (algorithm != AWS_SCA_SHA1 && algorithm != AWS_SCA_SHA256) {\\\\\\\\n            /* Full object checksums doesn\\'t support SHA. */\\\\\\\\n            put_options.put_options.full_object_checksum = full_object_checksum;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n        /*** GET FILE ***/\\\\\\\\n\\\\\\\\n        struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .client = client,\\\\\\\\n            .expected_validate_checksum_alg = algorithm,\\\\\\\\n            .validate_get_response_checksum = true,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = object_path,\\\\\\\\n                },\\\\\\\\n            .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n            .headers_callback = s_s3_validate_headers_checksum_set,\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n        aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get_fc, s_test_s3_round_trip_default_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 1 /*object_size_mb*/, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_empty_fc, s_test_s3_round_trip_empty_fc)\\\\\\\\nstatic int s_test_s3_round_trip_empty_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 0, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get_fc_header, s_test_s3_round_trip_default_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, true, 1, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_default_get_full_object_checksum_fc,\\\\\\\\n    s_test_s3_round_trip_default_get_full_object_checksum_fc)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_full_object_checksum_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 1, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc_helper(struct aws_allocator *allocator, void *ctx, bool via_header) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC64NVME,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC64NVME,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .headers_callback = s_s3_validate_headers_checksum_set,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_multipart_get_fc, s_test_s3_round_trip_multipart_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_multipart_get_fc_helper(allocator, ctx, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_multipart_get_fc_header, s_test_s3_round_trip_multipart_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_multipart_get_fc_helper(allocator, ctx, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test the multipart uploaded object was downloaded with same part size, which will download the object matches all the\\\\\\\\n * parts and validate the parts checksum. */\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header,\\\\\\\\n    enum aws_s3_tester_full_object_checksum full_object_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n    struct aws_byte_cursor object_name;\\\\\\\\n    /* Use different name to avoid collision when tests run concurrently. */\\\\\\\\n    switch (full_object_checksum) {\\\\\\\\n        case AWS_TEST_FOC_CALLBACK:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc_full_object_via_callback.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n        case AWS_TEST_FOC_HEADER:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc_full_object_via_header.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(allocator, &path_buf, object_name));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .full_object_checksum = full_object_checksum,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_multipart_get_fc, s_test_s3_round_trip_mpu_multipart_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_multipart_get_fc_header, s_test_s3_round_trip_mpu_multipart_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, true, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, true, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_CALLBACK);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/empty-file-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 0,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE WITH GET_FIRST_PART ***/\\\\\\\\n    uint64_t small_object_size_hint = 1;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .object_size_hint =\\\\\\\\n            &small_object_size_hint /* pass a object_size_hint > 0 so that the request goes through the getPart flow */,\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE WITH HEAD_OBJECT ***/\\\\\\\\n    get_options.object_size_hint = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_empty_file_with_checksum, s_test_s3_download_empty_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_download_empty_file_with_checksum_helper(allocator, ctx, false);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(test_s3_download_empty_file_with_checksum_header, s_test_s3_download_empty_file_with_checksum_header)\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_download_empty_file_with_checksum_helper(allocator, ctx, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_single_part_file_with_checksum, s_test_s3_download_single_part_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_single_part_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(10),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/single-part-10Mb-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    uint64_t object_size_hint = MB_TO_BYTES(object_size_mb);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .object_size_hint = &object_size_hint,\\\\\\\\n    };\\\\\\\\n    uint64_t small_object_size_hint = MB_TO_BYTES(1);\\\\\\\\n\\\\\\\\n    /* will do headRequest */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(20);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n\\\\\\\\n    /* will do getPart */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /* will do getPart */\\\\\\\\n    /*** GET FILE with part_size = file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(10);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < file_size and wrong object_size_hint ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.object_size_hint = &small_object_size_hint;\\\\\\\\n    /* will do getPart first, cancel it and then rangedGet */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_multipart_file_with_checksum, s_test_s3_download_multipart_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_multipart_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/multipart-10Mb-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    uint64_t object_size_hint = MB_TO_BYTES(object_size_mb);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .object_size_hint = &object_size_hint,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* will do HeadRequest first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(7);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    /* will do HeadObject first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size = first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(5);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    /* will do HeadObject First */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    uint64_t small_object_size_hint = 1;\\\\\\\\n\\\\\\\\n    /*** GET FILE with with wrong object_size_hint ***/\\\\\\\\n    get_options.object_size_hint = &small_object_size_hint;\\\\\\\\n    get_options.finish_callback = NULL;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < first_part_size***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n\\\\\\\\n    /* will do GetPart, cancel the request and then do ranged Gets. */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(7);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n\\\\\\\\n    /* will do GetPart first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size = first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(5);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    /* will do GetPart first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > fileSize ***/\\\\\\\\n    /* TODO: Enable this test once the checksum issue is resolved. Currently, when the S3 GetObject API is called with\\\\\\\\n     * the range 0-contentLength, it returns a checksum of checksums without the -numParts portion. This leads to a\\\\\\\\n     * checksum mismatch error, as it is incorrectly validated as a part checksum. */\\\\\\\\n    /*\\\\\\\\n    client_options.part_size = MB_TO_BYTES(20);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n    */\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_array_list response_checksum_list;\\\\\\\\n    /* Check for all algorithm but the CRC32 */\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_array_list_init_dynamic(&response_checksum_list, allocator, 4, sizeof(enum aws_s3_checksum_algorithm)));\\\\\\\\n    enum aws_s3_checksum_algorithm alg = AWS_SCA_CRC32C;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    alg = AWS_SCA_SHA1;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    alg = AWS_SCA_SHA256;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .validate_checksum_algorithms = &response_checksum_list,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_no_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    /* Push all the algorithms to the list for validation, now we should have the checksum validated. */\\\\\\\\n    alg = AWS_SCA_CRC32;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_array_list_clean_up(&response_checksum_list);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_default_get_fc, s_test_s3_round_trip_mpu_default_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_default_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_default_get_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_no_validate_checksum,\\\\\\\\n        .headers_callback = s_s3_validate_headers_checksum_unset,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor key,\\\\\\\\n    int object_size_mb,\\\\\\\\n    bool unknown_content_length) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(allocator, &path_buf, key));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .skip_content_length = unknown_content_length,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(\\\\\\\\n        MB_TO_BYTES(put_options.put_options.object_size_mb), test_results.progress.total_bytes_transferred);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_with_filepath, s_test_s3_round_trip_with_filepath)\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath\\\\\\\\\\\\\"), 1, false /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_with_filepath, s_test_s3_round_trip_mpu_with_filepath)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_mpu\\\\\\\\\\\\\"),\\\\\\\\n        50,\\\\\\\\n        false /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_with_filepath_no_content_length, s_test_s3_round_trip_with_filepath_no_content_length)\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_no_content_length\\\\\\\\\\\\\"),\\\\\\\\n        1,\\\\\\\\n        true /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_with_filepath_no_content_length,\\\\\\\\n    s_test_s3_round_trip_mpu_with_filepath_no_content_length)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_with_filepath_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_mpu_no_content_length\\\\\\\\\\\\\"),\\\\\\\\n        50,\\\\\\\\n        true /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_chunked_then_unchunked, s_test_s3_chunked_then_unchunked)\\\\\\\\nstatic int s_test_s3_chunked_then_unchunked(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Test to see if signed_body_value modified when signing chunked request */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/chunked_unchunked/test_chunked.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor chunked_object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options chunked_put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = chunked_object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &chunked_put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/chunked_unchunked/test_unchunked.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor unchunked_object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options unchunked_put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_NONE,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = unchunked_object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &unchunked_put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_meta_request_default, s_test_s3_meta_request_default)\\\\\\\\nstatic int s_test_s3_meta_request_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n\\\\\\\\n    /* Pass the request through as a default request so that it goes through as-is. */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    /* Check the size of the metrics should be the same as the number of\\\\\\\\n    requests, which should be 1 */\\\\\\\\n    ASSERT_UINT_EQUALS(1, aws_array_list_length(&meta_request_test_results.synced_data.metrics));\\\\\\\\n    struct aws_s3_request_metrics *metrics = NULL;\\\\\\\\n    aws_array_list_back(&meta_request_test_results.synced_data.metrics, (void **)&metrics);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_error_missing_file, s_test_s3_error_missing_file)\\\\\\\\nstatic int s_test_s3_error_missing_file(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor test_object_path =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/non-existing-file12345.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message =\\\\\\\\n        aws_s3_test_get_object_request_new(allocator, aws_byte_cursor_from_string(host_name), test_object_path);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_response_status == 404);\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.error_response_headers != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_NOT_NULL(meta_request_test_results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(meta_request_test_results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(meta_request_test_results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_test_s3_existing_host_entry_address_resolved_callback(\\\\\\\\n    struct aws_host_resolver *resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    int err_code,\\\\\\\\n    const struct aws_array_list *host_addresses,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)err_code;\\\\\\\\n    (void)host_addresses;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = user_data;\\\\\\\\n    AWS_ASSERT(tester);\\\\\\\\n    aws_s3_tester_notify_signal(tester);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_existing_host_entry, s_test_s3_existing_host_entry)\\\\\\\\nstatic int s_test_s3_existing_host_entry(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_host_resolution_config host_resolver_config;\\\\\\\\n        AWS_ZERO_STRUCT(host_resolver_config);\\\\\\\\n        host_resolver_config.impl = aws_default_dns_resolve;\\\\\\\\n        host_resolver_config.max_ttl = 30;\\\\\\\\n        host_resolver_config.impl_data = NULL;\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_host_resolver_resolve_host(\\\\\\\\n            client_config.client_bootstrap->host_resolver,\\\\\\\\n            host_name,\\\\\\\\n            s_test_s3_existing_host_entry_address_resolved_callback,\\\\\\\\n            &host_resolver_config,\\\\\\\\n            &tester));\\\\\\\\n\\\\\\\\n        aws_s3_tester_wait_for_signal(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_bad_endpoint, s_test_s3_bad_endpoint)\\\\\\\\nstatic int s_test_s3_bad_endpoint(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"test_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    AWS_STATIC_STRING_FROM_LITERAL(invalid_host_name, \\\\\\\\\\\\\"invalid_host_name_totally_absolutely\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Construct a message that points to an invalid host name. Key can be anything. */\\\\\\\\n    struct aws_http_message *message =\\\\\\\\n        aws_s3_test_get_object_request_new(allocator, aws_byte_cursor_from_string(invalid_host_name), test_key);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(&tester, client, &options, &meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        meta_request_test_results.finished_error_code == AWS_IO_DNS_INVALID_NAME ||\\\\\\\\n        meta_request_test_results.finished_error_code == AWS_IO_DNS_QUERY_FAILED);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_raise_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_body_callback_raise_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)body;\\\\\\\\n    (void)range_start;\\\\\\\\n    (void)user_data;\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_fail_headers_callback, s_test_s3_put_object_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_put_object_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_fail_body_callback, s_test_s3_put_object_fail_body_callback)\\\\\\\\nstatic int s_test_s3_put_object_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n\\\\\\\\n        /* Put object currently never invokes the body callback, which means it should not fail. */\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, NULL));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_fail_headers_callback, s_test_s3_get_object_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_get_object_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_fail_body_callback, s_test_s3_get_object_fail_body_callback)\\\\\\\\nstatic int s_test_s3_get_object_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_headers_callback, s_test_s3_default_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_default_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_atomic_var s_test_headers_callback_invoked;\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_check_returns_success(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    /* increments counter to check if callback was invoked exactly once */\\\\\\\\n    aws_atomic_fetch_add(&s_test_headers_callback_invoked, 1);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_check_returns_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    /* increments counter to check if callback was invoked exactly once */\\\\\\\\n    aws_atomic_fetch_add(&s_test_headers_callback_invoked, 1);\\\\\\\\n\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_invoke_headers_callback_on_error, s_test_s3_default_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_default_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_default_invoke_headers_callback_cancels_on_error,\\\\\\\\n    s_test_s3_default_invoke_headers_callback_cancels_on_error)\\\\\\\\nstatic int s_test_s3_default_invoke_headers_callback_cancels_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_invoke_headers_callback_on_error,\\\\\\\\n    s_test_s3_get_object_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_get_object_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_invoke_headers_callback_on_error,\\\\\\\\n    s_test_s3_put_object_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_put_object_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .invalid_request = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INVALID_RESPONSE_STATUS, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation,\\\\\\\\n    s_test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation)\\\\\\\\nstatic int s_test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_UNKNOWN, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_body_callback, s_test_s3_default_fail_body_callback)\\\\\\\\nstatic int s_test_s3_default_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that if a DEFAULt meta-request sets the operation_name, and gets an error response,\\\\\\\\n * then aws_s3_meta_request_result.error_response_operation_name is set. */\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_operation_name, s_test_s3_default_fail_operation_name)\\\\\\\\nstatic int s_test_s3_default_fail_operation_name(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\", aws_string_c_str(meta_request_test_results.error_response_operation_name));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_invalid_request, s_test_s3_put_fail_object_invalid_request)\\\\\\\\nstatic int s_test_s3_put_fail_object_invalid_request(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .invalid_request = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INVALID_RESPONSE_STATUS, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    /* Since 1MB is under part_size, there will be a single PutObject request */\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"PutObject\\\\\\\\\\\\\", aws_string_c_str(meta_request_test_results.error_response_operation_name));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that we fail to create a metarequest when an invalid `send_filepath` is passed in */\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_invalid_send_filepath, s_test_s3_put_fail_object_invalid_send_filepath)\\\\\\\\nstatic int s_test_s3_put_fail_object_invalid_send_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor object_key = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = aws_s3_test_put_object_request_new_without_body(\\\\\\\\n        allocator, &host_name, g_test_body_content_type, object_key, 1024 /*content_length*/, 0 /*flags*/);\\\\\\\\n    ASSERT_NOT_NULL(message);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options meta_request_options = {\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .message = message,\\\\\\\\n        .send_filepath = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"obviously_invalid_file_path\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &meta_request_options);\\\\\\\\n    ASSERT_NULL(meta_request);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_ERROR_FILE_INVALID_PATH, aws_last_error());\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the parallel read stream failed to send read the second part. */\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_bad_parallel_read_stream, s_test_s3_put_fail_object_bad_parallel_read_stream)\\\\\\\\nstatic int s_test_s3_put_fail_object_bad_parallel_read_stream(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    /* Override the parallel input stream new function to create a bad parallel input stream */\\\\\\\\n    client->vtable->parallel_input_stream_new_from_file = aws_parallel_input_stream_new_from_file_failure_tester;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 100,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_UNIMPLEMENTED, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_single_part_fail_object_inputstream_fail_reading,\\\\\\\\n    s_test_s3_put_single_part_fail_object_inputstream_fail_reading)\\\\\\\\nstatic int s_test_s3_put_single_part_fail_object_inputstream_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n                .content_length = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_single_part_fail_object_inputstream_mismatch_content_length,\\\\\\\\n    s_test_s3_put_single_part_fail_object_inputstream_mismatch_content_length)\\\\\\\\nstatic int s_test_s3_put_single_part_fail_object_inputstream_mismatch_content_length(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .content_length = MB_TO_BYTES(2),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_inputstream_fail_reading, s_test_s3_put_fail_object_inputstream_fail_reading)\\\\\\\\nstatic int s_test_s3_put_fail_object_inputstream_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n                .content_length = 10 * 1024 * 1024,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_IO_STREAM_READ_FAILED, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_fail_object_inputstream_mismatch_content_length,\\\\\\\\n    s_test_s3_put_fail_object_inputstream_mismatch_content_length)\\\\\\\\nstatic int s_test_s3_put_fail_object_inputstream_mismatch_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = false,\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .content_length = 10 * 1024 * 1024,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INCORRECT_CONTENT_LENGTH, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_clamp_part_size, s_test_s3_put_object_clamp_part_size)\\\\\\\\nstatic int s_test_s3_put_object_clamp_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n        .max_part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client_config.part_size < g_s3_min_upload_part_size);\\\\\\\\n    ASSERT_TRUE(client_config.max_part_size < g_s3_min_upload_part_size);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    /* Upload should now succeed even when specifying a smaller than allowed part size. */\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(test_results.part_size == g_s3_min_upload_part_size);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_get_expected_user_agent(struct aws_allocator *allocator, struct aws_byte_buf *dest) {\\\\\\\\n    AWS_ASSERT(allocator);\\\\\\\\n    AWS_ASSERT(dest);\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor forward_slash = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/\\\\\\\\\\\\\");\\\\\\\\n    const struct aws_byte_cursor single_space = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\" \\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_init(dest, allocator, 32));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_product_name));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &forward_slash));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_s3_client_version));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &single_space));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_platform));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &forward_slash));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_unknown));\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_add_user_agent_header, s_test_add_user_agent_header)\\\\\\\\nstatic int s_test_add_user_agent_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor single_space = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\" \\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_buf expected_user_agent_value_buf;\\\\\\\\n    s_get_expected_user_agent(allocator, &expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor expected_user_agent_value = aws_byte_cursor_from_buf(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_byte_cursor user_agent_value;\\\\\\\\n        AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n\\\\\\\\n        struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n\\\\\\\\n        aws_s3_add_user_agent_header(allocator, message);\\\\\\\\n\\\\\\\\n        struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(headers != NULL);\\\\\\\\n        ASSERT_SUCCESS(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value));\\\\\\\\n        ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n            user_agent_value.ptr, user_agent_value.len, expected_user_agent_value.ptr, expected_user_agent_value.len);\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        const struct aws_byte_cursor dummy_agent_header_value =\\\\\\\\n            AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_user_agent_product/dummy_user_agent_value\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        struct aws_byte_buf total_expected_user_agent_value_buf;\\\\\\\\n        aws_byte_buf_init(&total_expected_user_agent_value_buf, allocator, 64);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &dummy_agent_header_value);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &single_space);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &expected_user_agent_value);\\\\\\\\n\\\\\\\\n        struct aws_byte_cursor total_expected_user_agent_value =\\\\\\\\n            aws_byte_cursor_from_buf(&total_expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n        struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n        struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n        ASSERT_TRUE(headers != NULL);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_http_headers_add(headers, g_user_agent_header_name, dummy_agent_header_value));\\\\\\\\n\\\\\\\\n        aws_s3_add_user_agent_header(allocator, message);\\\\\\\\n\\\\\\\\n        {\\\\\\\\n            struct aws_byte_cursor user_agent_value;\\\\\\\\n            AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n            ASSERT_SUCCESS(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value));\\\\\\\\n            ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n                user_agent_value.ptr,\\\\\\\\n                user_agent_value.len,\\\\\\\\n                total_expected_user_agent_value.ptr,\\\\\\\\n                total_expected_user_agent_value.len);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_byte_buf_clean_up(&total_expected_user_agent_value_buf);\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&expected_user_agent_value_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_user_agent_meta_request_finished_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *results = meta_request->user_data;\\\\\\\\n    AWS_ASSERT(results != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = results->tester;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf expected_user_agent_value_buf;\\\\\\\\n    s_get_expected_user_agent(meta_request->allocator, &expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor expected_user_agent_value = aws_byte_cursor_from_buf(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = request->send_data.message;\\\\\\\\n    struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor user_agent_value;\\\\\\\\n    AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n\\\\\\\\n    AWS_FATAL_ASSERT(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value) == AWS_OP_SUCCESS);\\\\\\\\n    AWS_FATAL_ASSERT(aws_byte_cursor_eq(&user_agent_value, &expected_user_agent_value));\\\\\\\\n    aws_byte_buf_clean_up(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *original_meta_request_vtable =\\\\\\\\n        aws_s3_tester_get_meta_request_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    original_meta_request_vtable->finished_request(meta_request, request, error_code);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_s3_meta_request *s_s3_meta_request_factory_override_finished_request(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    const struct aws_s3_meta_request_options *options) {\\\\\\\\n    AWS_ASSERT(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = client->shutdown_callback_user_data;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *original_client_vtable =\\\\\\\\n        aws_s3_tester_get_client_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = original_client_vtable->meta_request_factory(client, options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *patched_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(tester, meta_request, NULL);\\\\\\\\n    patched_meta_request_vtable->finished_request = s_s3_test_user_agent_meta_request_finished_request;\\\\\\\\n\\\\\\\\n    return meta_request;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_test_sending_user_agent_create_client(struct aws_s3_tester *tester, struct aws_s3_client **client) {\\\\\\\\n    AWS_ASSERT(tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(tester, &client_options, client));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(tester, *client, NULL);\\\\\\\\n    patched_client_vtable->meta_request_factory = s_s3_meta_request_factory_override_finished_request;\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_auto_ranged_get_sending_user_agent, s_test_s3_auto_ranged_get_sending_user_agent)\\\\\\\\nstatic int s_test_s3_auto_ranged_get_sending_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = g_pre_existing_object_1MB,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_auto_ranged_put_sending_user_agent, s_test_s3_auto_ranged_put_sending_user_agent)\\\\\\\\nstatic int s_test_s3_auto_ranged_put_sending_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .put_options =\\\\\\\\n                {\\\\\\\\n                    .ensure_multipart = true,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_sending_meta_request_user_agent, s_test_s3_default_sending_meta_request_user_agent)\\\\\\\\nstatic int s_test_s3_default_sending_meta_request_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .default_type_options =\\\\\\\\n                {\\\\\\\\n                    .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                    .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n                },\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = g_pre_existing_object_1MB,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct range_requests_test_user_data {\\\\\\\\n    struct aws_http_headers *headers;\\\\\\\\n    struct aws_byte_buf *body_buffer;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic int s_range_requests_headers_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)response_status;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results = user_data;\\\\\\\\n    struct range_requests_test_user_data *test_user_data = test_results->tester->user_data;\\\\\\\\n\\\\\\\\n    if (test_user_data != NULL) {\\\\\\\\n        copy_http_headers(headers, test_user_data->headers);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_range_requests_receive_body_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)range_start;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results = user_data;\\\\\\\\n    struct range_requests_test_user_data *test_user_data = test_results->tester->user_data;\\\\\\\\n\\\\\\\\n    aws_byte_buf_append_dynamic(test_user_data->body_buffer, body);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_range_requests, s_test_s3_range_requests)\\\\\\\\nstatic int s_test_s3_range_requests(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor object_names[] = {\\\\\\\\n        g_pre_existing_object_1MB,\\\\\\\\n        g_pre_existing_object_kms_10MB,\\\\\\\\n        g_pre_existing_object_aes256_10MB,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    enum aws_s3_tester_sse_type object_sse_types[] = {\\\\\\\\n        AWS_S3_TESTER_SSE_NONE,\\\\\\\\n        AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        AWS_S3_TESTER_SSE_AES256,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor ranges[] = {\\\\\\\\n        // No range at all.\\\\\\\\n        {0, NULL},\\\\\\\\n\\\\\\\\n        // Single byte range.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=8-8\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Single byte range (first byte).\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-0\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // First 8K.  8K < client\\'s 16K part size.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-8191\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // First 0.5 MB.  0.5 MB < 1 MB test file.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-524287\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // 0.5 MB - 2 MB range.  This overlaps and goes beyond the 1 MB test file size.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=524288-2097151\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Get everything after the first 0.5 MB\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=524288-\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Last 0.5 MB\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=-524288\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Everything after first 8K\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=8192-\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Last 8K\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=-8192\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* List of headers that should have matching values between the auto_ranged_get and default (which sends the HTTP\\\\\\\\n     * request as-is to S3) meta request.*/\\\\\\\\n    const struct aws_byte_cursor headers_that_should_match[] = {\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"ETag\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Accept-Ranges\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Range\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Type\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Length\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Server\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"x-amz-server-side-encryption\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"x-amz-server-side-encryption-aws-kms-key\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* List of headers that are okay to be in the auto_ranged_get response and not in the default response, or vice\\\\\\\\n     * versa.*/\\\\\\\\n    const struct aws_byte_cursor headers_to_ignore[] = {\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Connection\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    const size_t num_object_names = AWS_ARRAY_SIZE(object_names);\\\\\\\\n    const size_t num_ranges = AWS_ARRAY_SIZE(ranges);\\\\\\\\n\\\\\\\\n    for (size_t object_name_index = 0; object_name_index < num_object_names; ++object_name_index) {\\\\\\\\n        for (size_t range_index = 0; range_index < num_ranges; ++range_index) {\\\\\\\\n\\\\\\\\n            AWS_LOGF_INFO(\\\\\\\\n                AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Testing object name %d and range %d\\\\\\\\\\\\\", (int)object_name_index, (int)range_index);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf range_get_buffer;\\\\\\\\n            aws_byte_buf_init(&range_get_buffer, allocator, 256);\\\\\\\\n            struct aws_http_headers *range_get_headers = aws_http_headers_new(allocator);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf verify_range_get_buffer;\\\\\\\\n            aws_byte_buf_init(&verify_range_get_buffer, allocator, 256);\\\\\\\\n            struct aws_http_headers *verify_range_get_headers = aws_http_headers_new(allocator);\\\\\\\\n\\\\\\\\n            struct aws_s3_tester_meta_request_options options = {\\\\\\\\n                .allocator = allocator,\\\\\\\\n                .client = client,\\\\\\\\n                .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n                .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n                .headers_callback = s_range_requests_headers_callback,\\\\\\\\n                .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n                .get_options =\\\\\\\\n                    {\\\\\\\\n                        .object_path = object_names[object_name_index],\\\\\\\\n                        .object_range = ranges[range_index],\\\\\\\\n                    },\\\\\\\\n                .sse_type = object_sse_types[object_name_index],\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            {\\\\\\\\n                struct range_requests_test_user_data test_user_data = {\\\\\\\\n                    .headers = range_get_headers,\\\\\\\\n                    .body_buffer = &range_get_buffer,\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                tester.user_data = &test_user_data;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            /* Send a default meta request (which just pushes the request directly to S3) with the same options to\\\\\\\\n             * verify the format of each request. */\\\\\\\\n            struct aws_s3_tester_meta_request_options verify_options = {\\\\\\\\n                .allocator = allocator,\\\\\\\\n                .client = client,\\\\\\\\n                .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n                .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n                .headers_callback = s_range_requests_headers_callback,\\\\\\\\n                .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n                .default_type_options =\\\\\\\\n                    {\\\\\\\\n                        .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                        .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n                    },\\\\\\\\n                .get_options =\\\\\\\\n                    {\\\\\\\\n                        .object_path = object_names[object_name_index],\\\\\\\\n                        .object_range = ranges[range_index],\\\\\\\\n                    },\\\\\\\\n                .sse_type = object_sse_types[object_name_index],\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            {\\\\\\\\n                struct range_requests_test_user_data test_user_data = {\\\\\\\\n                    .headers = verify_range_get_headers,\\\\\\\\n                    .body_buffer = &verify_range_get_buffer,\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                tester.user_data = &test_user_data;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &verify_options, NULL));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            /* Compare headers. */\\\\\\\\n            for (size_t i = 0; i < aws_http_headers_count(verify_range_get_headers); ++i) {\\\\\\\\n                struct aws_http_header verify_header;\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get_index(verify_range_get_headers, i, &verify_header));\\\\\\\\n\\\\\\\\n                bool ignore_header = false;\\\\\\\\n\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_to_ignore); ++j) {\\\\\\\\n                    if (aws_byte_cursor_eq_ignore_case(&headers_to_ignore[j], &verify_header.name)) {\\\\\\\\n                        ignore_header = true;\\\\\\\\n                        break;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                if (ignore_header) {\\\\\\\\n                    aws_http_headers_erase(range_get_headers, verify_header.name);\\\\\\\\n                    continue;\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                AWS_LOGF_INFO(\\\\\\\\n                    AWS_LS_S3_GENERAL,\\\\\\\\n                    \\\\\\\\\\\\\"%d,%d Checking for header \\\\\\\\\\\\\" PRInSTR,\\\\\\\\n                    (int)object_name_index,\\\\\\\\n                    (int)range_index,\\\\\\\\n                    AWS_BYTE_CURSOR_PRI(verify_header.name));\\\\\\\\n\\\\\\\\n                struct aws_byte_cursor header_value;\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get(range_get_headers, verify_header.name, &header_value));\\\\\\\\n\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_that_should_match); ++j) {\\\\\\\\n                    if (!aws_byte_cursor_eq_ignore_case(&headers_that_should_match[j], &verify_header.name)) {\\\\\\\\n                        continue;\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    AWS_LOGF_INFO(\\\\\\\\n                        AWS_LS_S3_GENERAL,\\\\\\\\n                        \\\\\\\\\\\\\"%d,%d Header Contents \\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\" vs \\\\\\\\\\\\\" PRInSTR,\\\\\\\\n                        (int)object_name_index,\\\\\\\\n                        (int)range_index,\\\\\\\\n                        AWS_BYTE_CURSOR_PRI(verify_header.value),\\\\\\\\n                        AWS_BYTE_CURSOR_PRI(header_value));\\\\\\\\n\\\\\\\\n                    ASSERT_TRUE(aws_byte_cursor_eq(&verify_header.value, &header_value));\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_erase(range_get_headers, verify_header.name));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            for (size_t i = 0; i < aws_http_headers_count(range_get_headers); ++i) {\\\\\\\\n                struct aws_http_header header;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get_index(range_get_headers, i, &header));\\\\\\\\n                bool ignore_header = false;\\\\\\\\n\\\\\\\\n                /* If the ignore header doesn\\'t exist in the verify_range_get_headers, ignore it here. */\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_to_ignore); ++j) {\\\\\\\\n                    if (aws_byte_cursor_eq_ignore_case(&headers_to_ignore[j], &header.name)) {\\\\\\\\n                        ignore_header = true;\\\\\\\\n                        break;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                if (ignore_header) {\\\\\\\\n                    ASSERT_SUCCESS(aws_http_headers_erase(range_get_headers, header.name));\\\\\\\\n                    continue;\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                AWS_LOGF_INFO(AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Left over header: \\\\\\\\\\\\\" PRInSTR, AWS_BYTE_CURSOR_PRI(header.name));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(aws_http_headers_count(range_get_headers) == 0);\\\\\\\\n\\\\\\\\n            /* Compare Body Contents */\\\\\\\\n            ASSERT_TRUE(aws_byte_buf_eq(&range_get_buffer, &verify_range_get_buffer));\\\\\\\\n\\\\\\\\n            aws_http_headers_release(range_get_headers);\\\\\\\\n            aws_byte_buf_clean_up(&range_get_buffer);\\\\\\\\n\\\\\\\\n            aws_http_headers_release(verify_range_get_headers);\\\\\\\\n            aws_byte_buf_clean_up(&verify_range_get_buffer);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_not_satisfiable_range, s_test_s3_not_satisfiable_range)\\\\\\\\nstatic int s_test_s3_not_satisfiable_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .headers_callback = s_range_requests_headers_callback,\\\\\\\\n        .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=2097151-\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_416_REQUESTED_RANGE_NOT_SATISFIABLE, results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_invalid_start_range_greator_than_end_range, s_test_s3_invalid_start_range_greator_than_end_range)\\\\\\\\nstatic int s_test_s3_invalid_start_range_greator_than_end_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=20-10\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n    ASSERT_INT_EQUALS(results.finished_error_code, AWS_ERROR_S3_INVALID_RANGE_HEADER);\\\\\\\\n    ASSERT_INT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_invalid_empty_file_with_range, s_test_s3_invalid_empty_file_with_range)\\\\\\\\nstatic int s_test_s3_invalid_empty_file_with_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_empty_object,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-0\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_416_REQUESTED_RANGE_NOT_SATISFIABLE, results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_copy_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor source_key,\\\\\\\\n    struct aws_byte_cursor destination_key,\\\\\\\\n    int expected_error_code,\\\\\\\\n    int expected_response_status,\\\\\\\\n    uint64_t expected_size) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    struct aws_byte_buf encoded_path;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n    AWS_ZERO_STRUCT(encoded_path);\\\\\\\\n\\\\\\\\n    aws_byte_buf_init(&encoded_path, allocator, source_key.len);\\\\\\\\n    aws_byte_buf_append_encoding_uri_path(&encoded_path, &source_key);\\\\\\\\n\\\\\\\\n    /* without copy_source_uri */\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    /* with path style copy_source_uri */\\\\\\\\n    char source_url[1024];\\\\\\\\n    snprintf(\\\\\\\\n        source_url,\\\\\\\\n        sizeof(source_url),\\\\\\\\n        \\\\\\\\\\\\\"https://s3.%s.amazonaws.com/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"\\\\\\\\\\\\\",\\\\\\\\n        g_test_s3_region.ptr,\\\\\\\\n        AWS_BYTE_CURSOR_PRI(source_bucket),\\\\\\\\n        AWS_BYTE_BUF_PRI(encoded_path));\\\\\\\\n    copy_source_uri = aws_byte_cursor_from_c_str(source_url);\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    /* with virtual style copy_source_uri */\\\\\\\\n    snprintf(\\\\\\\\n        source_url,\\\\\\\\n        sizeof(source_url),\\\\\\\\n        \\\\\\\\\\\\\"https://\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\".s3.%s.amazonaws.com/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(source_bucket),\\\\\\\\n        g_test_s3_region.ptr,\\\\\\\\n        AWS_BYTE_BUF_PRI(encoded_path));\\\\\\\\n    copy_source_uri = aws_byte_cursor_from_c_str(source_url);\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_byte_buf_clean_up(&encoded_path);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_small_object, s_test_s3_copy_small_object)\\\\\\\\nstatic int s_test_s3_copy_small_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, MB_TO_BYTES(1));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_small_object_special_char, s_test_s3_copy_small_object_special_char)\\\\\\\\nstatic int s_test_s3_copy_small_object_special_char(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB-@\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB_@\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, MB_TO_BYTES(1));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_copy_large_object_special_char, s_test_s3_multipart_copy_large_object_special_char)\\\\\\\\nstatic int s_test_s3_multipart_copy_large_object_special_char(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-2GB-@\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_2GB-@\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, GB_TO_BYTES(2));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_copy_large_object, s_test_s3_multipart_copy_large_object)\\\\\\\\nstatic int s_test_s3_multipart_copy_large_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-2GB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_2GB\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, GB_TO_BYTES(2));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_object_invalid_source_key, s_test_s3_copy_object_invalid_source_key)\\\\\\\\nstatic int s_test_s3_copy_object_invalid_source_key(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"__INVALID__\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/__INVALID__\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        source_key,\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_S3_INVALID_RESPONSE_STATUS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_404_NOT_FOUND,\\\\\\\\n        0 /* expected_size is ignored */);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test a bypass Copy Object meta request using a slash prefix in the x_amz_copy_source header.\\\\\\\\n * S3 supports both bucket/key and /bucket/key\\\\\\\\n * This test validates the fix for the bug described in https://sim.amazon.com/issues/AWSCRT-730\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_copy_source_prefixed_by_slash, s_test_s3_copy_source_prefixed_by_slash)\\\\\\\\nstatic int s_test_s3_copy_source_prefixed_by_slash(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK,\\\\\\\\n        MB_TO_BYTES(1),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_invalid_source_uri, s_test_s3_copy_invalid_source_uri)\\\\\\\\nstatic int s_test_s3_copy_invalid_source_uri(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"http://invalid-uri.com:80:80/path\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_MALFORMED_INPUT_STRING,\\\\\\\\n        0,\\\\\\\\n        MB_TO_BYTES(1),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test multipart Copy Object meta request using a slash prefix in the x_amz_copy_source header.\\\\\\\\n * S3 supports both bucket/key and /bucket/key\\\\\\\\n * This test validates the fix for the bug described in https://sim.amazon.com/issues/AWSCRT-730\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_copy_source_prefixed_by_slash_multipart, s_test_s3_copy_source_prefixed_by_slash_multipart)\\\\\\\\nstatic int s_test_s3_copy_source_prefixed_by_slash_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-256MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_256MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK,\\\\\\\\n        MB_TO_BYTES(256),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_get_object_mrap_helper(struct aws_allocator *allocator, bool multipart) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_signing_config_aws signing_config = tester.default_signing_config;\\\\\\\\n    /* Use Sigv4A for signing */\\\\\\\\n    signing_config.algorithm = AWS_SIGNING_ALGORITHM_V4_ASYMMETRIC;\\\\\\\\n    /* Use * for region to sign */\\\\\\\\n    signing_config.region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = multipart ? 64 * 1024 : 20 * 1024 * 1024,\\\\\\\\n        .region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\"),\\\\\\\\n        .signing_config = &signing_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0 /*flag*/));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .mrap_test = true,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test single-part get object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_less_than_part_size_mrap, s_test_s3_get_object_less_than_part_size_mrap)\\\\\\\\nstatic int s_test_s3_get_object_less_than_part_size_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_get_object_mrap_helper(allocator, false /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test multi-part get object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multipart_mrap, s_test_s3_get_object_multipart_mrap)\\\\\\\\nstatic int s_test_s3_get_object_multipart_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_get_object_mrap_helper(allocator, true /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_put_object_mrap_helper(struct aws_allocator *allocator, bool multipart) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_signing_config_aws signing_config = tester.default_signing_config;\\\\\\\\n    /* Use Sigv4A for signing */\\\\\\\\n    signing_config.algorithm = AWS_SIGNING_ALGORITHM_V4_ASYMMETRIC;\\\\\\\\n    /* Use * for region to sign */\\\\\\\\n    signing_config.region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n        .region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\"),\\\\\\\\n        .signing_config = &signing_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0 /*flag*/));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .mrap_test = true,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = multipart ? 10 : 1,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test single-part put object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_less_than_part_size_mrap, s_test_s3_put_object_less_than_part_size_mrap)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_put_object_mrap_helper(allocator, false /*multipart*/);\\\\\\\\n}\\\\\\\\n/* Test multi-part put object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multipart_mrap, s_test_s3_put_object_multipart_mrap)\\\\\\\\nstatic int s_test_s3_put_object_multipart_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_put_object_mrap_helper(allocator, true /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_http_message *s_put_object_request_new(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor key,\\\\\\\\n    struct aws_byte_cursor endpoint,\\\\\\\\n    struct aws_input_stream *body_stream,\\\\\\\\n    uint64_t content_length) {\\\\\\\\n\\\\\\\\n    AWS_PRECONDITION(allocator);\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n\\\\\\\\n    if (message == NULL) {\\\\\\\\n        return NULL;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if (aws_http_message_set_request_path(message, key)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_http_header host_header = {\\\\\\\\n        .name = g_host_header_name,\\\\\\\\n        .value = endpoint,\\\\\\\\n    };\\\\\\\\n    if (aws_http_message_add_header(message, host_header)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    char content_length_c_str[1024];\\\\\\\\n    snprintf(content_length_c_str, sizeof(content_length_c_str), \\\\\\\\\\\\\"%\\\\\\\\\\\\\" PRIu64, content_length);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_length_header = {\\\\\\\\n        .name = g_content_length_header_name,\\\\\\\\n        .value = aws_byte_cursor_from_c_str(content_length_c_str),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    if (aws_http_message_add_header(message, content_length_header)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if (aws_http_message_set_request_method(message, aws_http_method_put)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_set_body_stream(message, body_stream);\\\\\\\\n\\\\\\\\n    return message;\\\\\\\\n\\\\\\\\nerror_clean_up_message:\\\\\\\\n\\\\\\\\n    if (message != NULL) {\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n        message = NULL;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return NULL;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct put_object_pause_resume_test_data {\\\\\\\\n    struct aws_mutex mutex;\\\\\\\\n    struct aws_condition_variable c_var;\\\\\\\\n\\\\\\\\n    /* execution of the test meta request completed */\\\\\\\\n    bool execution_completed;\\\\\\\\n\\\\\\\\n    /* accumulator of amount of bytes uploaded */\\\\\\\\n    struct aws_atomic_var total_bytes_uploaded;\\\\\\\\n\\\\\\\\n    /* the offset where upload should be paused */\\\\\\\\n    struct aws_atomic_var request_pause_offset;\\\\\\\\n\\\\\\\\n    struct aws_atomic_var pause_requested;\\\\\\\\n\\\\\\\\n    struct aws_atomic_var pause_result;\\\\\\\\n\\\\\\\\n    /* the persistable state of the paused request */\\\\\\\\n    struct aws_atomic_var persistable_state_ptr;\\\\\\\\n\\\\\\\\n    int meta_request_error_code;\\\\\\\\n    int response_status_code;\\\\\\\\n\\\\\\\\n    /* (Optional) content_length to send. If not set, use the length of the input stream. */\\\\\\\\n    uint64_t content_length;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic void s_put_pause_resume_meta_request_finish(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *meta_request_result,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    struct aws_s3_tester *tester = user_data;\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = tester->user_data;\\\\\\\\n\\\\\\\\n    /* if error response body is available, dump it to test result to help investigation of failed tests */\\\\\\\\n    if (meta_request_result->error_response_body != NULL && meta_request_result->error_response_body->len > 0) {\\\\\\\\n        AWS_LOGF_ERROR(\\\\\\\\n            AWS_LS_S3_GENERAL,\\\\\\\\n            \\\\\\\\\\\\\"Response error body: %.*s\\\\\\\\\\\\\",\\\\\\\\n            (int)meta_request_result->error_response_body->len,\\\\\\\\n            meta_request_result->error_response_body->buffer);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_mutex_lock(&test_data->mutex);\\\\\\\\n    test_data->meta_request_error_code = meta_request_result->error_code;\\\\\\\\n    test_data->response_status_code = meta_request_result->response_status;\\\\\\\\n    test_data->execution_completed = true;\\\\\\\\n    aws_mutex_unlock(&test_data->mutex);\\\\\\\\n    aws_condition_variable_notify_one(&test_data->c_var);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic bool s_put_pause_resume_test_completion_predicate(void *arg) {\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = arg;\\\\\\\\n    return test_data->execution_completed;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Patched version of aws_s3_meta_request_vtable->finished_request() for pause/resume tests.\\\\\\\\n * It can pause the meta-request immediately after a part completes.\\\\\\\\n * We use a patched vtable, instead of the progress_callback, because\\\\\\\\n * the progress_callback fires on another thread, which might be too late to\\\\\\\\n * prevent more parts from being sent. */\\\\\\\\nstatic void s_meta_request_finished_request_patched_for_pause_resume_tests(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    struct aws_s3_tester *tester = meta_request->user_data;\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = tester->user_data;\\\\\\\\n    AWS_ASSERT(test_data);\\\\\\\\n\\\\\\\\n    if ((error_code == AWS_ERROR_SUCCESS) && (meta_request->type == AWS_S3_META_REQUEST_TYPE_PUT_OBJECT) &&\\\\\\\\n        (request->request_tag == AWS_S3_AUTO_RANGED_PUT_REQUEST_TAG_PART)) {\\\\\\\\n\\\\\\\\n        if (!request->is_noop) {\\\\\\\\n            /* If the request is noop, we are not really uploading the part */\\\\\\\\n            aws_atomic_fetch_add(&test_data->total_bytes_uploaded, request->request_body.len);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        size_t total_bytes_uploaded = aws_atomic_load_int(&test_data->total_bytes_uploaded);\\\\\\\\n        uint64_t offset_to_pause = aws_atomic_load_int(&test_data->request_pause_offset);\\\\\\\\n\\\\\\\\n        if (total_bytes_uploaded >= offset_to_pause) {\\\\\\\\n            /* offset of the upload at which we should pause was reached. let\\'s pause the upload */\\\\\\\\n            /* if the meta request has already been paused previously, do nothing. */\\\\\\\\n            size_t expected = false;\\\\\\\\n            bool request_pause = aws_atomic_compare_exchange_int(&test_data->pause_requested, &expected, true);\\\\\\\\n            if (request_pause) {\\\\\\\\n                struct aws_s3_meta_request_resume_token *resume_token = NULL;\\\\\\\\n                int pause_result = aws_s3_meta_request_pause(meta_request, &resume_token);\\\\\\\\n                struct aws_byte_cursor upload_id = aws_s3_meta_request_resume_token_upload_id(resume_token);\\\\\\\\n                /* Make Sure we have upload ID */\\\\\\\\n                AWS_FATAL_ASSERT(aws_byte_cursor_eq_c_str(&upload_id, \\\\\\\\\\\\\"\\\\\\\\\\\\\") == false);\\\\\\\\n                aws_atomic_store_int(&test_data->pause_result, pause_result);\\\\\\\\n                aws_atomic_store_ptr(&test_data->persistable_state_ptr, resume_token);\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Continue with original vtable function... */\\\\\\\\n    struct aws_s3_meta_request_vtable *original_meta_request_vtable =\\\\\\\\n        aws_s3_tester_get_meta_request_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    original_meta_request_vtable->finished_request(meta_request, request, error_code);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_s3_meta_request *s_meta_request_factory_patch_for_pause_resume_tests(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    const struct aws_s3_meta_request_options *options) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(client != NULL);\\\\\\\\n    struct aws_s3_tester *tester = client->shutdown_callback_user_data;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *original_client_vtable =\\\\\\\\n        aws_s3_tester_get_client_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = original_client_vtable->meta_request_factory(client, options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *patched_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(tester, meta_request, NULL);\\\\\\\\n    patched_meta_request_vtable->finished_request = s_meta_request_finished_request_patched_for_pause_resume_tests;\\\\\\\\n\\\\\\\\n    return meta_request;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* total length of the object to simulate for upload */\\\\\\\\nstatic const size_t s_pause_resume_object_length_128MB = 128 * 1024 * 1024;\\\\\\\\n\\\\\\\\n/* this runs when a RESUMED upload is about to successfully complete */\\\\\\\\nstatic int s_pause_resume_upload_review_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_upload_review *review,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)user_data;\\\\\\\\n    struct aws_allocator *allocator = meta_request->allocator;\\\\\\\\n\\\\\\\\n    /* A bit hacky, but stream the same data that the test always uploads, and ensure the checksums match */\\\\\\\\n\\\\\\\\n    struct aws_input_stream *reread_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    for (size_t part_index = 0; part_index < review->part_count; ++part_index) {\\\\\\\\n        const struct aws_s3_upload_part_review *part_review = &review->part_array[part_index];\\\\\\\\n        struct aws_byte_buf reread_part_buf;\\\\\\\\n        ASSERT_TRUE(part_review->size <= SIZE_MAX);\\\\\\\\n        aws_byte_buf_init(&reread_part_buf, allocator, (size_t)part_review->size);\\\\\\\\n        ASSERT_SUCCESS(aws_input_stream_read(reread_stream, &reread_part_buf));\\\\\\\\n\\\\\\\\n        /* part sizes should match */\\\\\\\\n        ASSERT_UINT_EQUALS(part_review->size, reread_part_buf.len);\\\\\\\\n\\\\\\\\n        if (review->checksum_algorithm != AWS_SCA_NONE) {\\\\\\\\n            struct aws_byte_cursor reread_part_cursor = aws_byte_cursor_from_buf(&reread_part_buf);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf checksum_buf;\\\\\\\\n            aws_byte_buf_init(&checksum_buf, allocator, 128);\\\\\\\\n            ASSERT_SUCCESS(\\\\\\\\n                aws_checksum_compute(allocator, review->checksum_algorithm, &reread_part_cursor, &checksum_buf));\\\\\\\\n            struct aws_byte_cursor checksum_cursor = aws_byte_cursor_from_buf(&checksum_buf);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf encoded_checksum_buf;\\\\\\\\n            aws_byte_buf_init(&encoded_checksum_buf, allocator, 128);\\\\\\\\n\\\\\\\\n            ASSERT_SUCCESS(aws_base64_encode(&checksum_cursor, &encoded_checksum_buf));\\\\\\\\n\\\\\\\\n            /* part checksums should match */\\\\\\\\n            ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n                encoded_checksum_buf.buffer,\\\\\\\\n                encoded_checksum_buf.len,\\\\\\\\n                part_review->checksum.ptr,\\\\\\\\n                part_review->checksum.len);\\\\\\\\n\\\\\\\\n            aws_byte_buf_clean_up(&checksum_buf);\\\\\\\\n            aws_byte_buf_clean_up(&encoded_checksum_buf);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_byte_buf_clean_up(&reread_part_buf);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_input_stream_release(reread_stream);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_pause_resume_receive_body_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)range_start;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    // TODO: this is a bit hacky, as it will try to compare every partial get result we receive to the input stream.\\\\\\\\n    // Something better?\\\\\\\\n\\\\\\\\n    struct aws_input_stream *input_stream =\\\\\\\\n        aws_s3_test_input_stream_new(meta_request->allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf buf;\\\\\\\\n    aws_byte_buf_init(&buf, meta_request->allocator, (size_t)range_start);\\\\\\\\n    aws_input_stream_read(input_stream, &buf);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&buf);\\\\\\\\n    aws_byte_buf_init(&buf, meta_request->allocator, body->len);\\\\\\\\n    aws_input_stream_read(input_stream, &buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor input_cur = aws_byte_cursor_from_buf(&buf);\\\\\\\\n\\\\\\\\n    bool body_matches_expected = aws_byte_cursor_eq(&input_cur, body);\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(input_stream);\\\\\\\\n    aws_byte_buf_clean_up(&buf);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_matches_expected);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_pause_resume_helper(\\\\\\\\n    struct aws_s3_tester *tester,\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    struct put_object_pause_resume_test_data *test_data,\\\\\\\\n    struct aws_byte_cursor destination_key,\\\\\\\\n    struct aws_input_stream *upload_body_stream,\\\\\\\\n    struct aws_s3_meta_request_resume_token *resume_state,\\\\\\\\n    enum aws_s3_checksum_algorithm checksum_algorithm,\\\\\\\\n    int expected_error_code,\\\\\\\\n    int expected_response_status) {\\\\\\\\n\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    if (resume_state == NULL) {\\\\\\\\n        /* If we\\'re going to cancel this operation, limit the client to 1 HTTP connection.\\\\\\\\n         * That way, we don\\'t end up \\\\\\\\\\\\\"cancelling\\\\\\\\\\\\\" but all the parts actually\\\\\\\\n         * succeed anyway on other connections */\\\\\\\\n        client_config.max_active_connections_override = 1;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(tester, client, NULL);\\\\\\\\n    patched_client_vtable->meta_request_factory = s_meta_request_factory_patch_for_pause_resume_tests;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    /* creates a PutObject request */\\\\\\\\n    int64_t content_length = test_data->content_length;\\\\\\\\n    if (content_length == 0) {\\\\\\\\n        /* If not set, use the length of the input stream */\\\\\\\\n        aws_input_stream_get_length(upload_body_stream, &content_length);\\\\\\\\n    }\\\\\\\\n    struct aws_http_message *message = s_put_object_request_new(\\\\\\\\n        allocator, destination_key, aws_byte_cursor_from_c_str(endpoint), upload_body_stream, content_length);\\\\\\\\n\\\\\\\\n    test_data->c_var = (struct aws_condition_variable)AWS_CONDITION_VARIABLE_INIT;\\\\\\\\n    aws_mutex_init(&test_data->mutex);\\\\\\\\n    test_data->execution_completed = false;\\\\\\\\n\\\\\\\\n    tester->user_data = test_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_checksum_config checksum_config = {\\\\\\\\n        .checksum_algorithm = checksum_algorithm,\\\\\\\\n        .location = checksum_algorithm == AWS_SCA_NONE ? AWS_SCL_NONE : AWS_SCL_TRAILER,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options meta_request_options = {\\\\\\\\n        .user_data = tester,\\\\\\\\n        .body_callback = NULL,\\\\\\\\n        .signing_config = client_config.signing_config,\\\\\\\\n        .finish_callback = s_put_pause_resume_meta_request_finish,\\\\\\\\n        .headers_callback = NULL,\\\\\\\\n        .upload_review_callback = s_pause_resume_upload_review_callback,\\\\\\\\n        .message = message,\\\\\\\\n        .shutdown_callback = NULL,\\\\\\\\n        .resume_token = NULL,\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_config = &checksum_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    if (resume_state) {\\\\\\\\n        meta_request_options.resume_token = resume_state;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &meta_request_options);\\\\\\\\n    ASSERT_NOT_NULL(meta_request);\\\\\\\\n\\\\\\\\n    /* wait completion of the meta request */\\\\\\\\n    aws_mutex_lock(&test_data->mutex);\\\\\\\\n    aws_condition_variable_wait_pred(\\\\\\\\n        &test_data->c_var, &test_data->mutex, s_put_pause_resume_test_completion_predicate, test_data);\\\\\\\\n    aws_mutex_unlock(&test_data->mutex);\\\\\\\\n\\\\\\\\n    /* assert error_code and response_status_code */\\\\\\\\n    ASSERT_INT_EQUALS(expected_error_code, test_data->meta_request_error_code);\\\\\\\\n    ASSERT_INT_EQUALS(expected_response_status, test_data->response_status_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_mutex_clean_up(&test_data->mutex);\\\\\\\\n    aws_http_message_destroy(message);\\\\\\\\n\\\\\\\\n    /* release this client with its crazy patched vtables */\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_wait_for_client_shutdown(tester);\\\\\\\\n    tester->bound_to_client = false;\\\\\\\\n\\\\\\\\n    if (expected_error_code == AWS_ERROR_SUCCESS) {\\\\\\\\n        /* get the file and verify it matches what we uploaded */\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .body_callback = s_pause_resume_receive_body_callback,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = destination_key,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_test_results results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(tester, &options, &results));\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_happy_path, s_test_s3_put_pause_resume_happy_path)\\\\\\\\nstatic int s_test_s3_put_pause_resume_happy_path(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded < s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_all_parts_done, s_test_s3_put_pause_resume_all_parts_done)\\\\\\\\nstatic int s_test_s3_put_pause_resume_all_parts_done(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_all_parts_done.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 128 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_NONE,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    AWS_LOGF_INFO(AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Persistable state %p\\\\\\\\\\\\\", persistable_state);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_NONE,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_INT_EQUALS(0, bytes_uploaded);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_resume_data, s_test_s3_put_pause_resume_invalid_resume_data)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_resume_data(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_resume_data.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_s3_test_input_stream_new_with_value_type(\\\\\\\\n        allocator, s_pause_resume_object_length_128MB, TEST_STREAM_VALUE_2);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_RESUMED_PART_CHECKSUM_MISMATCH,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded < s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_resume_stream, s_test_s3_put_pause_resume_invalid_resume_stream)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_resume_stream(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_bad_resume_stream.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_release(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* a bad input stream to resume from */\\\\\\\\n    struct aws_input_stream_tester_options stream_options = {\\\\\\\\n        .autogen_length = s_pause_resume_object_length_128MB,\\\\\\\\n        .fail_on_nth_read = 1,\\\\\\\\n        .fail_with_error_code = AWS_IO_STREAM_READ_FAILED,\\\\\\\\n    };\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_input_stream_new_tester(allocator, &stream_options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    /* Each failed resume will delete the MPU */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_IO_STREAM_READ_FAILED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* resume didn\\'t read any bytes because the bad input stream failed to read. */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded == 0);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_release(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_content_length, s_test_s3_put_pause_resume_invalid_content_length)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_bad_resume_stream.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n    test_data.content_length = s_pause_resume_object_length_128MB;\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_release(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* a small input stream to resume with */\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_s3_test_input_stream_new(allocator, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    /* Each failed resume will delete the MPU */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_INCORRECT_CONTENT_LENGTH,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* resume didn\\'t read any bytes because the bad input stream failed to read. */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded == 0);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_release(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Most basic test of the upload_review_callback */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review, s_test_s3_upload_review)\\\\\\\\nstatic int s_test_s3_upload_review(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_CRC32.txt\\\\\\\\\\\\\"),\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(2, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(8), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(10) - MB_TO_BYTES(8), test_results.upload_review.part_sizes_array[1]);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_SCA_CRC32, test_results.upload_review.checksum_algorithm);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"9J8ZNA==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"BNjxzQ==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[1]));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test upload_review_callback when Content-Length is not declared */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_no_content_length, s_test_s3_upload_review_no_content_length)\\\\\\\\nstatic int s_test_s3_upload_review_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_1MB_CRC32.txt\\\\\\\\\\\\\"),\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"4hP4ig==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_upload_review_raise_canceled_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_upload_review *review,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)review;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    return aws_raise_error(AWS_ERROR_S3_CANCELED);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that if upload_review_callback raises an error, then the upload is canceled. */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_rejection, s_test_s3_upload_review_rejection)\\\\\\\\nstatic int s_test_s3_upload_review_rejection(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_rejection.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    /* Send meta-request that will raise an error from the review_upload_callback */\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .upload_review_callback = s_upload_review_raise_canceled_error,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* Check that meta-request failed with the error raised by the upload_review_callback */\\\\\\\\n    ASSERT_INT_EQUALS(AWS_ERROR_S3_CANCELED, test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    /*\\\\\\\\n     * Now check that the upload did not complete on the server either\\\\\\\\n     * (server should have received AbortMultipartUpload).\\\\\\\\n     * Check by attempting to GET the object, which should fail with 404 NOT FOUND.\\\\\\\\n     */\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &test_results));\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_404_NOT_FOUND, test_results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(test_results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(test_results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(test_results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that an MPU can be done with checksum location = NONE as long as an upload review callback\\\\\\\\n * is used, and the resulting object doesn\\'t have checksums uploaded. */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_checksum_location_none, s_test_s3_upload_review_checksum_location_none)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(2, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(5), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(5), test_results.upload_review.part_sizes_array[1]);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_SCA_CRC32, test_results.upload_review.checksum_algorithm);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"7/xUXw==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"PCOjcw==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[1]));\\\\\\\\n\\\\\\\\n    /* S3 will store the crc64 checksum for the whole object, and we can still have validate the checksum, but the algo\\\\\\\\n     * be validated will be crc64, instead of the crc32 we get from the client. */\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC64NVME,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_checksum_location_none_async, s_test_s3_upload_review_checksum_location_none_async)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none_async(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Trying to reach the noop case of async read */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_upload_review_checksum_location_none_async_noop_part,\\\\\\\\n    s_test_s3_upload_review_checksum_location_none_async_noop_part)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none_async_noop_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n                .eof_requires_extra_read = true, /* don\\'t report EOF until it tries to read 2nd part */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_http_stream *s_http_connection_make_request_patch(\\\\\\\\n    struct aws_http_connection *client_connection,\\\\\\\\n    const struct aws_http_make_request_options *options) {\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = options->request;\\\\\\\\n    struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n    struct aws_byte_cursor out_value;\\\\\\\\n    int e = aws_http_headers_get(headers, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"Content-Length\\\\\\\\\\\\\"), &out_value);\\\\\\\\n    AWS_FATAL_ASSERT(e == AWS_OP_ERR); // Assert that the header is not present\\\\\\\\n    AWS_FATAL_ASSERT(aws_last_error() == AWS_ERROR_HTTP_HEADER_NOT_FOUND);\\\\\\\\n\\\\\\\\n    return aws_http_connection_make_request(client_connection, options);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_get_without_content_length, s_test_s3_default_get_without_content_length)\\\\\\\\nstatic int s_test_s3_default_get_without_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    /* Send default type */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.message = message;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct aws_string *test_helper(struct aws_allocator *allocator) {\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n    return host_name;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_get, aws_test_s3_default_get)\\\\\\\\nstatic int aws_test_s3_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_string *hsot_name = test_helper(allocator);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(hsot_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    /* Send default type */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.message = message;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\",\\\\n  \\\\\"encoding\\\\\": \\\\\"base64\\\\\",\\\\n  \\\\\"_links\\\\\": {\\\\n    \\\\\"self\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests/s3_data_plane_tests.c?ref=dummy-delete-me\\\\\",\\\\n    \\\\\"git\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/git/blobs/dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n    \\\\\"html\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\"\\\\n  }\\\\n}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Let me first check the comments_styles.md file to understand how I should structure my review comments:\"},{\"type\":\"tool_use\",\"name\":\"filesystem-read_file\",\"input\":{\"path\":\"/Users/dengket/project/hackthon/fast-agent/crt_c_reviewer/summarization/comments_styles.md\"},\"id\":\"toolu_bdrk_01Q1rEBGizXuaACbajtW4RFJ\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01Q1rEBGizXuaACbajtW4RFJ\",\"content\":[{\"type\":\"text\",\"text\":\"# Effective Code Review Comment Guidelines\\\\n\\\\nBased on an analysis of multiple GitHub Pull Request reviews, this document summarizes key patterns and best practices for writing effective code review comments.\\\\n\\\\n## General Principles\\\\n\\\\n### 1. Comment Classification\\\\n\\\\n* **Use clear prefixes to indicate severity:**\\\\n  + `trivial:` - Minor issues that should be fixed but don\\'t block approval\\\\n  + `debatable:` or `extremely debatable:` - Suggestions open to discussion\\\\n  + `nit:` - Extremely minor stylistic preferences\\\\n  + `important:` - Issues that should be addressed before merging\\\\n  + `blocking:` - Critical issues that must be resolved\\\\n\\\\n* **Be explicit about expectations:**\\\\n  + Distinguish between mandatory changes and optional suggestions\\\\n  + Indicate when comments are informational rather than requesting changes\\\\n\\\\n### 2. Comment Structure\\\\n\\\\n* **Be specific and actionable:**\\\\n  + Refer to specific lines or sections of code\\\\n  + Explain both what the issue is and why it matters\\\\n  + Provide concrete solutions when possible\\\\n\\\\n* **Use GitHub suggestion blocks for direct code changes:**\\\\n  \\\\n\\\\n```\\\\n  ```suggestion\\\\n  actual code change goes here\\\\n  ```\\\\n\\\\n  \\\\n\\\\n```\\\\n\\\\n- **Group related issues together:**\\\\n  - Number multiple points for clarity\\\\n  - Address similar issues in a single comment when possible\\\\n\\\\n- **Provide context:**\\\\n  - Link to relevant documentation, PRs, or issues\\\\n  - Reference cross-repository standards when applicable\\\\n  - Explain reasoning behind suggestions, not just what to change\\\\n\\\\n### 3. Comment Scope\\\\n\\\\n- **Focus on the right level of detail:**\\\\n  - For simple PRs: Brief approvals may be sufficient\\\\n  - For complex PRs: Detailed, organized feedback is necessary\\\\n\\\\n- **Consider multiple aspects of code quality:**\\\\n  - Functional correctness\\\\n  - Error handling and edge cases\\\\n  - Performance implications\\\\n  - Security considerations\\\\n  - Consistency with existing patterns\\\\n  - Documentation and readability\\\\n  - Cross-platform compatibility\\\\n  - API design and usability\\\\n\\\\n## Technical Focus Areas\\\\n\\\\n### 1. Code Architecture and Design\\\\n\\\\n- **API Usability:**\\\\n  - Consider the developer experience of using the API\\\\n  - Question potentially confusing or redundant API requirements\\\\n  - Think about cross-language compatibility\\\\n\\\\n- **Error Handling:**\\\\n  - Verify proper cleanup in error cases\\\\n  - Ensure appropriate error propagation\\\\n  - Check for consistent error handling patterns\\\\n  - In C code, prefer unified error paths with consolidated cleanup\\\\n\\\\n- **Consistency:**\\\\n  - Flag inconsistent naming conventions\\\\n  - Highlight deviations from established patterns\\\\n  - Ensure consistency across related repositories\\\\n\\\\n### 2. Code Style and Readability\\\\n\\\\n- **Prioritize clear organization:**\\\\n  - Suggest clearer code structure when logic is hard to follow\\\\n  - Flag complex conditionals that could be simplified\\\\n  - Recommend extracting complex logic into well-named helper functions\\\\n\\\\n- **Comment on documentation:**\\\\n  - Ensure comments accurately describe behavior\\\\n  - Request documentation for parameters with specific usage requirements\\\\n  - Verify public API documentation clarity\\\\n\\\\n- **Focus on maintainability:**\\\\n  - Consider how code might evolve in the future\\\\n  - Identify fragile patterns that could break with future changes\\\\n  - Suggest explicit guards against potential future bugs\\\\n\\\\n### 3. Cross-Team and Ecosystem Considerations\\\\n\\\\n- **Coordinate across teams:**\\\\n  - Flag changes that might affect other teams or services\\\\n  - Recommend cross-team communication when necessary\\\\n\\\\n- **Verify ecosystem consistency:**\\\\n  - Check if behavior matches related SDKs or libraries\\\\n  - Confirm conformance to broader project standards\\\\n\\\\n## Review Process\\\\n\\\\n### 1. Reviewing Approach\\\\n\\\\n- **Progressive reviews:**\\\\n  - Start with critical issues and architectural concerns\\\\n  - Follow up on remaining issues after major concerns are addressed\\\\n  - Provide final approval once all necessary changes are made\\\\n\\\\n- **Approval comments:**\\\\n  - Use \\\\\"fix & ship\\\\\" for PRs with only minor issues\\\\n  - Include verification steps if needed before merging\\\\n  - Acknowledge when previous feedback has been addressed\\\\n\\\\n### 2. Review Tone\\\\n\\\\n- **Be direct but constructive:**\\\\n  - Focus on the code, not the person\\\\n  - Frame feedback as improvements rather than criticisms\\\\n  - Use a professional, collaborative tone\\\\n\\\\n- **Acknowledge good work:**\\\\n  - Provide positive feedback on well-implemented features\\\\n  - Recognize when authors have addressed previous feedback well\\\\n  - Use phrases like \\\\\"nice job\\\\\" or \\\\\"this looks good\\\\\" where appropriate\\\\n\\\\n- **Balance criticism with encouragement:**\\\\n  - Point out both strengths and areas for improvement\\\\n  - Recognize the effort that went into the implementation\\\\n\\\\n## Comment Examples by Category\\\\n\\\\n### Effective Trivial Comments\\\\n\\\\n```\\\\n\\\\ntrivial: undoing needless changes to whitespace\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\ntrivial: it\\'s weird to use the `_10MB` and then upload 5MB\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\ntrivial: I found this if-statement confusing, and the helper function that did different things depending on how it\\'s called...\\\\n\\\\n```\\\\n\\\\n### Effective Technical Suggestions\\\\n\\\\n```\\\\n\\\\nif there\\'s an error, we need to cleanup out_checksum\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nSo, if users already added a checksum header, they ALSO need to set this enum?\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nInstead of the `on_error:` label sharing 90% the same cleanup code as `s_s3_client_finish_destroy_default()` , have them share code\\\\n\\\\n```\\\\n\\\\n### Effective Process Comments\\\\n\\\\n```\\\\n\\\\nI\\'d advise checking this branch from aws-crt-cpp, and making sure it all works nicely, before merging\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nChecked the C++ SDK and Java SDK and they also retry on TLS errors.\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nneed to coordinate with python teams on this...\\\\n```\\\\n\\\\n### Silent Approvals (When Appropriate)\\\\n\\\\nSilent approvals (no comments, just approval) are appropriate for:\\\\n* Simple, straightforward changes\\\\n* Well-understood code\\\\n* Follow-up to previous discussions\\\\n* Self-explanatory code\\\\n* Trivial fixes\\\\n* When there\\'s an established trust relationship between reviewer and author\\\\n\\\\n## Special Cases\\\\n\\\\n### 1. Automated/Routine Changes\\\\n\\\\n* **Minimize comments for routine updates:**\\\\n  + For automated changes or version bumps, simple approvals may be sufficient\\\\n  + Focus comments on any unexpected deviations from expected patterns\\\\n\\\\n### 2. Cross-Repository Changes\\\\n\\\\n* **Consider broader impacts:**\\\\n  + For changes affecting multiple repositories, test across all affected codebases\\\\n  + Verify consistency with related repositories\\' standards\\\\n\\\\n### 3. Documentation Changes\\\\n\\\\n* **Focus on accuracy and clarity:**\\\\n  + Ensure documentation correctly describes behavior\\\\n  + Verify examples work as described\\\\n  + Check for consistent formatting and terminology\\\\n\\\\n## Conclusion\\\\n\\\\nEffective code review comments are specific, actionable, appropriately categorized, and delivered in a constructive tone. They focus on technical accuracy while maintaining readability and consistency with project standards. The level of detail should match the complexity of the change, ranging from brief approvals for simple changes to detailed, structured feedback for complex modifications.\\\\n\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now, let me gather information about the AWS C S3 library to understand the code changes better:\"},{\"type\":\"tool_use\",\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"input\":{\"knowledge_base_id\":\"8BRIG4RFWU\",\"query\":\"Tell me about the aws-c-s3 library: what is it and how is memory management handled?\"},\"id\":\"toolu_bdrk_015kaRmKaWVkAeXfatofn8xG\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_015kaRmKaWVkAeXfatofn8xG\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"## AWS C S3 The AWS-C-S3 library is an asynchronous AWS S3 client focused on maximizing throughput and network utilization. ### Key features: - **Automatic Request Splitting**: Improves throughput by automatically splitting the request into part-sized chunks and performing parallel uploads/downloads of these chunks over multiple connections. There\\'s a cap on the throughput of single S3 connection, the only way to go faster is multiple parallel connections. - **Automatic Retries**: Increases resilience by retrying individual failed chunks of a file transfer, eliminating the need to restart transfers from scratch after an intermittent error. - **DNS Load Balancing**: DNS resolver continuously harvests Amazon S3 IP addresses. When load is spread across the S3 fleet, overall throughput more reliable than if all connections are going to a single IP. - **Advanced Network Management**: The client incorporates automatic request parallelization, effective timeouts and retries, and efficient connection reuse. This approach helps to maximize throughput and network utilization, and to avoid network overloads. - **Thread Pools and Async I/O**: Avoids bottlenecks associated with single-thread processing. - **Parallel Reads**: When uploading a large file from disk, reads from multiple parts of the file in parallel.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.6043286}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"Comparatively, majority of memory usage within S3 Client comes from buffers allocated for Put/Get parts. So to control memory usage, the client will concentrate on controlling the number of buffers allocated. Effectively, this boils down to a back pressure mechanism of limiting the number of parts scheduled as memory gets closer to the limit. Memory used for other resources, ex. http connections data, various supporting structures, are not actively controlled and instead some memory is taken out from overall limit. Overall, scheduling does a best-effort memory limiting. At the time of scheduling, the client reserves memory by using buffer pool ticketing mechanism. Buffer is acquired from the pool using the ticket as close to the usage as possible (this approach peaks at lower mem usage than preallocating all mem upfront because buffers cannot be used right away, ex reading from file will fill buffers slower than they are sent, leading to decent amount of buffer reuse) Reservation mechanism is approximate and in some cases can lead to actual memory usage being higher once tickets are redeemed. The client reserves some memory to mitigate overflows like that.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/docs/memory_aware_request_execution.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.56801295}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"};  enum aws_s3_subject {     AWS_LS_S3_GENERAL = AWS_LOG_SUBJECT_BEGIN_RANGE(AWS_C_S3_PACKAGE_ID),     AWS_LS_S3_CLIENT,     AWS_LS_S3_CLIENT_STATS,     AWS_LS_S3_REQUEST,     AWS_LS_S3_META_REQUEST,     AWS_LS_S3_ENDPOINT,     AWS_LS_S3_LAST = AWS_LOG_SUBJECT_END_RANGE(AWS_C_S3_PACKAGE_ID) };  struct aws_s3_platform_info;  #ifdef _MSC_VER #    pragma warning(push) #    pragma warning(disable : 4626) /* assignment operator was implicitly defined as deleted */ #    pragma warning(disable : 5027) /* move assignment operator was implicitly defined as deleted */ #endif  struct aws_s3_platform_info {     /* name of the instance-type: example c5n.18xlarge */     struct aws_byte_cursor instance_type;     /* max throughput for this instance type, in gigabits per second */     double max_throughput_gbps;     /* The current build of this library specifically knows an optimal configuration for this      * platform */     bool has_recommended_configuration; };  #ifdef _MSC_VER #    pragma warning(pop) #endif  AWS_EXTERN_C_BEGIN  /**  * Initializes internal datastructures used by aws-c-s3.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/include/aws/s3/s3.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5554074}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"CRT S3 client was designed with throughput as a primary goal. As such, the client scales resource usage, such as number of parallel requests in flight, to achieve target throughput. The client creates buffers to hold data it is sending or receiving for each request and scaling requests in flight has direct impact on memory used. In practice, setting high target throughput or larger part size can lead to high observed memory usage. To mitigate high memory usages, memory reuse improvements were added to the client along with options to limit max memory used. The following sections will go into more detail on aspects of those changes and how the affect the client. ### Memory Reuse At the basic level, CRT S3 client starts with a meta request for operation like put or get, breaks it into smaller part-sized requests and executes those in parallel. CRT S3 client used to allocate part sized buffer for each of those requests and release it right after the request was done. That approach, resulted in a lot of very short lived allocations and allocator thrashing, overall leading to memory use spikes considerably higher than whats needed. To address that, the client is switching to a pooled buffer approach, discussed below. Note: approach described below is work in progress and concentrates on improving the common cases (default 8mb part sizes and part sizes smaller than 64mb).\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/docs/memory_aware_request_execution.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.55118364}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"`aws_myobj_new_copy()` or `aws_myobj_destroy_secure()`). Any function that initializes an existing object will be suffixed with `init` (e.g. `aws_myobj_init()`. These objects will have a corresponding `clean_up` function if necessary. In these cases, you are responsible for making the decisions for how your object is allocated. The `init` functions return `AWS_OP_SUCCESS` ( 0 ) or `AWS_OP_ERR` (-1) on failure. If several `init` or `clean_up` functions are available, they should be named like `init_x` or `clean_up_x` (e.g. `aws_myobj_init_static()` or `aws_myobj_clean_up_secure()`). ## Contributing If you are contributing to this code-base, first off, THANK YOU!. There are a few things to keep in mind to minimize the pull request turn around time. ### Coding \\\\\\\\\\\\\"guidelines\\\\\\\\\\\\\" These \\\\\\\\\\\\\"guidelines\\\\\\\\\\\\\" are followed in every library in the AWS C SDK ecosystem. #### Memory Management * All APIs that need to be able to allocate memory, must take an instance of `aws_allocator` and use that. No `malloc()` or `free()` calls should be made directly. * If an API does not allocate the memory, it does not free it. All allocations and deallocations should take place at the same level.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5440948}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"No `malloc()` or `free()` calls should be made directly. * If an API does not allocate the memory, it does not free it. All allocations and deallocations should take place at the same level. For example, if a user allocates memory, the user is responsible for freeing it. There will inevitably be a few exceptions to this rule, but they will need significant justification to make it through the code-review. * All functions that allocate memory must raise an `AWS_ERROR_OOM` error code upon allocation failures. If it is a `new()` function it should return NULL. If it is an `init()` function, it should return `AWS_OP_ERR`. #### Threading * Occasionally a thread is necessary. In those cases, prefer for memory not to be shared between threads. If memory must cross a thread barrier it should be a complete ownership hand-off. Bias towards, \\\\\\\\\\\\\"if I need a mutex, I\\'m doing it wrong\\\\\\\\\\\\\". * Do not sleep or block .... ever .... under any circumstances, in non-test-code. * Do not expose blocking APIs. ### Error Handling * For APIs returning an `int` error code. The only acceptable return types are `AWS_OP_SUCCESS` and `AWS_OP_ERR`. Before returning control to the caller, if you have an error to raise, use the `aws_raise_error()` function. * For APIs returning an allocated instance of an object, return the memory on success, and `NULL` on failure.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.53935426}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/byte_buf.h> #include <aws/common/clock.h> #include <aws/common/common.h> #include <aws/common/environment.h> #include <aws/common/ref_count.h> #include <aws/http/request_response.h> #include <aws/io/channel_bootstrap.h> #include <aws/io/event_loop.h> #include <aws/io/host_resolver.h> #include <aws/io/stream.h> #include <aws/io/tls_channel_handler.h> #include <aws/testing/aws_test_harness.h> #include <inttypes.h> #include <stdio.h>  /* Ensure the library can go through the init/cleanup cycle multiple times */ AWS_TEST_CASE(test_s3_library_init_cleanup_init_cleanup, s_test_s3_library_init_cleanup_init_cleanup) static int s_test_s3_library_init_cleanup_init_cleanup(struct aws_allocator *allocator, void *ctx) {     (void)ctx;      aws_s3_library_init(allocator);     aws_s3_library_clean_up();      aws_s3_library_init(allocator);\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_util_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5337879}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include <aws/io/message_pool.h>  #include <aws/common/thread.h>  int aws_memory_pool_init(     struct aws_memory_pool *mempool,     struct aws_allocator *alloc,     uint16_t ideal_segment_count,     size_t segment_size) {      mempool->alloc = alloc;     mempool->ideal_segment_count = ideal_segment_count;     mempool->segment_size = segment_size;     mempool->data_ptr = aws_mem_calloc(alloc, ideal_segment_count, sizeof(void *));     if (!mempool->data_ptr) {         return AWS_OP_ERR;     }      aws_array_list_init_static(&mempool->stack, mempool->data_ptr, ideal_segment_count, sizeof(void *));      for (uint16_t i = 0; i < ideal_segment_count; ++i) {         void *memory = aws_mem_acquire(alloc, segment_size);         if (memory) {             aws_array_list_push_back(&mempool->stack, &memory);         } else {             goto clean_up;         }     }      return AWS_OP_SUCCESS;  clean_up:     aws_memory_pool_clean_up(mempool);     return AWS_OP_ERR; }  void aws_memory_pool_clean_up(struct aws_memory_pool *mempool\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-io/source/message_pool.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5180144}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"#ifndef AWS_S3_UTIL_H #define AWS_S3_UTIL_H  /**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  /* This file provides access to useful constants and simple utility functions. */  #include <aws/auth/signing_config.h> #include <aws/common/byte_buf.h> #include <aws/s3/s3_client.h>  #if ASSERT_LOCK_HELD #    define ASSERT_SYNCED_DATA_LOCK_HELD(object)                                                                       \\\\\\\\\\\\\\\\         {                                                                                                              \\\\\\\\\\\\\\\\             int cached_error = aws_last_error();                                                                       \\\\\\\\\\\\\\\\             AWS_ASSERT(aws_mutex_try_lock(&(object)->synced_data.lock) == AWS_OP_ERR);                                 \\\\\\\\\\\\\\\\             aws_raise_error(cached_error);                                                                             \\\\\\\\\\\\\\\\         } #else #    define ASSERT_SYNCED_DATA_LOCK_HELD(object) #endif #define KB_TO_BYTES(kb) ((kb) * 1024) #define MB_TO_BYTES(mb) ((mb) * 1024 * 1024) #define GB_TO_BYTES(gb) ((gb) * 1024 * 1024 * 1024ULL)  #define MS_TO_NS(ms) ((uint64_t)(ms) * 1000000) #define SEC_TO_NS(ms) ((uint64_t)(ms) * 1000000000)  struct aws_allocator; struct aws_http_stream; struct aws_http_headers; struct\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/include/aws/s3/private/s3_util.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5074548}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"Secondary area is used for requests with part size bigger than a predefined value (currently 4 times part size) allocations from it got directly to allocator and are effectively old way of doing things. Primary memory area is split into blocks of fixed size (part size if defined or 8mb if not times 16). Blocks are allocated on demand. Each block is logically subdivided into part sized chunks. Pool allocates and releases in chunk sizes only, and supports acquiring several chunks (up to 4) at once. Blocks are kept around while there are ongoing requests and are released async, when there is low pressure on memory. One complication is \\\\\\\\\\\\\"forced\\\\\\\\\\\\\" buffers. A forced buffer is one that comes from primary or secondary storage as usual, but it is allowed to exceed the memory limit. Forced buffers are only used when waiting for a normal ticket reservation could cause deadlock. (At time of writing, they\\'re only used for async-writes) ### Scheduling Running out of memory is a terminal condition within CRT and in general its not practical to try to set overall memory limit on all allocations, since it dramatically increases the complexity of the code that deals with cases where only part of a memory was allocated for a task. Comparatively, majority of memory usage within S3 Client comes from buffers allocated for Put/Get parts. So to control memory usage, the client will concentrate on controlling the number of buffers allocated.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/docs/memory_aware_request_execution.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5046679}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"tool_use\",\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"input\":{\"knowledge_base_id\":\"8BRIG4RFWU\",\"query\":\"What are the memory management guidelines for aws-c-s3 library? How should memory allocation and deallocation be handled?\"},\"id\":\"toolu_bdrk_01JpXWEwmAf9dC3x63SvbqPu\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01JpXWEwmAf9dC3x63SvbqPu\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"No `malloc()` or `free()` calls should be made directly. * If an API does not allocate the memory, it does not free it. All allocations and deallocations should take place at the same level. For example, if a user allocates memory, the user is responsible for freeing it. There will inevitably be a few exceptions to this rule, but they will need significant justification to make it through the code-review. * All functions that allocate memory must raise an `AWS_ERROR_OOM` error code upon allocation failures. If it is a `new()` function it should return NULL. If it is an `init()` function, it should return `AWS_OP_ERR`. #### Threading * Occasionally a thread is necessary. In those cases, prefer for memory not to be shared between threads. If memory must cross a thread barrier it should be a complete ownership hand-off. Bias towards, \\\\\\\\\\\\\"if I need a mutex, I\\'m doing it wrong\\\\\\\\\\\\\". * Do not sleep or block .... ever .... under any circumstances, in non-test-code. * Do not expose blocking APIs. ### Error Handling * For APIs returning an `int` error code. The only acceptable return types are `AWS_OP_SUCCESS` and `AWS_OP_ERR`. Before returning control to the caller, if you have an error to raise, use the `aws_raise_error()` function. * For APIs returning an allocated instance of an object, return the memory on success, and `NULL` on failure.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.6167448}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"Comparatively, majority of memory usage within S3 Client comes from buffers allocated for Put/Get parts. So to control memory usage, the client will concentrate on controlling the number of buffers allocated. Effectively, this boils down to a back pressure mechanism of limiting the number of parts scheduled as memory gets closer to the limit. Memory used for other resources, ex. http connections data, various supporting structures, are not actively controlled and instead some memory is taken out from overall limit. Overall, scheduling does a best-effort memory limiting. At the time of scheduling, the client reserves memory by using buffer pool ticketing mechanism. Buffer is acquired from the pool using the ticket as close to the usage as possible (this approach peaks at lower mem usage than preallocating all mem upfront because buffers cannot be used right away, ex reading from file will fill buffers slower than they are sent, leading to decent amount of buffer reuse) Reservation mechanism is approximate and in some cases can lead to actual memory usage being higher once tickets are redeemed. The client reserves some memory to mitigate overflows like that.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/docs/memory_aware_request_execution.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.58853376}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"CRT S3 client was designed with throughput as a primary goal. As such, the client scales resource usage, such as number of parallel requests in flight, to achieve target throughput. The client creates buffers to hold data it is sending or receiving for each request and scaling requests in flight has direct impact on memory used. In practice, setting high target throughput or larger part size can lead to high observed memory usage. To mitigate high memory usages, memory reuse improvements were added to the client along with options to limit max memory used. The following sections will go into more detail on aspects of those changes and how the affect the client. ### Memory Reuse At the basic level, CRT S3 client starts with a meta request for operation like put or get, breaks it into smaller part-sized requests and executes those in parallel. CRT S3 client used to allocate part sized buffer for each of those requests and release it right after the request was done. That approach, resulted in a lot of very short lived allocations and allocator thrashing, overall leading to memory use spikes considerably higher than whats needed. To address that, the client is switching to a pooled buffer approach, discussed below. Note: approach described below is work in progress and concentrates on improving the common cases (default 8mb part sizes and part sizes smaller than 64mb).\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/docs/memory_aware_request_execution.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.54926616}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"`aws_myobj_new_copy()` or `aws_myobj_destroy_secure()`). Any function that initializes an existing object will be suffixed with `init` (e.g. `aws_myobj_init()`. These objects will have a corresponding `clean_up` function if necessary. In these cases, you are responsible for making the decisions for how your object is allocated. The `init` functions return `AWS_OP_SUCCESS` ( 0 ) or `AWS_OP_ERR` (-1) on failure. If several `init` or `clean_up` functions are available, they should be named like `init_x` or `clean_up_x` (e.g. `aws_myobj_init_static()` or `aws_myobj_clean_up_secure()`). ## Contributing If you are contributing to this code-base, first off, THANK YOU!. There are a few things to keep in mind to minimize the pull request turn around time. ### Coding \\\\\\\\\\\\\"guidelines\\\\\\\\\\\\\" These \\\\\\\\\\\\\"guidelines\\\\\\\\\\\\\" are followed in every library in the AWS C SDK ecosystem. #### Memory Management * All APIs that need to be able to allocate memory, must take an instance of `aws_allocator` and use that. No `malloc()` or `free()` calls should be made directly. * If an API does not allocate the memory, it does not free it. All allocations and deallocations should take place at the same level.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.54922205}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"Secondary area is used for requests with part size bigger than a predefined value (currently 4 times part size) allocations from it got directly to allocator and are effectively old way of doing things. Primary memory area is split into blocks of fixed size (part size if defined or 8mb if not times 16). Blocks are allocated on demand. Each block is logically subdivided into part sized chunks. Pool allocates and releases in chunk sizes only, and supports acquiring several chunks (up to 4) at once. Blocks are kept around while there are ongoing requests and are released async, when there is low pressure on memory. One complication is \\\\\\\\\\\\\"forced\\\\\\\\\\\\\" buffers. A forced buffer is one that comes from primary or secondary storage as usual, but it is allowed to exceed the memory limit. Forced buffers are only used when waiting for a normal ticket reservation could cause deadlock. (At time of writing, they\\'re only used for async-writes) ### Scheduling Running out of memory is a terminal condition within CRT and in general its not practical to try to set overall memory limit on all allocations, since it dramatically increases the complexity of the code that deals with cases where only part of a memory was allocated for a task. Comparatively, majority of memory usage within S3 Client comes from buffers allocated for Put/Get parts. So to control memory usage, the client will concentrate on controlling the number of buffers allocated.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/docs/memory_aware_request_execution.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5430409}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"}     }      va_end(args_allocs);     return allocation; }  #undef AWS_ALIGN_ROUND_UP  void aws_mem_release(struct aws_allocator *allocator, void *ptr) {     AWS_FATAL_PRECONDITION(allocator != NULL);     AWS_FATAL_PRECONDITION(allocator->mem_release != NULL);      if (ptr != NULL) {         allocator->mem_release(allocator, ptr);     } }  int aws_mem_realloc(struct aws_allocator *allocator, void **ptr, size_t oldsize, size_t newsize) {     AWS_FATAL_PRECONDITION(allocator != NULL);     AWS_FATAL_PRECONDITION(allocator->mem_realloc || allocator->mem_acquire);     AWS_FATAL_PRECONDITION(allocator->mem_release);      /* Protect against https://wiki.sei.cmu.edu/confluence/display/c/MEM04-C.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/source/allocator.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.53344566}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"In later versions, if allocator->mem_realloc() returns NULL, this function will assert and exit. To handle  * conditions where OOM is not a fatal error, allocator->mem_realloc() is responsible for finding/reclaiming/running a  * GC etc...before returning.  */ AWS_COMMON_API int aws_mem_realloc(struct aws_allocator *allocator, void **ptr, size_t oldsize, size_t newsize); /*  * Maintainer note: The above function doesn\\'t return the pointer (as with  * standard C realloc) as this pattern becomes error-prone when OOMs occur.  * In particular, we want to avoid losing the old pointer when an OOM condition  * occurs, so we prefer to take the old pointer as an in/out reference argument  * that we can leave unchanged on failure.  */  enum aws_mem_trace_level {     AWS_MEMTRACE_NONE = 0,   /* no tracing */     AWS_MEMTRACE_BYTES = 1,  /* just track allocation sizes and total allocated */     AWS_MEMTRACE_STACKS = 2, /* capture callstacks for each allocation */ };  /*  * Wraps an allocator and tracks all external allocations. If aws_mem_trace_dump() is called  * and there are still allocations active, they will be reported to the aws_logger at TRACE level.  * allocator - The allocator to wrap  * deprecated - Deprecated arg, ignored.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/include/aws/common/allocator.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5266288}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include <aws/common/common.h>  #include <aws/testing/aws_test_harness.h>  #ifdef __MACH__ #    include <CoreFoundation/CoreFoundation.h> #endif  static size_t s_alloc_counter, s_alloc_total_size, s_call_ct_malloc, s_call_ct_free, s_call_ct_realloc;  static void *s_test_alloc_acquire(struct aws_allocator *allocator, size_t size) {     (void)allocator;      s_alloc_counter++;     s_call_ct_malloc++;     s_alloc_total_size += size;      uint8_t *buf = malloc(size + 16);     *(size_t *)buf = size;     buf += 16;     return buf; }  static void s_test_alloc_release(struct aws_allocator *allocator, void *ptr) {     (void)allocator;      uint8_t *buf = ptr;     s_call_ct_free++;      buf -= 16;     size_t old_size = *(size_t *)buf;     s_alloc_counter--;     s_alloc_total_size -= old_size;      free(buf); }  static size_t s_original_size, s_reported_oldsize;  static void *s_test_realloc(struct aws_allocator *allocator, void *ptr, size_t oldsize, size_t newsize) {     (\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/tests/realloc_test.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5228546}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include <aws/io/message_pool.h>  #include <aws/common/thread.h>  int aws_memory_pool_init(     struct aws_memory_pool *mempool,     struct aws_allocator *alloc,     uint16_t ideal_segment_count,     size_t segment_size) {      mempool->alloc = alloc;     mempool->ideal_segment_count = ideal_segment_count;     mempool->segment_size = segment_size;     mempool->data_ptr = aws_mem_calloc(alloc, ideal_segment_count, sizeof(void *));     if (!mempool->data_ptr) {         return AWS_OP_ERR;     }      aws_array_list_init_static(&mempool->stack, mempool->data_ptr, ideal_segment_count, sizeof(void *));      for (uint16_t i = 0; i < ideal_segment_count; ++i) {         void *memory = aws_mem_acquire(alloc, segment_size);         if (memory) {             aws_array_list_push_back(&mempool->stack, &memory);         } else {             goto clean_up;         }     }      return AWS_OP_SUCCESS;  clean_up:     aws_memory_pool_clean_up(mempool);     return AWS_OP_ERR; }  void aws_memory_pool_clean_up(struct aws_memory_pool *mempool\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-io/source/message_pool.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.52241856}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"Leak memory? If your function creates some complex stateful class, that takes lots of parameters, and can\\'t currently fail, but you can totally imagine a future where it can, then yeah give it an API where it might fail. But for simple stuff that\\'s just allocating: no. ### Memory Allocation Cannot Fail Don\\'t write code that tries to handle Out Of Memory (OOM). `aws_mem_acquire()` and `aws_mem_calloc()` will never return `NULL`, they will simply abort if the OS fails to allocate. For the first few months of aws-c development, we tried to handle Out Of Memory. Lots of code was written that tried to deal with this; little of it was ever tested. In the end we decided it wasn\\'t worth the effort. Swift and Rust just abort if you push into a vector and it can\\'t expand. We should too. Now, `aws_allocator` will abort before it ever returns `NULL`. Unfortunately, after making this change we didn\\'t go back and simplify APIs that could no longer fail, because it would be a large breaking change. So functions like `aws_hash_table_put()` return `int` but it\\'s always `AWS_OP_SUCCESS` and you should never bother checking it. It sucks, but you just have to \\\\\\\\\\\\\"know\\\\\\\\\\\\\" which errors should or shouldn\\'t be checked for.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/docs/error-handling.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5218568}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now, let me examine the PR files to understand what this PR is adding:\\\\n\\\\nBased on the PR and knowledge-base information, I understand that:\\\\n\\\\n1. This is a \\\\\"dummy test\\\\\" PR for aws-c-s3, which added a new test function `aws_test_s3_default_get` to test S3 GET operations.\\\\n\\\\n2. The PR adds new test code that includes:\\\\n   - A helper function `test_helper` that builds an endpoint string\\\\n   - A test function `aws_test_s3_default_get` that creates a client, patches its vtable, and sends a GET request\\\\n\\\\n3. The aws-c-s3 library is a C client for S3 operations with a focus on high throughput, and it follows specific memory management principles.\\\\n\\\\nLet me now analyze the code for memory management issues and safety concerns:\\\\n\\\\nFirst, let me create the directory for storing my comments:\"},{\"type\":\"tool_use\",\"name\":\"filesystem-create_directory\",\"input\":{\"path\":\"./new_comments_s3_PR519\"},\"id\":\"toolu_bdrk_01WKFUXPUFQKdGL7NRCtiazg\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01WKFUXPUFQKdGL7NRCtiazg\",\"content\":[{\"type\":\"text\",\"text\":\"Successfully created directory ./new_comments_s3_PR519\"}],\"is_error\":false}]}],\"stop_sequences\":null,\"system\":\"Given a github pull request.         The code in the pull request is very related to the knowledge base, fetch the details of the code base you want to learn about the code from the knowledge base.             Use 8BRIG4RFWU as Knowledge Base ID and aws profile as bedrock, region us-east-1                But if the code is just added by the pull request, then the knowledge base will not help         and follow the guidance in /Users/dengket/project/hackthon/fast-agent/crt_c_reviewer/summarization/comments_styles.md to be how you will make comments then make your comments             as details as you can for each specific lines about the memory management, check for memory leak and memory safety on the pull request,                 save your comments about the specific line or lines with the number of the lines to a folder naming followed by ./new_comments_s3_PR<the PR number> with name related to the Pull request like PR454_Comments_Impl.md.                     And then, generates the comments only if needed and keep the positive comments out for the specific line or lines as the input for create_pull_request_review,                         save it to a file to the same folder with naming like `input_PR454_comments_memory_management.json`, but don\\'t really submit the comments\",\"tools\":[{\"name\":\"github-create_or_update_file\",\"description\":\"Create or update a single file in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"path\":{\"type\":\"string\",\"description\":\"Path where to create/update the file\"},\"content\":{\"type\":\"string\",\"description\":\"Content of the file\"},\"message\":{\"type\":\"string\",\"description\":\"Commit message\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to create/update the file in\"},\"sha\":{\"type\":\"string\",\"description\":\"SHA of the file being replaced (required when updating existing files)\"}},\"required\":[\"owner\",\"repo\",\"path\",\"content\",\"message\",\"branch\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_repositories\",\"description\":\"Search for GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"query\":{\"type\":\"string\",\"description\":\"Search query (see GitHub search syntax)\"},\"page\":{\"type\":\"number\",\"description\":\"Page number for pagination (default: 1)\"},\"perPage\":{\"type\":\"number\",\"description\":\"Number of results per page (default: 30, max: 100)\"}},\"required\":[\"query\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_repository\",\"description\":\"Create a new GitHub repository in your account\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\",\"description\":\"Repository name\"},\"description\":{\"type\":\"string\",\"description\":\"Repository description\"},\"private\":{\"type\":\"boolean\",\"description\":\"Whether the repository should be private\"},\"autoInit\":{\"type\":\"boolean\",\"description\":\"Initialize with README.md\"}},\"required\":[\"name\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_file_contents\",\"description\":\"Get the contents of a file or directory from a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"path\":{\"type\":\"string\",\"description\":\"Path to the file or directory\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to get contents from\"}},\"required\":[\"owner\",\"repo\",\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-push_files\",\"description\":\"Push multiple files to a GitHub repository in a single commit\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to push to (e.g., \\'main\\' or \\'master\\')\"},\"files\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"content\":{\"type\":\"string\"}},\"required\":[\"path\",\"content\"],\"additionalProperties\":false},\"description\":\"Array of files to push\"},\"message\":{\"type\":\"string\",\"description\":\"Commit message\"}},\"required\":[\"owner\",\"repo\",\"branch\",\"files\",\"message\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_issue\",\"description\":\"Create a new issue in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"body\":{\"type\":\"string\"},\"assignees\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"milestone\":{\"type\":\"number\"},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"owner\",\"repo\",\"title\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_pull_request\",\"description\":\"Create a new pull request in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"title\":{\"type\":\"string\",\"description\":\"Pull request title\"},\"body\":{\"type\":\"string\",\"description\":\"Pull request body/description\"},\"head\":{\"type\":\"string\",\"description\":\"The name of the branch where your changes are implemented\"},\"base\":{\"type\":\"string\",\"description\":\"The name of the branch you want the changes pulled into\"},\"draft\":{\"type\":\"boolean\",\"description\":\"Whether to create the pull request as a draft\"},\"maintainer_can_modify\":{\"type\":\"boolean\",\"description\":\"Whether maintainers can modify the pull request\"}},\"required\":[\"owner\",\"repo\",\"title\",\"head\",\"base\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-fork_repository\",\"description\":\"Fork a GitHub repository to your account or specified organization\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"organization\":{\"type\":\"string\",\"description\":\"Optional: organization to fork to (defaults to your personal account)\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_branch\",\"description\":\"Create a new branch in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"branch\":{\"type\":\"string\",\"description\":\"Name for the new branch\"},\"from_branch\":{\"type\":\"string\",\"description\":\"Optional: source branch to create from (defaults to the repository\\'s default branch)\"}},\"required\":[\"owner\",\"repo\",\"branch\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_commits\",\"description\":\"Get list of commits of a branch in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"sha\":{\"type\":\"string\"},\"page\":{\"type\":\"number\"},\"perPage\":{\"type\":\"number\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_issues\",\"description\":\"List issues in a GitHub repository with filtering options\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"direction\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"page\":{\"type\":\"number\"},\"per_page\":{\"type\":\"number\"},\"since\":{\"type\":\"string\"},\"sort\":{\"type\":\"string\",\"enum\":[\"created\",\"updated\",\"comments\"]},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\",\"all\"]}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-update_issue\",\"description\":\"Update an existing issue in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"},\"title\":{\"type\":\"string\"},\"body\":{\"type\":\"string\"},\"assignees\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"milestone\":{\"type\":\"number\"},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\"]}},\"required\":[\"owner\",\"repo\",\"issue_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-add_issue_comment\",\"description\":\"Add a comment to an existing issue\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"},\"body\":{\"type\":\"string\"}},\"required\":[\"owner\",\"repo\",\"issue_number\",\"body\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_code\",\"description\":\"Search for code across GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_issues\",\"description\":\"Search for issues and pull requests across GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100},\"sort\":{\"type\":\"string\",\"enum\":[\"comments\",\"reactions\",\"reactions-+1\",\"reactions--1\",\"reactions-smile\",\"reactions-thinking_face\",\"reactions-heart\",\"reactions-tada\",\"interactions\",\"created\",\"updated\"]}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_users\",\"description\":\"Search for users on GitHub\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100},\"sort\":{\"type\":\"string\",\"enum\":[\"followers\",\"repositories\",\"joined\"]}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_issue\",\"description\":\"Get details of a specific issue in a GitHub repository.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"}},\"required\":[\"owner\",\"repo\",\"issue_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request\",\"description\":\"Get details of a specific pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_pull_requests\",\"description\":\"List and filter repository pull requests\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\",\"all\"],\"description\":\"State of the pull requests to return\"},\"head\":{\"type\":\"string\",\"description\":\"Filter by head user or head organization and branch name\"},\"base\":{\"type\":\"string\",\"description\":\"Filter by base branch name\"},\"sort\":{\"type\":\"string\",\"enum\":[\"created\",\"updated\",\"popularity\",\"long-running\"],\"description\":\"What to sort results by\"},\"direction\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"],\"description\":\"The direction of the sort\"},\"per_page\":{\"type\":\"number\",\"description\":\"Results per page (max 100)\"},\"page\":{\"type\":\"number\",\"description\":\"Page number of the results\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_pull_request_review\",\"description\":\"Create a review on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"commit_id\":{\"type\":\"string\",\"description\":\"The SHA of the commit that needs a review\"},\"body\":{\"type\":\"string\",\"description\":\"The body text of the review\"},\"event\":{\"type\":\"string\",\"enum\":[\"APPROVE\",\"REQUEST_CHANGES\",\"COMMENT\"],\"description\":\"The review action to perform\"},\"comments\":{\"type\":\"array\",\"items\":{\"anyOf\":[{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\",\"description\":\"The relative path to the file being commented on\"},\"position\":{\"type\":\"number\",\"description\":\"The position in the diff where you want to add a review comment\"},\"body\":{\"type\":\"string\",\"description\":\"Text of the review comment\"}},\"required\":[\"path\",\"position\",\"body\"],\"additionalProperties\":false},{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\",\"description\":\"The relative path to the file being commented on\"},\"line\":{\"type\":\"number\",\"description\":\"The line number in the file where you want to add a review comment\"},\"body\":{\"type\":\"string\",\"description\":\"Text of the review comment\"}},\"required\":[\"path\",\"line\",\"body\"],\"additionalProperties\":false}]},\"description\":\"Comments to post as part of the review (specify either position or line, not both)\"}},\"required\":[\"owner\",\"repo\",\"pull_number\",\"body\",\"event\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-merge_pull_request\",\"description\":\"Merge a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"commit_title\":{\"type\":\"string\",\"description\":\"Title for the automatic commit message\"},\"commit_message\":{\"type\":\"string\",\"description\":\"Extra detail to append to automatic commit message\"},\"merge_method\":{\"type\":\"string\",\"enum\":[\"merge\",\"squash\",\"rebase\"],\"description\":\"Merge method to use\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_files\",\"description\":\"Get the list of files changed in a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_status\",\"description\":\"Get the combined status of all status checks for a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-update_pull_request_branch\",\"description\":\"Update a pull request branch with the latest changes from the base branch\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"expected_head_sha\":{\"type\":\"string\",\"description\":\"The expected SHA of the pull request\\'s HEAD ref\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_comments\",\"description\":\"Get the review comments on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_reviews\",\"description\":\"Get the reviews on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-read_file\",\"description\":\"Read the complete contents of a file from the file system. Handles various text encodings and provides detailed error messages if the file cannot be read. Use this tool when you need to examine the contents of a single file. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-read_multiple_files\",\"description\":\"Read the contents of multiple files simultaneously. This is more efficient than reading files one by one when you need to analyze or compare multiple files. Each file\\'s content is returned with its path as a reference. Failed reads for individual files won\\'t stop the entire operation. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"paths\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"paths\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-write_file\",\"description\":\"Create a new file or completely overwrite an existing file with new content. Use with caution as it will overwrite existing files without warning. Handles text content with proper encoding. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"content\":{\"type\":\"string\"}},\"required\":[\"path\",\"content\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-edit_file\",\"description\":\"Make line-based edits to a text file. Each edit replaces exact line sequences with new content. Returns a git-style diff showing the changes made. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"edits\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"oldText\":{\"type\":\"string\",\"description\":\"Text to search for - must match exactly\"},\"newText\":{\"type\":\"string\",\"description\":\"Text to replace with\"}},\"required\":[\"oldText\",\"newText\"],\"additionalProperties\":false}},\"dryRun\":{\"type\":\"boolean\",\"default\":false,\"description\":\"Preview changes using git-style diff format\"}},\"required\":[\"path\",\"edits\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-create_directory\",\"description\":\"Create a new directory or ensure a directory exists. Can create multiple nested directories in one operation. If the directory already exists, this operation will succeed silently. Perfect for setting up directory structures for projects or ensuring required paths exist. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-list_directory\",\"description\":\"Get a detailed listing of all files and directories in a specified path. Results clearly distinguish between files and directories with [FILE] and [DIR] prefixes. This tool is essential for understanding directory structure and finding specific files within a directory. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-directory_tree\",\"description\":\"Get a recursive tree view of files and directories as a JSON structure. Each entry includes \\'name\\', \\'type\\' (file/directory), and \\'children\\' for directories. Files have no children array, while directories always have a children array (which may be empty). The output is formatted with 2-space indentation for readability. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-move_file\",\"description\":\"Move or rename files and directories. Can move files between directories and rename them in a single operation. If the destination exists, the operation will fail. Works across different directories and can be used for simple renaming within the same directory. Both source and destination must be within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"source\":{\"type\":\"string\"},\"destination\":{\"type\":\"string\"}},\"required\":[\"source\",\"destination\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-search_files\",\"description\":\"Recursively search for files and directories matching a pattern. Searches through all subdirectories from the starting path. The search is case-insensitive and matches partial names. Returns full paths to all matching items. Great for finding files when you don\\'t know their exact location. Only searches within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"pattern\":{\"type\":\"string\"},\"excludePatterns\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"default\":[]}},\"required\":[\"path\",\"pattern\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-get_file_info\",\"description\":\"Retrieve detailed metadata about a file or directory. Returns comprehensive information including size, creation time, last modified time, permissions, and type. This tool is perfect for understanding file characteristics without reading the actual content. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-list_allowed_directories\",\"description\":\"Returns the list of directories that this server is allowed to access. Use this to understand which directories are available before trying to access files.\",\"input_schema\":{\"type\":\"object\",\"properties\":{},\"required\":[]}},{\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"description\":\"Query an Amazon Bedrock Knowledge Base using natural language.\\\\n\\\\n    ## Usage Requirements\\\\n    - You MUST first use the `resource://knowledgebases` resource to get valid knowledge base IDs\\\\n    - You can query different knowledge bases or make multiple queries to the same knowledge base\\\\n\\\\n    ## Query Tips\\\\n    - Use clear, specific natural language queries for best results\\\\n    - You can use this tool MULTIPLE TIMES with different queries to gather comprehensive information\\\\n    - Break complex questions into multiple focused queries\\\\n    - Consider querying for factual information and explanations separately\\\\n\\\\n    ## Tool output format\\\\n    The response contains multiple JSON objects (one per line), each representing a retrieved document with:\\\\n    - content: The text content of the document\\\\n    - location: The source location of the document\\\\n    - score: The relevance score of the document\\\\n\\\\n\\\\n    ## Interpretation Best Practices\\\\n    1. Extract and combine key information from multiple results\\\\n    2. Consider the source and relevance score when evaluating information\\\\n    3. Use follow-up queries to clarify ambiguous or incomplete information\\\\n    4. If the response is not relevant, try a different query, knowledge base, and/or data source\\\\n    5. After a few attempts, ask the user for clarification or a different query.\\\\n    \",\"input_schema\":{\"properties\":{\"query\":{\"description\":\"A natural language query to search the knowledge base with\",\"title\":\"Query\",\"type\":\"string\"},\"knowledge_base_id\":{\"description\":\"The knowledge base ID to query. It must be a valid ID from the resource://knowledgebases MCP resource\",\"title\":\"Knowledge Base Id\",\"type\":\"string\"},\"number_of_results\":{\"default\":10,\"description\":\"The number of results to return. Use smaller values for focused results and larger values for broader coverage.\",\"title\":\"Number Of Results\",\"type\":\"integer\"},\"reranking\":{\"default\":false,\"description\":\"Whether to rerank the results. Useful for improving relevance and sorting. Can be globally configured with BEDROCK_KB_RERANKING_ENABLED environment variable.\",\"title\":\"Reranking\",\"type\":\"boolean\"},\"reranking_model_name\":{\"default\":\"AMAZON\",\"description\":\"The name of the reranking model to use. Options: \\'COHERE\\', \\'AMAZON\\'\",\"enum\":[\"COHERE\",\"AMAZON\"],\"title\":\"Reranking Model Name\",\"type\":\"string\"},\"data_source_ids\":{\"anyOf\":[{\"items\":{\"type\":\"string\"},\"type\":\"array\"},{\"type\":\"null\"}],\"default\":null,\"description\":\"The data source IDs to filter the knowledge base by. It must be a list of valid data source IDs from the resource://knowledgebases MCP resource\",\"title\":\"Data Source Ids\"}},\"required\":[\"query\",\"knowledge_base_id\"],\"title\":\"query_knowledge_bases_toolArguments\",\"type\":\"object\"}}],\"anthropic_version\":\"bedrock-2023-05-31\"}'"},"message":"Error code: 429 - {'message': 'Too many tokens, please wait before trying again.'}","body":{"message":"Too many tokens, please wait before trying again."},"response":"<httpx.Response [429] https://bedrock-runtime.us-west-2.amazonaws.com/model/us.anthropic.claude-3-7-sonnet-20250219-v1:0/invoke>","status_code":429,"request_id":null}]}}
{"level":"ERROR","timestamp":"2025-05-15T11:01:44.877223","namespace":"mcp_agent.llm.augmented_llm","message":"Error: Error code: 429 - {'message': 'Too many tokens, please wait before trying again.'}","data":{"data":[{"request":{"method":"POST","url":{"_uri_reference":["https","","bedrock-runtime.us-west-2.amazonaws.com",null,"/model/us.anthropic.claude-3-7-sonnet-20250219-v1:0/invoke",null,null]},"headers":["connection","host","accept-encoding","x-stainless-timeout","accept","content-type","user-agent","x-stainless-lang","x-stainless-package-version","x-stainless-os","x-stainless-arch","x-stainless-runtime","x-stainless-runtime-version","x-stainless-retry-count","x-stainless-read-timeout","content-length","x-amz-date","x-amz-security-token","authorization"],"extensions":{"timeout":{"connect":5.0,"read":600,"write":"600","pool":"600"}},"stream":[{"capitalize":"<callable: capitalize>","center":"<callable: center>","count":"<callable: count>","decode":"<callable: decode>","endswith":"<callable: endswith>","expandtabs":"<callable: expandtabs>","find":"<callable: find>","fromhex":"<callable: fromhex>","hex":"<callable: hex>","index":"<callable: index>","isalnum":"<callable: isalnum>","isalpha":"<callable: isalpha>","isascii":"<callable: isascii>","isdigit":"<callable: isdigit>","islower":"<callable: islower>","isspace":"<callable: isspace>","istitle":"<callable: istitle>","isupper":"<callable: isupper>","join":"<callable: join>","ljust":"<callable: ljust>","lower":"<callable: lower>","lstrip":"<callable: lstrip>","maketrans":"<callable: maketrans>","partition":"<callable: partition>","removeprefix":"<callable: removeprefix>","removesuffix":"<callable: removesuffix>","replace":"<callable: replace>","rfind":"<callable: rfind>","rindex":"<callable: rindex>","rjust":"<callable: rjust>","rpartition":"<callable: rpartition>","rsplit":"<callable: rsplit>","rstrip":"<callable: rstrip>","split":"<callable: split>","splitlines":"<callable: splitlines>","startswith":"<callable: startswith>","strip":"<callable: strip>","swapcase":"<callable: swapcase>","title":"<callable: title>","translate":"<callable: translate>","upper":"<callable: upper>","zfill":"<callable: zfill>"}],"_content":"b'{\"max_tokens\":4096,\"messages\":[{\"role\":\"user\",\"content\":[{\"type\":\"text\",\"text\":\"please review https://github.com/awslabs/aws-c-s3/pull/519\"}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"I\\'ll review the pull request at https://github.com/awslabs/aws-c-s3/pull/519. Let me first get the details of this PR to understand what it\\'s about.\"},{\"type\":\"tool_use\",\"name\":\"github-get_pull_request\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"pull_number\":519},\"id\":\"toolu_bdrk_01UX8q4t6vcuBkTZiqXK9C47\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01UX8q4t6vcuBkTZiqXK9C47\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\n  \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/pulls/519\\\\\",\\\\n  \\\\\"id\\\\\": 2520395028,\\\\n  \\\\\"node_id\\\\\": \\\\\"PR_kwDOEJB4Sc6WOi0U\\\\\",\\\\n  \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519\\\\\",\\\\n  \\\\\"diff_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519.diff\\\\\",\\\\n  \\\\\"patch_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519.patch\\\\\",\\\\n  \\\\\"issue_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/issues/519\\\\\",\\\\n  \\\\\"number\\\\\": 519,\\\\n  \\\\\"state\\\\\": \\\\\"open\\\\\",\\\\n  \\\\\"locked\\\\\": false,\\\\n  \\\\\"title\\\\\": \\\\\"dummy test\\\\\",\\\\n  \\\\\"user\\\\\": {\\\\n    \\\\\"login\\\\\": \\\\\"TingDaoK\\\\\",\\\\n    \\\\\"id\\\\\": 26829806,\\\\n    \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/26829806?v=4\\\\\",\\\\n    \\\\\"url\\\\\": \\\\\"https://api.github.com/users/TingDaoK\\\\\",\\\\n    \\\\\"html_url\\\\\": \\\\\"https://github.com/TingDaoK\\\\\"\\\\n  },\\\\n  \\\\\"body\\\\\": \\\\\"*Issue #, if available:*\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n*Description of changes:*\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.\\\\\\\\r\\\\\\\\n\\\\\",\\\\n  \\\\\"created_at\\\\\": \\\\\"2025-05-14T21:35:46Z\\\\\",\\\\n  \\\\\"updated_at\\\\\": \\\\\"2025-05-14T23:38:00Z\\\\\",\\\\n  \\\\\"closed_at\\\\\": null,\\\\n  \\\\\"merged_at\\\\\": null,\\\\n  \\\\\"merge_commit_sha\\\\\": \\\\\"b8fc1c78ceeba7906b6ac56483199a3faaf5e9cd\\\\\",\\\\n  \\\\\"assignee\\\\\": null,\\\\n  \\\\\"assignees\\\\\": [],\\\\n  \\\\\"requested_reviewers\\\\\": [],\\\\n  \\\\\"labels\\\\\": [],\\\\n  \\\\\"head\\\\\": {\\\\n    \\\\\"label\\\\\": \\\\\"awslabs:dummy-delete-me\\\\\",\\\\n    \\\\\"ref\\\\\": \\\\\"dummy-delete-me\\\\\",\\\\n    \\\\\"sha\\\\\": \\\\\"e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6\\\\\",\\\\n    \\\\\"user\\\\\": {\\\\n      \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n      \\\\\"id\\\\\": 3299148,\\\\n      \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\"\\\\n    },\\\\n    \\\\\"repo\\\\\": {\\\\n      \\\\\"id\\\\\": 277903433,\\\\n      \\\\\"node_id\\\\\": \\\\\"MDEwOlJlcG9zaXRvcnkyNzc5MDM0MzM=\\\\\",\\\\n      \\\\\"name\\\\\": \\\\\"aws-c-s3\\\\\",\\\\n      \\\\\"full_name\\\\\": \\\\\"awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"private\\\\\": false,\\\\n      \\\\\"owner\\\\\": {\\\\n        \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n        \\\\\"id\\\\\": 3299148,\\\\n        \\\\\"node_id\\\\\": \\\\\"MDEyOk9yZ2FuaXphdGlvbjMyOTkxNDg=\\\\\",\\\\n        \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n        \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n        \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\",\\\\n        \\\\\"type\\\\\": \\\\\"Organization\\\\\"\\\\n      },\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"description\\\\\": \\\\\"C99 library implementation for communicating with the S3 service, designed for maximizing throughput on high bandwidth EC2 instances.\\\\\",\\\\n      \\\\\"fork\\\\\": false,\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"created_at\\\\\": \\\\\"2020-07-07T19:21:45Z\\\\\",\\\\n      \\\\\"updated_at\\\\\": \\\\\"2025-05-15T17:15:47Z\\\\\",\\\\n      \\\\\"pushed_at\\\\\": \\\\\"2025-05-15T17:16:08Z\\\\\",\\\\n      \\\\\"git_url\\\\\": \\\\\"git://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"ssh_url\\\\\": \\\\\"git@github.com:awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"clone_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"default_branch\\\\\": \\\\\"main\\\\\"\\\\n    }\\\\n  },\\\\n  \\\\\"base\\\\\": {\\\\n    \\\\\"label\\\\\": \\\\\"awslabs:main\\\\\",\\\\n    \\\\\"ref\\\\\": \\\\\"main\\\\\",\\\\n    \\\\\"sha\\\\\": \\\\\"7d2d4b3070109c882ff78e8719f60597c7ba0472\\\\\",\\\\n    \\\\\"user\\\\\": {\\\\n      \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n      \\\\\"id\\\\\": 3299148,\\\\n      \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\"\\\\n    },\\\\n    \\\\\"repo\\\\\": {\\\\n      \\\\\"id\\\\\": 277903433,\\\\n      \\\\\"node_id\\\\\": \\\\\"MDEwOlJlcG9zaXRvcnkyNzc5MDM0MzM=\\\\\",\\\\n      \\\\\"name\\\\\": \\\\\"aws-c-s3\\\\\",\\\\n      \\\\\"full_name\\\\\": \\\\\"awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"private\\\\\": false,\\\\n      \\\\\"owner\\\\\": {\\\\n        \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n        \\\\\"id\\\\\": 3299148,\\\\n        \\\\\"node_id\\\\\": \\\\\"MDEyOk9yZ2FuaXphdGlvbjMyOTkxNDg=\\\\\",\\\\n        \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n        \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n        \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\",\\\\n        \\\\\"type\\\\\": \\\\\"Organization\\\\\"\\\\n      },\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"description\\\\\": \\\\\"C99 library implementation for communicating with the S3 service, designed for maximizing throughput on high bandwidth EC2 instances.\\\\\",\\\\n      \\\\\"fork\\\\\": false,\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"created_at\\\\\": \\\\\"2020-07-07T19:21:45Z\\\\\",\\\\n      \\\\\"updated_at\\\\\": \\\\\"2025-05-15T17:15:47Z\\\\\",\\\\n      \\\\\"pushed_at\\\\\": \\\\\"2025-05-15T17:16:08Z\\\\\",\\\\n      \\\\\"git_url\\\\\": \\\\\"git://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"ssh_url\\\\\": \\\\\"git@github.com:awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"clone_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"default_branch\\\\\": \\\\\"main\\\\\"\\\\n    }\\\\n  }\\\\n}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now, let me look at the files that were changed in this PR:\"},{\"type\":\"tool_use\",\"name\":\"github-get_pull_request_files\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"pull_number\":519},\"id\":\"toolu_bdrk_01JnCqby18mSvcazUhEu9KbB\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01JnCqby18mSvcazUhEu9KbB\",\"content\":[{\"type\":\"text\",\"text\":\"[\\\\n  {\\\\n    \\\\\"sha\\\\\": \\\\\"dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n    \\\\\"filename\\\\\": \\\\\"tests/s3_data_plane_tests.c\\\\\",\\\\n    \\\\\"status\\\\\": \\\\\"modified\\\\\",\\\\n    \\\\\"additions\\\\\": 49,\\\\n    \\\\\"deletions\\\\\": 0,\\\\n    \\\\\"changes\\\\\": 49,\\\\n    \\\\\"blob_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6/tests%2Fs3_data_plane_tests.c\\\\\",\\\\n    \\\\\"raw_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/raw/e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6/tests%2Fs3_data_plane_tests.c\\\\\",\\\\n    \\\\\"contents_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests%2Fs3_data_plane_tests.c?ref=e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6\\\\\",\\\\n    \\\\\"patch\\\\\": \\\\\"@@ -8114,3 +8114,52 @@ static int s_test_s3_default_get_without_content_length(struct aws_allocator *al\\\\\\\\n \\\\\\\\n     return AWS_OP_SUCCESS;\\\\\\\\n }\\\\\\\\n+\\\\\\\\n+struct aws_string *test_helper(struct aws_allocator *allocator) {\\\\\\\\n+    struct aws_string *host_name =\\\\\\\\n+        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n+    return host_name;\\\\\\\\n+}\\\\\\\\n+\\\\\\\\n+AWS_TEST_CASE(test_s3_default_get, aws_test_s3_default_get)\\\\\\\\n+static int aws_test_s3_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n+    (void)ctx;\\\\\\\\n+\\\\\\\\n+    struct aws_s3_tester tester;\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n+\\\\\\\\n+    struct aws_s3_client *client = NULL;\\\\\\\\n+    struct aws_s3_tester_client_options client_options;\\\\\\\\n+    AWS_ZERO_STRUCT(client_options);\\\\\\\\n+\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n+    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n+    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n+\\\\\\\\n+    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n+    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n+\\\\\\\\n+    struct aws_string *hsot_name = test_helper(allocator);\\\\\\\\n+\\\\\\\\n+    /* Put together a simple S3 Get Object request. */\\\\\\\\n+    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n+        allocator, aws_byte_cursor_from_string(hsot_name), g_pre_existing_object_1MB);\\\\\\\\n+\\\\\\\\n+    struct aws_s3_meta_request_options options;\\\\\\\\n+    AWS_ZERO_STRUCT(options);\\\\\\\\n+    /* Send default type */\\\\\\\\n+    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n+    options.message = message;\\\\\\\\n+    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n+\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n+        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n+\\\\\\\\n+    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n+    aws_http_message_release(message);\\\\\\\\n+    aws_s3_client_release(client);\\\\\\\\n+    aws_s3_tester_clean_up(&tester);\\\\\\\\n+\\\\\\\\n+    return AWS_OP_SUCCESS;\\\\\\\\n+}\\\\\"\\\\n  }\\\\n]\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now let me check the comments style document you mentioned:\"},{\"type\":\"tool_use\",\"name\":\"filesystem-read_file\",\"input\":{\"path\":\"/Users/dengket/project/hackthon/fast-agent/crt_c_reviewer/summarization/comments_styles.md\"},\"id\":\"toolu_bdrk_016Tc6VcYGNaC2Hd1acdXqt6\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_016Tc6VcYGNaC2Hd1acdXqt6\",\"content\":[{\"type\":\"text\",\"text\":\"# Effective Code Review Comment Guidelines\\\\n\\\\nBased on an analysis of multiple GitHub Pull Request reviews, this document summarizes key patterns and best practices for writing effective code review comments.\\\\n\\\\n## General Principles\\\\n\\\\n### 1. Comment Classification\\\\n\\\\n* **Use clear prefixes to indicate severity:**\\\\n  + `trivial:` - Minor issues that should be fixed but don\\'t block approval\\\\n  + `debatable:` or `extremely debatable:` - Suggestions open to discussion\\\\n  + `nit:` - Extremely minor stylistic preferences\\\\n  + `important:` - Issues that should be addressed before merging\\\\n  + `blocking:` - Critical issues that must be resolved\\\\n\\\\n* **Be explicit about expectations:**\\\\n  + Distinguish between mandatory changes and optional suggestions\\\\n  + Indicate when comments are informational rather than requesting changes\\\\n\\\\n### 2. Comment Structure\\\\n\\\\n* **Be specific and actionable:**\\\\n  + Refer to specific lines or sections of code\\\\n  + Explain both what the issue is and why it matters\\\\n  + Provide concrete solutions when possible\\\\n\\\\n* **Use GitHub suggestion blocks for direct code changes:**\\\\n  \\\\n\\\\n```\\\\n  ```suggestion\\\\n  actual code change goes here\\\\n  ```\\\\n\\\\n  \\\\n\\\\n```\\\\n\\\\n- **Group related issues together:**\\\\n  - Number multiple points for clarity\\\\n  - Address similar issues in a single comment when possible\\\\n\\\\n- **Provide context:**\\\\n  - Link to relevant documentation, PRs, or issues\\\\n  - Reference cross-repository standards when applicable\\\\n  - Explain reasoning behind suggestions, not just what to change\\\\n\\\\n### 3. Comment Scope\\\\n\\\\n- **Focus on the right level of detail:**\\\\n  - For simple PRs: Brief approvals may be sufficient\\\\n  - For complex PRs: Detailed, organized feedback is necessary\\\\n\\\\n- **Consider multiple aspects of code quality:**\\\\n  - Functional correctness\\\\n  - Error handling and edge cases\\\\n  - Performance implications\\\\n  - Security considerations\\\\n  - Consistency with existing patterns\\\\n  - Documentation and readability\\\\n  - Cross-platform compatibility\\\\n  - API design and usability\\\\n\\\\n## Technical Focus Areas\\\\n\\\\n### 1. Code Architecture and Design\\\\n\\\\n- **API Usability:**\\\\n  - Consider the developer experience of using the API\\\\n  - Question potentially confusing or redundant API requirements\\\\n  - Think about cross-language compatibility\\\\n\\\\n- **Error Handling:**\\\\n  - Verify proper cleanup in error cases\\\\n  - Ensure appropriate error propagation\\\\n  - Check for consistent error handling patterns\\\\n  - In C code, prefer unified error paths with consolidated cleanup\\\\n\\\\n- **Consistency:**\\\\n  - Flag inconsistent naming conventions\\\\n  - Highlight deviations from established patterns\\\\n  - Ensure consistency across related repositories\\\\n\\\\n### 2. Code Style and Readability\\\\n\\\\n- **Prioritize clear organization:**\\\\n  - Suggest clearer code structure when logic is hard to follow\\\\n  - Flag complex conditionals that could be simplified\\\\n  - Recommend extracting complex logic into well-named helper functions\\\\n\\\\n- **Comment on documentation:**\\\\n  - Ensure comments accurately describe behavior\\\\n  - Request documentation for parameters with specific usage requirements\\\\n  - Verify public API documentation clarity\\\\n\\\\n- **Focus on maintainability:**\\\\n  - Consider how code might evolve in the future\\\\n  - Identify fragile patterns that could break with future changes\\\\n  - Suggest explicit guards against potential future bugs\\\\n\\\\n### 3. Cross-Team and Ecosystem Considerations\\\\n\\\\n- **Coordinate across teams:**\\\\n  - Flag changes that might affect other teams or services\\\\n  - Recommend cross-team communication when necessary\\\\n\\\\n- **Verify ecosystem consistency:**\\\\n  - Check if behavior matches related SDKs or libraries\\\\n  - Confirm conformance to broader project standards\\\\n\\\\n## Review Process\\\\n\\\\n### 1. Reviewing Approach\\\\n\\\\n- **Progressive reviews:**\\\\n  - Start with critical issues and architectural concerns\\\\n  - Follow up on remaining issues after major concerns are addressed\\\\n  - Provide final approval once all necessary changes are made\\\\n\\\\n- **Approval comments:**\\\\n  - Use \\\\\"fix & ship\\\\\" for PRs with only minor issues\\\\n  - Include verification steps if needed before merging\\\\n  - Acknowledge when previous feedback has been addressed\\\\n\\\\n### 2. Review Tone\\\\n\\\\n- **Be direct but constructive:**\\\\n  - Focus on the code, not the person\\\\n  - Frame feedback as improvements rather than criticisms\\\\n  - Use a professional, collaborative tone\\\\n\\\\n- **Acknowledge good work:**\\\\n  - Provide positive feedback on well-implemented features\\\\n  - Recognize when authors have addressed previous feedback well\\\\n  - Use phrases like \\\\\"nice job\\\\\" or \\\\\"this looks good\\\\\" where appropriate\\\\n\\\\n- **Balance criticism with encouragement:**\\\\n  - Point out both strengths and areas for improvement\\\\n  - Recognize the effort that went into the implementation\\\\n\\\\n## Comment Examples by Category\\\\n\\\\n### Effective Trivial Comments\\\\n\\\\n```\\\\n\\\\ntrivial: undoing needless changes to whitespace\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\ntrivial: it\\'s weird to use the `_10MB` and then upload 5MB\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\ntrivial: I found this if-statement confusing, and the helper function that did different things depending on how it\\'s called...\\\\n\\\\n```\\\\n\\\\n### Effective Technical Suggestions\\\\n\\\\n```\\\\n\\\\nif there\\'s an error, we need to cleanup out_checksum\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nSo, if users already added a checksum header, they ALSO need to set this enum?\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nInstead of the `on_error:` label sharing 90% the same cleanup code as `s_s3_client_finish_destroy_default()` , have them share code\\\\n\\\\n```\\\\n\\\\n### Effective Process Comments\\\\n\\\\n```\\\\n\\\\nI\\'d advise checking this branch from aws-crt-cpp, and making sure it all works nicely, before merging\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nChecked the C++ SDK and Java SDK and they also retry on TLS errors.\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nneed to coordinate with python teams on this...\\\\n```\\\\n\\\\n### Silent Approvals (When Appropriate)\\\\n\\\\nSilent approvals (no comments, just approval) are appropriate for:\\\\n* Simple, straightforward changes\\\\n* Well-understood code\\\\n* Follow-up to previous discussions\\\\n* Self-explanatory code\\\\n* Trivial fixes\\\\n* When there\\'s an established trust relationship between reviewer and author\\\\n\\\\n## Special Cases\\\\n\\\\n### 1. Automated/Routine Changes\\\\n\\\\n* **Minimize comments for routine updates:**\\\\n  + For automated changes or version bumps, simple approvals may be sufficient\\\\n  + Focus comments on any unexpected deviations from expected patterns\\\\n\\\\n### 2. Cross-Repository Changes\\\\n\\\\n* **Consider broader impacts:**\\\\n  + For changes affecting multiple repositories, test across all affected codebases\\\\n  + Verify consistency with related repositories\\' standards\\\\n\\\\n### 3. Documentation Changes\\\\n\\\\n* **Focus on accuracy and clarity:**\\\\n  + Ensure documentation correctly describes behavior\\\\n  + Verify examples work as described\\\\n  + Check for consistent formatting and terminology\\\\n\\\\n## Conclusion\\\\n\\\\nEffective code review comments are specific, actionable, appropriately categorized, and delivered in a constructive tone. They focus on technical accuracy while maintaining readability and consistency with project standards. The level of detail should match the complexity of the change, ranging from brief approvals for simple changes to detailed, structured feedback for complex modifications.\\\\n\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now let me get the content of the changed file to understand the context better:\"},{\"type\":\"tool_use\",\"name\":\"github-get_file_contents\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"path\":\"tests/s3_data_plane_tests.c\",\"branch\":\"dummy-delete-me\"},\"id\":\"toolu_bdrk_015ZBeJaKwvuS5AQ6DiPaNrT\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_015ZBeJaKwvuS5AQ6DiPaNrT\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\n  \\\\\"name\\\\\": \\\\\"s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"path\\\\\": \\\\\"tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"sha\\\\\": \\\\\"dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n  \\\\\"size\\\\\": 319574,\\\\n  \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests/s3_data_plane_tests.c?ref=dummy-delete-me\\\\\",\\\\n  \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"git_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/git/blobs/dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n  \\\\\"download_url\\\\\": \\\\\"https://raw.githubusercontent.com/awslabs/aws-c-s3/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"type\\\\\": \\\\\"file\\\\\",\\\\n  \\\\\"content\\\\\": \\\\\"/**\\\\\\\\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\\\\\\\\n * SPDX-License-Identifier: Apache-2.0.\\\\\\\\n */\\\\\\\\n\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_checksums.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\"\\\\\\\\n#include <aws/common/byte_buf.h>\\\\\\\\n#include <aws/common/clock.h>\\\\\\\\n#include <aws/common/common.h>\\\\\\\\n#include <aws/common/encoding.h>\\\\\\\\n#include <aws/common/environment.h>\\\\\\\\n#include <aws/common/ref_count.h>\\\\\\\\n#include <aws/http/request_response.h>\\\\\\\\n#include <aws/http/status_code.h>\\\\\\\\n#include <aws/io/channel_bootstrap.h>\\\\\\\\n#include <aws/io/event_loop.h>\\\\\\\\n#include <aws/io/host_resolver.h>\\\\\\\\n#include <aws/io/stream.h>\\\\\\\\n#include <aws/io/tls_channel_handler.h>\\\\\\\\n#include <aws/io/uri.h>\\\\\\\\n#include <aws/testing/aws_test_harness.h>\\\\\\\\n#include <aws/testing/stream_tester.h>\\\\\\\\n#include <inttypes.h>\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_create_destroy, s_test_s3_client_create_destroy)\\\\\\\\nstatic int s_test_s3_client_create_destroy(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_create_error, s_test_s3_client_create_error)\\\\\\\\nstatic int s_test_s3_client_create_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    struct aws_http_proxy_options proxy_options = {\\\\\\\\n        .connection_type = AWS_HPCT_HTTP_LEGACY,\\\\\\\\n        .host = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"localhost\\\\\\\\\\\\\"),\\\\\\\\n        .port = 8899,\\\\\\\\n    };\\\\\\\\n    client_config.proxy_options = &proxy_options;\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_client_create_error_with_invalid_memory_limit_config,\\\\\\\\n    s_test_s3_client_create_error_with_invalid_memory_limit_config)\\\\\\\\nstatic int s_test_s3_client_create_error_with_invalid_memory_limit_config(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    client_config.memory_limit_in_bytes = 100;\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n    client_config.memory_limit_in_bytes = GB_TO_BYTES(1);\\\\\\\\n    client_config.max_part_size = GB_TO_BYTES(2);\\\\\\\\n    client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_client_create_error_with_invalid_network_interface,\\\\\\\\n    s_test_s3_client_create_error_with_invalid_network_interface)\\\\\\\\nstatic int s_test_s3_client_create_error_with_invalid_network_interface(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor *interface_names_array = aws_mem_calloc(allocator, 1, sizeof(struct aws_byte_cursor));\\\\\\\\n    interface_names_array[0] = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"invalid-nic\\\\\\\\\\\\\");\\\\\\\\n    client_config.network_interface_names_array = interface_names_array;\\\\\\\\n    client_config.num_network_interface_names = 1;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_mem_release(allocator, interface_names_array);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_monitoring_options_override, s_test_s3_client_monitoring_options_override)\\\\\\\\nstatic int s_test_s3_client_monitoring_options_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_http_connection_monitoring_options monitoring_options = {.minimum_throughput_bytes_per_second = 3000};\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.monitoring_options = &monitoring_options};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        client->monitoring_options.minimum_throughput_bytes_per_second ==\\\\\\\\n        client_config.monitoring_options->minimum_throughput_bytes_per_second);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_proxy_ev_settings_override, s_test_s3_client_proxy_ev_settings_override)\\\\\\\\nstatic int s_test_s3_client_proxy_ev_settings_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_tls_connection_options tls_conn_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_conn_options);\\\\\\\\n\\\\\\\\n    struct proxy_env_var_settings proxy_ev_settings = {\\\\\\\\n        .env_var_type = AWS_HPEV_ENABLE,\\\\\\\\n        .tls_options = &tls_conn_options,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.proxy_ev_settings = &proxy_ev_settings};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->proxy_ev_settings->env_var_type == client_config.proxy_ev_settings->env_var_type);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_tcp_keep_alive_options_override, s_test_s3_client_tcp_keep_alive_options_override)\\\\\\\\nstatic int s_test_s3_client_tcp_keep_alive_options_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tcp_keep_alive_options keep_alive_options = {.keep_alive_interval_sec = 20};\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.tcp_keep_alive_options = &keep_alive_options};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        client->tcp_keep_alive_options->keep_alive_interval_sec ==\\\\\\\\n        client_config.tcp_keep_alive_options->keep_alive_interval_sec);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_max_active_connections_override, s_test_s3_client_max_active_connections_override)\\\\\\\\nstatic int s_test_s3_client_max_active_connections_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .max_active_connections_override = 10,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->max_active_connections_override == client_config.max_active_connections_override);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_byo_crypto_no_options, s_test_s3_client_byo_crypto_no_options)\\\\\\\\nstatic int s_test_s3_client_byo_crypto_no_options(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .tls_mode = AWS_MR_TLS_ENABLED,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_last_error() == AWS_ERROR_INVALID_ARGUMENT);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_byo_crypto_with_options, s_test_s3_client_byo_crypto_with_options)\\\\\\\\nstatic int s_test_s3_client_byo_crypto_with_options(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_conn_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_conn_options);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n    client_config.tls_connection_options = &tls_conn_options;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nsize_t s_test_max_active_connections_host_count = 0;\\\\\\\\n\\\\\\\\nsize_t s_test_get_max_active_connections_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    return s_test_max_active_connections_host_count;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_get_max_active_connections, s_test_s3_client_get_max_active_connections)\\\\\\\\nstatic int s_test_s3_client_get_max_active_connections(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)allocator;\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_client_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_client_bootstrap);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    *((uint32_t *)&mock_client->max_active_connections_override) = 0;\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = 100;\\\\\\\\n    mock_client->client_bootstrap = &mock_client_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_get_max_active_connections_host_address_count;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_requests[AWS_S3_META_REQUEST_TYPE_MAX];\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n        /* Setup test data. */\\\\\\\\n        mock_meta_requests[i] = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n        mock_meta_requests[i]->type = i;\\\\\\\\n        mock_meta_requests[i]->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    s_test_max_active_connections_host_count = 2;\\\\\\\\n\\\\\\\\n    /* Behavior should not be affected by max_active_connections_override since it is 0, and should just be in relation\\\\\\\\n     * to ideal-connection-count. */\\\\\\\\n    {\\\\\\\\n        ASSERT_TRUE(aws_s3_client_get_max_active_connections(mock_client, NULL) == mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->ideal_connection_count);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Max active connections override should now cap the calculated amount of active connections. */\\\\\\\\n    {\\\\\\\\n        *((uint32_t *)&mock_client->max_active_connections_override) = 3;\\\\\\\\n\\\\\\\\n        /* Assert that override is low enough to have effect */\\\\\\\\n        ASSERT_TRUE(mock_client->max_active_connections_override < mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(\\\\\\\\n            aws_s3_client_get_max_active_connections(mock_client, NULL) ==\\\\\\\\n            mock_client->max_active_connections_override);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(mock_client->max_active_connections_override < mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->max_active_connections_override);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Max active connections override should be ignored since the calculated amount of max connections is less. */\\\\\\\\n    {\\\\\\\\n        *((uint32_t *)&mock_client->max_active_connections_override) = 100000;\\\\\\\\n\\\\\\\\n        /* Assert that override is NOT low enough to have effect */\\\\\\\\n        ASSERT_TRUE(mock_client->max_active_connections_override > mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(aws_s3_client_get_max_active_connections(mock_client, NULL) == mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(mock_client->max_active_connections_override > mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->ideal_connection_count);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n        mock_meta_requests[i] = aws_s3_meta_request_release(mock_meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_request_create_destroy, s_test_s3_request_create_destroy)\\\\\\\\nstatic int s_test_s3_request_create_destroy(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const int request_tag = 1234;\\\\\\\\n    const enum aws_s3_request_type request_type = AWS_S3_REQUEST_TYPE_LIST_PARTS;\\\\\\\\n    const uint32_t part_number = 5678;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n    meta_request->client = aws_s3_client_acquire(client);\\\\\\\\n\\\\\\\\n    struct aws_http_message *request_message = aws_s3_tester_dummy_http_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(request_message != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n        meta_request, request_tag, request_type, part_number, AWS_S3_REQUEST_FLAG_RECORD_RESPONSE_HEADERS);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->meta_request == meta_request);\\\\\\\\n    ASSERT_TRUE(request->part_number == part_number);\\\\\\\\n    ASSERT_TRUE(request->request_tag == request_tag);\\\\\\\\n    ASSERT_TRUE(request->request_type == request_type);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"ListParts\\\\\\\\\\\\\", aws_string_c_str(request->operation_name));\\\\\\\\n    ASSERT_TRUE(request->record_response_headers == true);\\\\\\\\n\\\\\\\\n    aws_s3_request_setup_send_data(request, request_message);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->send_data.message != NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers == NULL);\\\\\\\\n\\\\\\\\n    request->send_data.response_headers = aws_http_headers_new(allocator);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers != NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.metrics != NULL);\\\\\\\\n    request->send_data.metrics = aws_s3_request_metrics_release(request->send_data.metrics);\\\\\\\\n\\\\\\\\n    aws_s3_request_clean_up_send_data(request);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->send_data.message == NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers == NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_status == 0);\\\\\\\\n\\\\\\\\n    aws_s3_request_release(request);\\\\\\\\n    aws_http_message_release(request_message);\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct s3_test_body_streaming_user_data {\\\\\\\\n    struct aws_s3_tester *tester;\\\\\\\\n    struct aws_allocator *allocator;\\\\\\\\n    uint64_t expected_range_start;\\\\\\\\n    uint64_t received_body_size;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic int s_s3_meta_request_test_body_streaming_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)body;\\\\\\\\n    (void)range_start;\\\\\\\\n\\\\\\\\n    struct s3_test_body_streaming_user_data *body_streaming_user_data = user_data;\\\\\\\\n\\\\\\\\n    body_streaming_user_data->received_body_size += body->len;\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_streaming_user_data->expected_range_start == range_start);\\\\\\\\n    body_streaming_user_data->expected_range_start += body->len;\\\\\\\\n\\\\\\\\n    aws_s3_tester_inc_counter1(body_streaming_user_data->tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test the meta request body streaming functionality. */\\\\\\\\nAWS_TEST_CASE(test_s3_meta_request_body_streaming, s_test_s3_meta_request_body_streaming)\\\\\\\\nstatic int s_test_s3_meta_request_body_streaming(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const uint32_t part_range0_start = 1;\\\\\\\\n    const uint32_t part_range0_end = part_range0_start + 4;\\\\\\\\n\\\\\\\\n    const uint32_t part_range1_start = part_range0_end + 1;\\\\\\\\n    const uint32_t part_range1_end = part_range1_start + 4;\\\\\\\\n\\\\\\\\n    const size_t request_response_body_size = 16;\\\\\\\\n\\\\\\\\n    const uint64_t total_object_size = (uint64_t)part_range1_end * request_response_body_size;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf response_body_source_buffer;\\\\\\\\n    aws_byte_buf_init(&response_body_source_buffer, allocator, request_response_body_size);\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor test_byte_cursor = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"0\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < request_response_body_size; ++i) {\\\\\\\\n        aws_byte_buf_append(&response_body_source_buffer, &test_byte_cursor);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct s3_test_body_streaming_user_data body_streaming_user_data = {\\\\\\\\n        .tester = &tester,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_event_loop_group *event_loop_group = aws_event_loop_group_new_default(allocator, 0, NULL);\\\\\\\\n    meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    meta_request->user_data = &body_streaming_user_data;\\\\\\\\n    *((size_t *)&meta_request->part_size) = request_response_body_size;\\\\\\\\n    meta_request->body_callback = s_s3_meta_request_test_body_streaming_callback;\\\\\\\\n    meta_request->io_event_loop = aws_event_loop_group_get_next_loop(event_loop_group);\\\\\\\\n\\\\\\\\n    /* Queue the first range of parts in order. Each part should be flushed one-by-one. */\\\\\\\\n    {\\\\\\\\n        for (uint32_t part_number = part_range0_start; part_number <= part_range0_end; ++part_number) {\\\\\\\\n            struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n                meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_number, 0 /*flags*/);\\\\\\\\n\\\\\\\\n            aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n                0ULL,\\\\\\\\n                total_object_size - 1,\\\\\\\\n                request_response_body_size /*part_size*/,\\\\\\\\n                (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n                part_number,\\\\\\\\n                &request->part_range_start,\\\\\\\\n                &request->part_range_end);\\\\\\\\n\\\\\\\\n            aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n            aws_s3_tester_set_counter1_desired(&tester, part_number);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n            ASSERT_TRUE(aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == 0);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_tester_wait_for_counters(&tester);\\\\\\\\n\\\\\\\\n            aws_s3_request_release(request);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_set_counter1_desired(&tester, part_range1_end);\\\\\\\\n\\\\\\\\n    /* Queue parts for second range, but skip over the first part.*/\\\\\\\\n    {\\\\\\\\n        uint32_t num_parts_queued = 0;\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(part_range1_start != part_range1_end);\\\\\\\\n\\\\\\\\n        for (uint32_t part_number = part_range1_start + 1; part_number <= part_range1_end; ++part_number) {\\\\\\\\n            struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n                meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_number, 0 /*flags*/);\\\\\\\\n\\\\\\\\n            aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n                0ULL,\\\\\\\\n                total_object_size - 1,\\\\\\\\n                request_response_body_size /*part_size*/,\\\\\\\\n                (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n                part_number,\\\\\\\\n                &request->part_range_start,\\\\\\\\n                &request->part_range_end);\\\\\\\\n\\\\\\\\n            aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n            aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n            aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_request_release(request);\\\\\\\\n            ++num_parts_queued;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        ASSERT_TRUE(\\\\\\\\n            aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == num_parts_queued);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Stream the last part of the body, which should flush the priority queue. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n            meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_range1_start, 0 /*flags*/);\\\\\\\\n\\\\\\\\n        aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n            0ULL,\\\\\\\\n            total_object_size - 1,\\\\\\\\n            request_response_body_size /*part_size*/,\\\\\\\\n            (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n            part_range1_start,\\\\\\\\n            &request->part_range_start,\\\\\\\\n            &request->part_range_end);\\\\\\\\n\\\\\\\\n        aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        ASSERT_TRUE(aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == 0);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n        aws_s3_request_release(request);\\\\\\\\n\\\\\\\\n        aws_s3_tester_wait_for_counters(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_streaming_user_data.received_body_size == (request_response_body_size * part_range1_end));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_event_loop_group_release(event_loop_group);\\\\\\\\n    aws_byte_buf_clean_up(&response_body_source_buffer);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test aws_s3_client_queue_requests_threaded and aws_s3_client_dequeue_request_threaded */\\\\\\\\nAWS_TEST_CASE(test_s3_client_queue_requests, s_test_s3_client_queue_requests)\\\\\\\\nstatic int s_test_s3_client_queue_requests(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *pivot_request = aws_s3_request_new(mock_meta_request, 0, 0, 0, 0);\\\\\\\\n\\\\\\\\n    struct aws_linked_list pivot_request_list;\\\\\\\\n    aws_linked_list_init(&pivot_request_list);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *requests[] = {\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    const uint32_t num_requests = AWS_ARRAY_SIZE(requests);\\\\\\\\n\\\\\\\\n    struct aws_linked_list request_list;\\\\\\\\n    aws_linked_list_init(&request_list);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        aws_linked_list_push_back(&pivot_request_list, &pivot_request->node);\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &pivot_request_list, false);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 1);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n            aws_linked_list_push_back(&request_list, &requests[i]->node);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Move the requests to the back of the queue. */\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &request_list, false);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&request_list));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests + 1));\\\\\\\\n    ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        /* The first request should be the pivot request since the other requests were pushed to the back. */\\\\\\\\n        struct aws_s3_request *first_request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n        ASSERT_TRUE(first_request == pivot_request);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == num_requests);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        struct aws_s3_request *request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(request == requests[i]);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests - (i + 1)));\\\\\\\\n\\\\\\\\n        if (i < num_requests - 1) {\\\\\\\\n            ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        aws_linked_list_push_back(&pivot_request_list, &pivot_request->node);\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &pivot_request_list, false);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 1);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n            aws_linked_list_push_back(&request_list, &requests[i]->node);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Move the requests to the front of the queue. */\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &request_list, true);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&request_list));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests + 1));\\\\\\\\n    ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        struct aws_s3_request *request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(request == requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        /* The last request should be the pivot request since the other requests were pushed to the front. */\\\\\\\\n        struct aws_s3_request *last_request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n        ASSERT_TRUE(last_request == pivot_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        aws_s3_request_release(requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_request_release(pivot_request);\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct test_work_meta_request_update_user_data {\\\\\\\\n    bool has_work_remaining;\\\\\\\\n    uint32_t num_prepares;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic bool s_s3_test_work_meta_request_update(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    uint32_t flags,\\\\\\\\n    struct aws_s3_request **out_request) {\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data *user_data = meta_request->user_data;\\\\\\\\n\\\\\\\\n    if (out_request) {\\\\\\\\n        if (user_data->has_work_remaining) {\\\\\\\\n            *out_request = aws_s3_request_new(meta_request, 0, 0, 0, 0);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return user_data->has_work_remaining;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_work_meta_request_schedule_prepare_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    aws_s3_meta_request_prepare_request_callback_fn *callback,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)request;\\\\\\\\n    (void)callback;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data *test_user_data = meta_request->user_data;\\\\\\\\n    ++test_user_data->num_prepares;\\\\\\\\n\\\\\\\\n    aws_s3_request_release(request);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic size_t s_test_s3_update_meta_request_trigger_prepare_host_address_count = 0;\\\\\\\\n\\\\\\\\nstatic size_t s_test_s3_update_meta_request_trigger_prepare_get_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n    return s_test_s3_update_meta_request_trigger_prepare_host_address_count;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_validate_prepared_requests(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    size_t expected_num_being_prepared,\\\\\\\\n    struct aws_s3_meta_request *meta_request_with_work,\\\\\\\\n    struct aws_s3_meta_request *meta_request_without_work) {\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->threaded_data.request_queue_size == 0);\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&client->threaded_data.request_queue));\\\\\\\\n    ASSERT_TRUE(client->threaded_data.num_requests_being_prepared == expected_num_being_prepared);\\\\\\\\n    ASSERT_TRUE(aws_atomic_load_int(&client->stats.num_requests_in_flight) == expected_num_being_prepared);\\\\\\\\n\\\\\\\\n    uint32_t num_meta_requests_in_list = 0;\\\\\\\\n    bool meta_request_with_work_found = false;\\\\\\\\n\\\\\\\\n    for (struct aws_linked_list_node *node = aws_linked_list_begin(&client->threaded_data.meta_requests);\\\\\\\\n         node != aws_linked_list_end(&client->threaded_data.meta_requests);\\\\\\\\n         node = aws_linked_list_next(node)) {\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request *meta_request =\\\\\\\\n            AWS_CONTAINER_OF(node, struct aws_s3_meta_request, client_process_work_threaded_data);\\\\\\\\n\\\\\\\\n        if (meta_request == meta_request_with_work) {\\\\\\\\n            meta_request_with_work_found = true;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_request != meta_request_without_work);\\\\\\\\n\\\\\\\\n        ++num_meta_requests_in_list;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_with_work_found);\\\\\\\\n    ASSERT_TRUE(num_meta_requests_in_list == 1);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the client will prepare requests correctly. */\\\\\\\\nAWS_TEST_CASE(test_s3_update_meta_requests_trigger_prepare, s_test_s3_update_meta_requests_trigger_prepare)\\\\\\\\nstatic int s_test_s3_update_meta_requests_trigger_prepare(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_bootstrap);\\\\\\\\n\\\\\\\\n    const uint32_t ideal_connection_count = 100;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    mock_client->client_bootstrap = &mock_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_s3_update_meta_request_trigger_prepare_get_host_address_count;\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = ideal_connection_count;\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.meta_requests);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request_without_work = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request_without_work->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    mock_meta_request_without_work->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data mock_meta_request_without_work_data = {\\\\\\\\n        .has_work_remaining = false,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    mock_meta_request_without_work->user_data = &mock_meta_request_without_work_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *meta_request_without_work_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request_without_work, NULL);\\\\\\\\n    meta_request_without_work_vtable->update = s_s3_test_work_meta_request_update;\\\\\\\\n    meta_request_without_work_vtable->schedule_prepare_request = s_s3_test_work_meta_request_schedule_prepare_request;\\\\\\\\n\\\\\\\\n    /* Intentionally push this meta request first to test that it\\'s properly removed from the list. */\\\\\\\\n    aws_linked_list_push_back(\\\\\\\\n        &mock_client->threaded_data.meta_requests,\\\\\\\\n        &mock_meta_request_without_work->client_process_work_threaded_data.node);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_acquire(mock_meta_request_without_work);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request_with_work = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request_with_work->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    struct test_work_meta_request_update_user_data mock_meta_request_with_work_data = {\\\\\\\\n        .has_work_remaining = true,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    mock_meta_request_with_work->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n    mock_meta_request_with_work->user_data = &mock_meta_request_with_work_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *mock_meta_request_with_work_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request_with_work, NULL);\\\\\\\\n    mock_meta_request_with_work_vtable->update = s_s3_test_work_meta_request_update;\\\\\\\\n    mock_meta_request_with_work_vtable->schedule_prepare_request = s_s3_test_work_meta_request_schedule_prepare_request;\\\\\\\\n\\\\\\\\n    aws_linked_list_push_back(\\\\\\\\n        &mock_client->threaded_data.meta_requests,\\\\\\\\n        &mock_meta_request_with_work->client_process_work_threaded_data.node);\\\\\\\\n    aws_s3_meta_request_acquire(mock_meta_request_with_work);\\\\\\\\n\\\\\\\\n    /* With no known addresses, the amount of requests that can be prepared should be lower. */\\\\\\\\n    {\\\\\\\\n        s_test_s3_update_meta_request_trigger_prepare_host_address_count = 0;\\\\\\\\n        aws_s3_client_update_meta_requests_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(s_validate_prepared_requests(\\\\\\\\n            mock_client, g_min_num_connections, mock_meta_request_with_work, mock_meta_request_without_work));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* When the number of known addresses is 1+, the max number of requests should be reached. */\\\\\\\\n    {\\\\\\\\n        const uint32_t max_requests_prepare = aws_s3_client_get_max_requests_prepare(mock_client);\\\\\\\\n\\\\\\\\n        s_test_s3_update_meta_request_trigger_prepare_host_address_count = 1;\\\\\\\\n        aws_s3_client_update_meta_requests_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(s_validate_prepared_requests(\\\\\\\\n            mock_client, max_requests_prepare, mock_meta_request_with_work, mock_meta_request_without_work));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    while (!aws_linked_list_empty(&mock_client->threaded_data.meta_requests)) {\\\\\\\\n        struct aws_linked_list_node *meta_request_node =\\\\\\\\n            aws_linked_list_pop_front(&mock_client->threaded_data.meta_requests);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request *meta_request =\\\\\\\\n            AWS_CONTAINER_OF(meta_request_node, struct aws_s3_meta_request, client_process_work_threaded_data);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_release(meta_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request_without_work);\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request_with_work);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct s3_test_update_connections_finish_result_user_data {\\\\\\\\n    struct aws_s3_request *finished_request;\\\\\\\\n    struct aws_s3_request *create_connection_request;\\\\\\\\n\\\\\\\\n    uint32_t finished_request_call_counter;\\\\\\\\n    uint32_t create_connection_request_call_counter;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic void s_s3_test_meta_request_has_finish_result_finished_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    AWS_ASSERT(request);\\\\\\\\n    (void)error_code;\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data *user_data = meta_request->user_data;\\\\\\\\n    user_data->finished_request = request;\\\\\\\\n    ++user_data->finished_request_call_counter;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_meta_request_has_finish_result_client_create_connection_for_request(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    struct aws_s3_request *request) {\\\\\\\\n    (void)client;\\\\\\\\n    (void)request;\\\\\\\\n    AWS_ASSERT(client);\\\\\\\\n    AWS_ASSERT(request);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = request->meta_request;\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data *user_data = meta_request->user_data;\\\\\\\\n    user_data->create_connection_request = request;\\\\\\\\n    ++user_data->create_connection_request_call_counter;\\\\\\\\n}\\\\\\\\n\\\\\\\\nsize_t s_test_update_conns_finish_result_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    return 1;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the client will correctly discard requests for meta requests that are trying to finish. */\\\\\\\\nAWS_TEST_CASE(test_s3_client_update_connections_finish_result, s_test_s3_client_update_connections_finish_result)\\\\\\\\nstatic int s_test_s3_client_update_connections_finish_result(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_client_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_client_bootstrap);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    mock_client->client_bootstrap = &mock_client_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_update_conns_finish_result_host_address_count;\\\\\\\\n    mock_client->vtable->create_connection_for_request =\\\\\\\\n        s_s3_test_meta_request_has_finish_result_client_create_connection_for_request;\\\\\\\\n\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = 1;\\\\\\\\n\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data test_update_connections_finish_result_user_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_update_connections_finish_result_user_data);\\\\\\\\n\\\\\\\\n    /* Put together a mock meta request that is finished. */\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    mock_meta_request->synced_data.finish_result_set = true;\\\\\\\\n    mock_meta_request->user_data = &test_update_connections_finish_result_user_data;\\\\\\\\n    mock_meta_request->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *mock_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request, NULL);\\\\\\\\n    mock_meta_request_vtable->finished_request = s_s3_test_meta_request_has_finish_result_finished_request;\\\\\\\\n\\\\\\\\n    /* Verify that the request does not get sent because the meta request has finish-result. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request = aws_s3_request_new(mock_meta_request, 0, 0, 0, 0);\\\\\\\\n        aws_linked_list_push_back(&mock_client->threaded_data.request_queue, &request->node);\\\\\\\\n        ++mock_client->threaded_data.request_queue_size;\\\\\\\\n\\\\\\\\n        aws_s3_client_update_connections_threaded(mock_client);\\\\\\\\n\\\\\\\\n        /* Request should still have been dequeued, but immediately passed to the meta request finish function. */\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n        ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request == request);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request_call_counter == 1);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request == NULL);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request_call_counter == 0);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    AWS_ZERO_STRUCT(test_update_connections_finish_result_user_data);\\\\\\\\n\\\\\\\\n    /* Verify that a request with the \\'always send\\' flag still gets sent when the meta request has a finish-result. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request =\\\\\\\\n            aws_s3_request_new(mock_meta_request, 0, 0, 0, AWS_S3_REQUEST_FLAG_ALWAYS_SEND);\\\\\\\\n        aws_linked_list_push_back(&mock_client->threaded_data.request_queue, &request->node);\\\\\\\\n        ++mock_client->threaded_data.request_queue_size;\\\\\\\\n\\\\\\\\n        aws_s3_client_update_connections_threaded(mock_client);\\\\\\\\n\\\\\\\\n        /* Request should have been dequeued, and then sent on a connection. */\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n        ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request == NULL);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request_call_counter == 0);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request == request);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request_call_counter == 1);\\\\\\\\n\\\\\\\\n        aws_s3_request_release(request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_get_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    enum aws_s3_client_tls_usage tls_usage,\\\\\\\\n    uint32_t extra_meta_request_flag,\\\\\\\\n    struct aws_byte_cursor s3_path) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_connection_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_connection_options);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    struct aws_tls_ctx_options tls_context_options;\\\\\\\\n    aws_tls_ctx_options_init_default_client(&tls_context_options, allocator);\\\\\\\\n\\\\\\\\n    struct aws_tls_ctx *context = aws_tls_client_ctx_new(allocator, &tls_context_options);\\\\\\\\n    aws_tls_connection_options_init_from_ctx(&tls_connection_options, context);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    struct aws_string *endpoint =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n    struct aws_byte_cursor endpoint_cursor = aws_byte_cursor_from_string(endpoint);\\\\\\\\n\\\\\\\\n    tls_connection_options.server_name = aws_string_new_from_cursor(allocator, &endpoint_cursor);\\\\\\\\n\\\\\\\\n    switch (tls_usage) {\\\\\\\\n        case AWS_S3_TLS_ENABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n            client_config.tls_connection_options = &tls_connection_options;\\\\\\\\n            break;\\\\\\\\n        case AWS_S3_TLS_DISABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_DISABLED;\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS | extra_meta_request_flag;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_get_object_meta_request(&tester, client, s3_path, flags, NULL));\\\\\\\\n\\\\\\\\n    aws_string_destroy(endpoint);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    aws_tls_ctx_release(context);\\\\\\\\n    aws_tls_connection_options_clean_up(&tls_connection_options);\\\\\\\\n    aws_tls_ctx_options_clean_up(&tls_context_options);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_disabled, s_test_s3_get_object_tls_disabled)\\\\\\\\nstatic int s_test_s3_get_object_tls_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_DISABLED, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_enabled, s_test_s3_get_object_tls_enabled)\\\\\\\\nstatic int s_test_s3_get_object_tls_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_ENABLED, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_default, s_test_s3_get_object_tls_default)\\\\\\\\nstatic int s_test_s3_get_object_tls_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_DEFAULT, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_no_signing, s_test_s3_no_signing)\\\\\\\\nstatic int s_test_s3_no_signing(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_signing_override, s_test_s3_signing_override)\\\\\\\\nstatic int s_test_s3_signing_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    /* Getting without signing should fail since the client has no signing set up. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request.*/\\\\\\\\n        struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request(&tester, client, &options, &meta_request_test_results, 0));\\\\\\\\n        ASSERT_TRUE(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0) != AWS_OP_SUCCESS);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Getting with signing should succeed if we set up signing on the meta request. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n        options.signing_config = &tester.default_signing_config;\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request. */\\\\\\\\n        struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n            &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_less_than_part_size, s_test_s3_get_object_less_than_part_size)\\\\\\\\nstatic int s_test_s3_get_object_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_get_object_meta_request(\\\\\\\\n        &tester, client, g_pre_existing_object_1MB, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_with_part_remainder, s_test_s3_put_object_with_part_remainder)\\\\\\\\nstatic int s_test_s3_put_object_with_part_remainder(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Object size meant to be one megabyte larger than the part size of the client. */\\\\\\\\n                .object_size_mb = 6,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multiple, s_test_s3_get_object_multiple)\\\\\\\\nstatic int s_test_s3_get_object_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_requests[4];\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results[4];\\\\\\\\n    size_t num_meta_requests = AWS_ARRAY_SIZE(meta_requests);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(num_meta_requests == AWS_ARRAY_SIZE(meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        /* Put together a simple S3 Get Object request. */\\\\\\\\n        struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n            allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results[i], allocator);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results[i]));\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request. */\\\\\\\\n        meta_requests[i] = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_requests[i] != NULL);\\\\\\\\n\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        meta_requests[i] = aws_s3_meta_request_release(meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        aws_s3_tester_validate_get_object_results(&meta_request_test_results[i], 0);\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multiple_serial, s_test_s3_get_object_multiple_serial)\\\\\\\\nstatic int s_test_s3_get_object_multiple_serial(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-10MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < 4; ++i) {\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Sleep for some time to wait for the cleanup task to run */\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(7, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    /* BEGIN CRITICAL SECTION */\\\\\\\\n    aws_s3_client_lock_synced_data(client);\\\\\\\\n\\\\\\\\n    AWS_ASSERT(client->synced_data.num_endpoints_allocated == 0);\\\\\\\\n\\\\\\\\n    aws_s3_client_unlock_synced_data(client);\\\\\\\\n    /* END CRITICAL SECTION */\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path, s_test_s3_get_object_file_path)\\\\\\\\nstatic int s_test_s3_get_object_file_path(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_create_new, s_test_s3_get_object_file_path_create_new)\\\\\\\\nstatic int s_test_s3_get_object_file_path_create_new(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_CREATE_NEW,\\\\\\\\n                .pre_exist_file_length = 10,\\\\\\\\n                .recv_file_delete_on_failure = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_RECV_FILE_ALREADY_EXISTS, aws_last_error());\\\\\\\\n\\\\\\\\n    /* The request failed without invoking the finish callback. Reset the finish and shutdown count */\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_shutdown_count);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n    tester.synced_data.desired_meta_request_shutdown_count = 0;\\\\\\\\n    tester.synced_data.desired_meta_request_finish_count = 0;\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    get_options.validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS;\\\\\\\\n    get_options.get_options.pre_exist_file_length = 0;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_append, s_test_s3_get_object_file_path_append)\\\\\\\\nstatic int s_test_s3_get_object_file_path_append(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    uint64_t pre_exist_file_length = 10;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_CREATE_OR_APPEND,\\\\\\\\n                .pre_exist_file_length = pre_exist_file_length,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(pre_exist_file_length + MB_TO_BYTES(1), meta_request_test_results.received_file_size);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), meta_request_test_results.progress.total_bytes_transferred);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_to_position, s_test_s3_get_object_file_path_to_position)\\\\\\\\nstatic int s_test_s3_get_object_file_path_to_position(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    uint64_t pre_exist_file_length = 10;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_WRITE_TO_POSITION,\\\\\\\\n                .pre_exist_file_length = 0,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_RECV_FILE_NOT_FOUND, aws_last_error());\\\\\\\\n\\\\\\\\n    /* The request failed without invoking the finish callback. Reset the finish and shutdown count */\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_shutdown_count);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n    tester.synced_data.desired_meta_request_shutdown_count = 0;\\\\\\\\n    tester.synced_data.desired_meta_request_finish_count = 0;\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    get_options.validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS;\\\\\\\\n    get_options.get_options.pre_exist_file_length = pre_exist_file_length;\\\\\\\\n    get_options.get_options.recv_file_position = 20;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(\\\\\\\\n        get_options.get_options.recv_file_position + MB_TO_BYTES(1), meta_request_test_results.received_file_size);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), meta_request_test_results.progress.total_bytes_transferred);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_empty_object, s_test_s3_get_object_empty_default)\\\\\\\\nstatic int s_test_s3_get_object_empty_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    return (s_test_s3_get_object_helper(allocator, AWS_S3_TLS_ENABLED, 0, g_pre_existing_empty_object));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_sse_kms, s_test_s3_get_object_sse_kms)\\\\\\\\nstatic int s_test_s3_get_object_sse_kms(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Keep TLS enabled for SSE related download, or it will fail. */\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, AWS_S3_TESTER_SEND_META_REQUEST_SSE_KMS, g_pre_existing_object_kms_10MB);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_sse_aes256, s_test_s3_get_object_sse_aes256)\\\\\\\\nstatic int s_test_s3_get_object_sse_aes256(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Keep TLS enabled for SSE related download, or it will fail. */\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, AWS_S3_TESTER_SEND_META_REQUEST_SSE_AES256, g_pre_existing_object_aes256_10MB);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Assert that GetObject can download an object whose body is XML identical to an \\\\\\\\\\\\\"async error\\\\\\\\\\\\\" aka \\\\\\\\\\\\\"200 error\\\\\\\\\\\\\":\\\\\\\\n * <?xml version=\\\\\\\\\\\\\"1.0\\\\\\\\\\\\\" encoding=\\\\\\\\\\\\\"UTF-8\\\\\\\\\\\\\"?>\\\\\\\\\\\\\\\\n<Error><Code>InternalError</Code>... */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_looks_like_async_error_xml, s_test_s3_get_object_looks_like_async_error_xml)\\\\\\\\nstatic int s_test_s3_get_object_looks_like_async_error_xml(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, 0 /*extra_meta_request_flag*/, g_pre_existing_object_async_error_xml);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Same as above, but send the \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\" via AWS_S3_META_REQUEST_TYPE_DEFAULT\\\\\\\\n * (instead of the typical AWS_S3_META_REQUEST_TYPE_GET_OBJECT) */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_default_get_object_looks_like_async_error_xml,\\\\\\\\n    s_test_s3_default_get_object_looks_like_async_error_xml)\\\\\\\\nstatic int s_test_s3_default_get_object_looks_like_async_error_xml(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_async_error_xml,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test read-backpressure functionality by repeatedly:\\\\\\\\n * - letting the download stall\\\\\\\\n * - incrementing the read window\\\\\\\\n * - repeat...\\\\\\\\n */\\\\\\\\nstatic int s_apply_backpressure_until_meta_request_finish(\\\\\\\\n    struct aws_s3_tester *tester,\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results,\\\\\\\\n    size_t part_size,\\\\\\\\n    size_t window_initial_size,\\\\\\\\n    uint64_t window_increment_size) {\\\\\\\\n\\\\\\\\n    /* Remember the last time something happened (we received download data, or incremented read window) */\\\\\\\\n    uint64_t last_time_something_happened;\\\\\\\\n    ASSERT_SUCCESS(aws_sys_clock_get_ticks(&last_time_something_happened));\\\\\\\\n\\\\\\\\n    /* To ensure that backpressure is working, we wait a bit after download stalls\\\\\\\\n     * before incrementing the read window again.\\\\\\\\n     * This number also controls the max time we wait for bytes to start arriving\\\\\\\\n     * after incrementing the window.\\\\\\\\n     * If the magic number is too high the test will be slow,\\\\\\\\n     * if it\\'s too low the test will fail on slow networks */\\\\\\\\n    const uint64_t wait_duration_with_nothing_happening =\\\\\\\\n        aws_timestamp_convert(3, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL);\\\\\\\\n\\\\\\\\n    uint64_t accumulated_window_increments = window_initial_size;\\\\\\\\n    uint64_t accumulated_data_size = 0;\\\\\\\\n\\\\\\\\n    while (true) {\\\\\\\\n        /* Check if meta-request is done (don\\'t exit yet, we want to check some numbers first...) */\\\\\\\\n        aws_s3_tester_lock_synced_data(tester);\\\\\\\\n        bool done = tester->synced_data.meta_requests_finished != 0;\\\\\\\\n        aws_s3_tester_unlock_synced_data(tester);\\\\\\\\n\\\\\\\\n        /* Check how much data we\\'ve received */\\\\\\\\n        size_t received_body_size_delta = aws_atomic_exchange_int(&test_results->received_body_size_delta, 0);\\\\\\\\n        accumulated_data_size += (uint64_t)received_body_size_delta;\\\\\\\\n\\\\\\\\n        /* Check that we haven\\'t received more data than the window allows.\\\\\\\\n         * TODO: Stop allowing \\\\\\\\\\\\\"hacky wiggle room\\\\\\\\\\\\\". The current implementation\\\\\\\\n         *       may push more bytes to the user (up to 1 part) than they\\'ve asked for. */\\\\\\\\n        uint64_t hacky_wiggle_room = part_size;\\\\\\\\n        uint64_t max_data_allowed = accumulated_window_increments + hacky_wiggle_room;\\\\\\\\n        ASSERT_TRUE(accumulated_data_size <= max_data_allowed, \\\\\\\\\\\\\"Received more data than the read window allows\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        /* If we\\'re done, we\\'re done */\\\\\\\\n        if (done) {\\\\\\\\n            break;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Figure out how long it\\'s been since we last received data */\\\\\\\\n        uint64_t current_time;\\\\\\\\n        ASSERT_SUCCESS(aws_sys_clock_get_ticks(&current_time));\\\\\\\\n\\\\\\\\n        if (received_body_size_delta != 0) {\\\\\\\\n            last_time_something_happened = current_time;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        uint64_t duration_since_something_happened = current_time - last_time_something_happened;\\\\\\\\n\\\\\\\\n        /* If it seems like data has stopped flowing... */\\\\\\\\n        if (duration_since_something_happened >= wait_duration_with_nothing_happening) {\\\\\\\\n\\\\\\\\n            /* Assert that data stopped flowing because the window reached 0. */\\\\\\\\n            uint64_t current_window = aws_sub_u64_saturating(accumulated_window_increments, accumulated_data_size);\\\\\\\\n            ASSERT_INT_EQUALS(0, current_window, \\\\\\\\\\\\\"Data stopped flowing but read window isn\\'t 0 yet.\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n            /* Open the window a bit (this resets the \\\\\\\\\\\\\"something happened\\\\\\\\\\\\\" timer */\\\\\\\\n            accumulated_window_increments += window_increment_size;\\\\\\\\n            aws_s3_meta_request_increment_read_window(meta_request, window_increment_size);\\\\\\\\n\\\\\\\\n            last_time_something_happened = current_time;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Sleep a moment, and loop again... */\\\\\\\\n        aws_thread_current_sleep(aws_timestamp_convert(100, AWS_TIMESTAMP_MILLIS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_get_object_backpressure_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    size_t part_size,\\\\\\\\n    size_t window_initial_size,\\\\\\\\n    uint64_t window_increment_size,\\\\\\\\n    bool file_on_disk) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = part_size,\\\\\\\\n        .enable_read_backpressure = true,\\\\\\\\n        .initial_read_window = window_initial_size,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options = {\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .message = message,\\\\\\\\n    };\\\\\\\\n    struct aws_string *filepath_str = NULL;\\\\\\\\n    if (file_on_disk) {\\\\\\\\n        filepath_str = aws_s3_tester_create_file(allocator, g_pre_existing_object_1MB, NULL);\\\\\\\\n        options.recv_filepath = aws_byte_cursor_from_string(filepath_str);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Increment read window bit by bit until all data is downloaded */\\\\\\\\n    ASSERT_SUCCESS(s_apply_backpressure_until_meta_request_finish(\\\\\\\\n        &tester, meta_request, &meta_request_test_results, part_size, window_initial_size, window_increment_size));\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    /* Regression test:\\\\\\\\n     * Ensure that it\\'s safe to call increment-window even after the meta-request has finished */\\\\\\\\n    aws_s3_meta_request_increment_read_window(meta_request, 1024);\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    if (filepath_str) {\\\\\\\\n        aws_file_delete(filepath_str);\\\\\\\\n        aws_string_destroy(filepath_str);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_small_increments, s_test_s3_get_object_backpressure_small_increments)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_small_increments(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments smaller than part-size.\\\\\\\\n     * Only 1 part at a time should be in flight */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_big_increments, s_test_s3_get_object_backpressure_big_increments)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_big_increments(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments larger than part-size.\\\\\\\\n     * Multiple parts should be in flight at a time */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 8;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size * 3;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_initial_size_zero, s_test_s3_get_object_backpressure_initial_size_zero)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_initial_size_zero(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test with initial window size of zero */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 0;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_small_increments_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_small_increments_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_small_increments_recv_filepath(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    /* Test increments smaller than part-size.\\\\\\\\n     * Only 1 part at a time should be in flight */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_big_increments_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_big_increments_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_big_increments_recv_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments larger than part-size.\\\\\\\\n     * Multiple parts should be in flight at a time */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 8;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size * 3;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_initial_size_zero_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_initial_size_zero_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_initial_size_zero_recv_filepath(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    /* Test with initial window size of zero */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 0;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_part, s_test_s3_get_object_part)\\\\\\\\nstatic int s_test_s3_get_object_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/get_object_part_test\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /* GET FILE */\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_NO_VALIDATE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .part_number = 2,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_SUCCESS, meta_request_test_results.finished_error_code);\\\\\\\\n    /* Only one request was made to get the second part of the object */\\\\\\\\n    ASSERT_UINT_EQUALS(1, aws_array_list_length(&meta_request_test_results.synced_data.metrics));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    enum aws_s3_client_tls_usage tls_usage,\\\\\\\\n    uint32_t extra_meta_request_flag) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_connection_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_connection_options);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    struct aws_tls_ctx_options tls_context_options;\\\\\\\\n    aws_tls_ctx_options_init_default_client(&tls_context_options, allocator);\\\\\\\\n\\\\\\\\n    struct aws_tls_ctx *context = aws_tls_client_ctx_new(allocator, &tls_context_options);\\\\\\\\n    aws_tls_connection_options_init_from_ctx(&tls_connection_options, context);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    struct aws_string *endpoint =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n    struct aws_byte_cursor endpoint_cursor = aws_byte_cursor_from_string(endpoint);\\\\\\\\n\\\\\\\\n    tls_connection_options.server_name = aws_string_new_from_cursor(allocator, &endpoint_cursor);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    switch (tls_usage) {\\\\\\\\n        case AWS_S3_TLS_ENABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n            client_config.tls_connection_options = &tls_connection_options;\\\\\\\\n            break;\\\\\\\\n        case AWS_S3_TLS_DISABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_DISABLED;\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_put_object_meta_request(\\\\\\\\n        &tester, client, 10, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS | extra_meta_request_flag, NULL));\\\\\\\\n\\\\\\\\n    aws_string_destroy(endpoint);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    aws_tls_ctx_release(context);\\\\\\\\n    aws_tls_connection_options_clean_up(&tls_connection_options);\\\\\\\\n    aws_tls_ctx_options_clean_up(&tls_context_options);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_disabled, s_test_s3_put_object_tls_disabled)\\\\\\\\nstatic int s_test_s3_put_object_tls_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DISABLED, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_enabled, s_test_s3_put_object_tls_enabled)\\\\\\\\nstatic int s_test_s3_put_object_tls_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_ENABLED, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_default, s_test_s3_put_object_tls_default)\\\\\\\\nstatic int s_test_s3_put_object_tls_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DEFAULT, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_put_object_with_acl, s_test_s3_multipart_put_object_with_acl)\\\\\\\\nstatic int s_test_s3_multipart_put_object_with_acl(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DEFAULT, AWS_S3_TESTER_SEND_META_REQUEST_PUT_ACL));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_multiple_helper(struct aws_allocator *allocator, bool file_on_disk) {\\\\\\\\n\\\\\\\\n    enum s_numbers { NUM_REQUESTS = 5 };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_requests[NUM_REQUESTS];\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results[NUM_REQUESTS];\\\\\\\\n    struct aws_http_message *messages[NUM_REQUESTS];\\\\\\\\n    struct aws_input_stream *input_streams[NUM_REQUESTS];\\\\\\\\n    struct aws_byte_buf input_stream_buffers[NUM_REQUESTS];\\\\\\\\n    struct aws_string *filepath_str[NUM_REQUESTS];\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    size_t content_length = MB_TO_BYTES(10);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results[i], allocator);\\\\\\\\n        char object_path_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n        snprintf(\\\\\\\\n            object_path_buffer,\\\\\\\\n            sizeof(object_path_buffer),\\\\\\\\n            \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-10MB-%zu.txt\\\\\\\\\\\\\",\\\\\\\\n            AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n            i);\\\\\\\\n        AWS_ZERO_STRUCT(input_stream_buffers[i]);\\\\\\\\n        aws_s3_create_test_buffer(allocator, content_length, &input_stream_buffers[i]);\\\\\\\\n        struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&input_stream_buffers[i]);\\\\\\\\n        input_streams[i] = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n        struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(object_path_buffer);\\\\\\\\n        struct aws_byte_cursor host_cur = aws_byte_cursor_from_string(host_name);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT;\\\\\\\\n        if (file_on_disk) {\\\\\\\\n            filepath_str[i] = aws_s3_tester_create_file(allocator, test_object_path, input_streams[i]);\\\\\\\\n            messages[i] = aws_s3_test_put_object_request_new_without_body(\\\\\\\\n                allocator, &host_cur, g_test_body_content_type, test_object_path, content_length, 0 /*flags*/);\\\\\\\\n            options.send_filepath = aws_byte_cursor_from_string(filepath_str[i]);\\\\\\\\n        } else {\\\\\\\\n            filepath_str[i] = NULL;\\\\\\\\n            messages[i] = aws_s3_test_put_object_request_new(\\\\\\\\n                allocator, &host_cur, test_object_path, g_test_body_content_type, input_streams[i], 0);\\\\\\\\n        }\\\\\\\\n        options.message = messages[i];\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results[i]));\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Put Object request. */\\\\\\\\n        meta_requests[i] = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_requests[i] != NULL);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        meta_requests[i] = aws_s3_meta_request_release(meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_s3_tester_validate_get_object_results(&meta_request_test_results[i], 0);\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_http_message_release(messages[i]);\\\\\\\\n        aws_input_stream_release(input_streams[i]);\\\\\\\\n        aws_byte_buf_clean_up(&input_stream_buffers[i]);\\\\\\\\n        if (filepath_str[i]) {\\\\\\\\n            ASSERT_SUCCESS(aws_file_delete(filepath_str[i]));\\\\\\\\n            aws_string_destroy(filepath_str[i]);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multiple, s_test_s3_put_object_multiple)\\\\\\\\nstatic int s_test_s3_put_object_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_put_object_multiple_helper(allocator, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multiple_with_filepath, s_test_s3_put_object_multiple_with_filepath)\\\\\\\\nstatic int s_test_s3_put_object_multiple_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_put_object_multiple_helper(allocator, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_less_than_part_size, s_test_s3_put_object_less_than_part_size)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_buffer_pool_trim, s_test_s3_put_object_buffer_pool_trim)\\\\\\\\nstatic int s_test_s3_put_object_buffer_pool_trim(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 8 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 32,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    struct aws_s3_buffer_pool_usage_stats usage_before = aws_s3_buffer_pool_get_usage(client->buffer_pool);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(0 != usage_before.primary_num_blocks);\\\\\\\\n\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(6, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    struct aws_s3_buffer_pool_usage_stats usage_after = aws_s3_buffer_pool_get_usage(client->buffer_pool);\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(0, usage_after.primary_num_blocks);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_less_than_part_size_with_content_encoding,\\\\\\\\n    s_test_s3_put_object_less_than_part_size_with_content_encoding)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size_with_content_encoding(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor content_encoding_cursor = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"gzip\\\\\\\\\\\\\");\\\\\\\\n    uint32_t object_size_mb = 1;\\\\\\\\n    char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n    snprintf(\\\\\\\\n        object_path_sprintf_buffer,\\\\\\\\n        sizeof(object_path_sprintf_buffer),\\\\\\\\n        \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-content-encoding-%uMB.txt\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n        object_size_mb);\\\\\\\\n    struct aws_byte_cursor object_path_cursor = aws_byte_cursor_from_c_str(object_path_sprintf_buffer);\\\\\\\\n\\\\\\\\n    /*** put file with encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_SHA256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path_cursor,\\\\\\\\n                .content_encoding = content_encoding_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** get file and validate encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results get_object_result;\\\\\\\\n    aws_s3_meta_request_test_results_init(&get_object_result, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &get_object_result));\\\\\\\\n    struct aws_byte_cursor content_encoding_header_cursor;\\\\\\\\n    ASSERT_SUCCESS(aws_http_headers_get(\\\\\\\\n        get_object_result.response_headers, g_content_encoding_header_name, &content_encoding_header_cursor));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq(&content_encoding_cursor, &content_encoding_header_cursor));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&get_object_result);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_mpu_with_content_encoding, s_test_s3_put_object_mpu_with_content_encoding)\\\\\\\\nstatic int s_test_s3_put_object_mpu_with_content_encoding(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor content_encoding_cursor = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"gzip\\\\\\\\\\\\\");\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n    char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n    snprintf(\\\\\\\\n        object_path_sprintf_buffer,\\\\\\\\n        sizeof(object_path_sprintf_buffer),\\\\\\\\n        \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-content-encoding-%uMB.txt\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n        object_size_mb);\\\\\\\\n    struct aws_byte_cursor object_path_cursor = aws_byte_cursor_from_c_str(object_path_sprintf_buffer);\\\\\\\\n\\\\\\\\n    /*** put file with encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_SHA256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path_cursor,\\\\\\\\n                .content_encoding = content_encoding_cursor,\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** get file and validate encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results get_object_result;\\\\\\\\n    aws_s3_meta_request_test_results_init(&get_object_result, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &get_object_result));\\\\\\\\n    struct aws_byte_cursor content_encoding_header_cursor;\\\\\\\\n    ASSERT_SUCCESS(aws_http_headers_get(\\\\\\\\n        get_object_result.response_headers, g_content_encoding_header_name, &content_encoding_header_cursor));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq(&content_encoding_cursor, &content_encoding_header_cursor));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&get_object_result);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multipart_threshold, s_test_s3_put_object_multipart_threshold)\\\\\\\\nstatic int s_test_s3_put_object_multipart_threshold(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n        .multipart_upload_threshold = MB_TO_BYTES(15),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    /* First smaller than the part size */\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 5,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a single part upload, and have 0 as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(0, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    /* Second smaller than threshold and larger than part size */\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    put_options.put_options.object_size_mb = 10;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a single part upload, and have 0 as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(0, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    /* Third larger than threshold*/\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    put_options.put_options.object_size_mb = 20;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in multi-part upload, and have the real part size */\\\\\\\\n    ASSERT_UINT_EQUALS(client_config.part_size, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_threshold_less_than_part_size,\\\\\\\\n    s_test_s3_put_object_multipart_threshold_less_than_part_size)\\\\\\\\nstatic int s_test_s3_put_object_multipart_threshold_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n        .multipart_upload_threshold = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    /* First smaller than the part size */\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 6,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a one part of multipart upload, and have the content length as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(put_options.put_options.object_size_mb), meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_empty_object, s_test_s3_put_object_empty_object)\\\\\\\\nstatic int s_test_s3_put_object_empty_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 0,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s3_no_content_length_test_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    uint32_t object_size_in_mb,\\\\\\\\n    bool use_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = use_checksum ? AWS_SCA_CRC32 : AWS_SCA_NONE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_in_mb,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_no_content_length, s_test_s3_put_object_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 19, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_single_part_no_content_length, s_test_s3_put_object_single_part_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_single_part_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 5, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_zero_size_no_content_length, s_test_s3_put_object_zero_size_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_zero_size_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 0, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_large_object_no_content_length_with_checksum,\\\\\\\\n    s_test_s3_put_large_object_no_content_length_with_checksum)\\\\\\\\nstatic int s_test_s3_put_large_object_no_content_length_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 128, true));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Once upon a time, we have a bug that without content-length, we will schedule more requests to prepare than needed.\\\\\\\\n * And those extra request will be cleaned up, however, the client level count of `num_requests_being_prepared` will\\\\\\\\n * still keep record for those.\\\\\\\\n *\\\\\\\\n * To reproduce, we create bunch of requests with less than a part body. And then sleep for a while to let dns resolve\\\\\\\\n * purge all records. (Otherwise, we will always have one valid request to be available to send.) to trigger not going\\\\\\\\n * full speed code. And we will hang.\\\\\\\\n *\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_no_content_length_multiple, s_test_s3_put_object_no_content_length_multiple)\\\\\\\\nstatic int s_test_s3_put_object_no_content_length_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    aws_s3_set_dns_ttl(55);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    for (int i = 0; i < 6; i++) {\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    }\\\\\\\\n    /* Sleep more than the DNS ttl to purge all records. */\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(60, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    /* After sleep for a while, make another meta request */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream when we\\'re not doing multipart upload */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_singlepart, s_test_s3_put_object_async_singlepart)\\\\\\\\nstatic int s_test_s3_put_object_async_singlepart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 4,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream in multipart upload */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_multipart, s_test_s3_put_object_async_multipart)\\\\\\\\nstatic int s_test_s3_put_object_async_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 16,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, but the aws_async_input_stream_read() calls all complete synchronously */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_read_completes_synchronously,\\\\\\\\n    s_test_s3_put_object_async_read_completes_synchronously)\\\\\\\\nstatic int s_test_s3_put_object_async_read_completes_synchronously(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .async_read_strategy = AWS_ASYNC_READ_COMPLETES_IMMEDIATELY,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, where it takes multiple read() calls to fill each part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_small_reads, s_test_s3_put_object_async_small_reads)\\\\\\\\nstatic int s_test_s3_put_object_async_small_reads(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .max_bytes_per_read = KB_TO_BYTES(1001), /* something that doesn\\'t evenly divide into 8MB parts */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test synchronous input-stream, where it takes multiple read() calls to fill each part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_small_reads, s_test_s3_put_object_small_reads)\\\\\\\\nstatic int s_test_s3_put_object_small_reads(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .max_bytes_per_read = KB_TO_BYTES(1001), /* something that doesn\\'t evenly divide into 8MB parts */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that doesn\\'t end exactly on a part boundary */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_no_content_length_partial_part,\\\\\\\\n    s_test_s3_put_object_async_no_content_length_partial_part)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_partial_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 3,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that fills exactly 1 part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_no_content_length_1part, s_test_s3_put_object_async_no_content_length_1part)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_1part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 8,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that doesn\\'t realize\\\\\\\\n * it\\'s at EOF until it tries to read the 2nd part and gets 0 bytes */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_no_content_length_empty_part2,\\\\\\\\n    s_test_s3_put_object_async_no_content_length_empty_part2)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_empty_part2(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 8,             /* read 1 part\\'s worth of data */\\\\\\\\n                .eof_requires_extra_read = true, /* don\\'t report EOF until it tries to read 2nd part */\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that fills multiple parts */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_no_content_length_2parts, s_test_s3_put_object_async_no_content_length_2parts)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_2parts(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 16,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_fail_reading, s_test_s3_put_object_async_fail_reading)\\\\\\\\nstatic int s_test_s3_put_object_async_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(AWS_IO_STREAM_READ_FAILED, test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_validate_if_none_match_failure_response(struct aws_s3_meta_request_test_results *test_results) {\\\\\\\\n\\\\\\\\n    /**\\\\\\\\n     * response body should be like:\\\\\\\\n     * <Error>\\\\\\\\n     * <Code>PreconditionFailed</Code>\\\\\\\\n     * <Message>At least one of the pre-conditions you specified did not hold</Message>\\\\\\\\n     * <Condition>If-None-Match</Condition>\\\\\\\\n     * <RequestId></RequestId>\\\\\\\\n     * <HostId></HostId>\\\\\\\\n     * </Error>\\\\\\\\n     */\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor xml_doc = aws_byte_cursor_from_buf(&test_results->error_response_body);\\\\\\\\n    struct aws_byte_cursor error_code_string = {0};\\\\\\\\n    struct aws_byte_cursor condition_string = {0};\\\\\\\\n\\\\\\\\n    const char *error_code_path[] = {\\\\\\\\\\\\\"Error\\\\\\\\\\\\\", \\\\\\\\\\\\\"Code\\\\\\\\\\\\\", NULL};\\\\\\\\n    ASSERT_SUCCESS(aws_xml_get_body_at_path(test_results->allocator, xml_doc, error_code_path, &error_code_string));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq_c_str(&error_code_string, \\\\\\\\\\\\\"PreconditionFailed\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    const char *condition_path[] = {\\\\\\\\\\\\\"Error\\\\\\\\\\\\\", \\\\\\\\\\\\\"Condition\\\\\\\\\\\\\", NULL};\\\\\\\\n    ASSERT_SUCCESS(aws_xml_get_body_at_path(test_results->allocator, xml_doc, condition_path, &condition_string));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq_c_str(&condition_string, \\\\\\\\\\\\\"If-None-Match\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_if_none_match, s_test_s3_put_object_if_none_match)\\\\\\\\nstatic int s_test_s3_put_object_if_none_match(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n    struct aws_byte_cursor if_none_match_all = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Use pre_exist object so that the request should fail with the expected failure message. */\\\\\\\\n                .object_path_override = g_pre_existing_object_1MB,\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .if_none_match_header = if_none_match_all,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_HTTP_STATUS_CODE_412_PRECONDITION_FAILED, test_results.finished_response_status);\\\\\\\\n    ASSERT_SUCCESS(s_test_validate_if_none_match_failure_response(&test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_mpu_if_none_match, s_test_s3_put_object_mpu_if_none_match)\\\\\\\\nstatic int s_test_s3_put_object_mpu_if_none_match(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n    struct aws_byte_cursor if_none_match_all = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Use pre_exist object so that the request should fail with the expected failure message. */\\\\\\\\n                .object_path_override = g_pre_existing_object_10MB,\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .if_none_match_header = if_none_match_all,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /** Complete MPU can fail with 200 error */\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        AWS_HTTP_STATUS_CODE_412_PRECONDITION_FAILED == test_results.finished_response_status ||\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK == test_results.finished_response_status);\\\\\\\\n    ASSERT_SUCCESS(s_test_validate_if_none_match_failure_response(&test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_kms, s_test_s3_put_object_sse_kms)\\\\\\\\nstatic int s_test_s3_put_object_sse_kms(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_kms_multipart, s_test_s3_put_object_sse_kms_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_kms_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_aes256, s_test_s3_put_object_sse_aes256)\\\\\\\\nstatic int s_test_s3_put_object_sse_aes256(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_aes256_multipart, s_test_s3_put_object_sse_aes256_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_aes256_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_c_aes256_multipart, s_test_s3_put_object_sse_c_aes256_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_c_aes256_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    (void)allocator;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        tester.allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_sse_c.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_C_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_sse_c_aes256_multipart_with_checksum,\\\\\\\\n    s_test_s3_put_object_sse_c_aes256_multipart_with_checksum)\\\\\\\\nstatic int s_test_s3_put_object_sse_c_aes256_multipart_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        tester.allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_sse_c_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_C_AES256,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_content_md5_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    bool multipart_upload,\\\\\\\\n    uint32_t flags,\\\\\\\\n    enum aws_s3_meta_request_compute_content_md5 compute_content_md5) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    size_t part_size = 5 * 1024 * 1024;\\\\\\\\n    if (!multipart_upload) {\\\\\\\\n        /* content_length < part_size */\\\\\\\\n        part_size = 15 * 1024 * 1024;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = part_size,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    client_config.compute_content_md5 = compute_content_md5;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_put_object_meta_request(&tester, client, 10, flags, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_no_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_no_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_no_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_no_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_no_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_no_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_correct_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_correct_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_correct_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_correct_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_correct_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_correct_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_incorrect_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_incorrect_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_incorrect_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_incorrect_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_incorrect_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_incorrect_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_no_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_no_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_no_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_no_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_no_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_no_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_correct_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_correct_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_correct_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_correct_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_correct_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_correct_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_incorrect_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_incorrect_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_incorrect_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_incorrect_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_incorrect_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_incorrect_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_upload_part_message_helper(struct aws_allocator *allocator, bool should_compute_content_md5) {\\\\\\\\n\\\\\\\\n    aws_s3_library_init(allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n    /* base64 encoded md5 of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */\\\\\\\\n    struct aws_byte_cursor expected_content_md5 = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"+y3U+EY5uFXhVVmRoiJWyA==\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    uint32_t part_number = 1;\\\\\\\\n    struct aws_string *upload_id = aws_string_new_from_c_str(allocator, \\\\\\\\\\\\\"dummy_upload_id\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message = aws_s3_upload_part_message_new(\\\\\\\\n        allocator, base_message, &test_buffer, part_number, upload_id, should_compute_content_md5, NULL, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    if (should_compute_content_md5) {\\\\\\\\n        ASSERT_TRUE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n        struct aws_byte_cursor content_md5;\\\\\\\\n        aws_http_headers_get(new_headers, g_content_md5_header_name, &content_md5);\\\\\\\\n        ASSERT_BIN_ARRAYS_EQUALS(expected_content_md5.ptr, expected_content_md5.len, content_md5.ptr, content_md5.len);\\\\\\\\n    } else {\\\\\\\\n        ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(upload_id);\\\\\\\\n    upload_id = NULL;\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    aws_s3_library_clean_up();\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_part_message_with_content_md5, s_test_s3_upload_part_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_upload_part_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_upload_part_message_helper(allocator, true));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_part_message_without_content_md5, s_test_s3_upload_part_message_without_content_md5)\\\\\\\\nstatic int s_test_s3_upload_part_message_without_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_upload_part_message_helper(allocator, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_create_multipart_upload_message_with_content_md5,\\\\\\\\n    s_test_s3_create_multipart_upload_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_create_multipart_upload_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_md5_header = {\\\\\\\\n        .name = g_content_md5_header_name,\\\\\\\\n        .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_content_md5\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_http_message_add_header(base_message, content_md5_header));\\\\\\\\n\\\\\\\\n    struct aws_http_headers *base_headers = aws_http_message_get_headers(base_message);\\\\\\\\n    ASSERT_TRUE(aws_http_headers_has(base_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message = aws_s3_create_multipart_upload_message_new(allocator, base_message, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_complete_multipart_message_with_content_md5,\\\\\\\\n    s_test_s3_complete_multipart_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_complete_multipart_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_md5_header = {\\\\\\\\n        .name = g_content_md5_header_name,\\\\\\\\n        .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_content_md5\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_http_message_add_header(base_message, content_md5_header));\\\\\\\\n\\\\\\\\n    struct aws_http_headers *base_headers = aws_http_message_get_headers(base_message);\\\\\\\\n    ASSERT_TRUE(aws_http_headers_has(base_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf body_buffer;\\\\\\\\n    aws_byte_buf_init(&body_buffer, allocator, 512);\\\\\\\\n\\\\\\\\n    struct aws_string *upload_id = aws_string_new_from_c_str(allocator, \\\\\\\\\\\\\"dummy_upload_id\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_array_list parts;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_init_dynamic(&parts, allocator, 0, sizeof(struct aws_s3_mpu_part_info *)));\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message =\\\\\\\\n        aws_s3_complete_multipart_message_new(allocator, base_message, &body_buffer, upload_id, &parts, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_array_list_clean_up(&parts);\\\\\\\\n\\\\\\\\n    aws_string_destroy(upload_id);\\\\\\\\n    upload_id = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&body_buffer);\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_double_slashes, s_test_s3_put_object_double_slashes)\\\\\\\\nstatic int s_test_s3_put_object_double_slashes(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix//test.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip, s_test_s3_round_trip)\\\\\\\\nstatic int s_test_s3_round_trip(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get, s_test_s3_round_trip_default_get)\\\\\\\\nstatic int s_test_s3_round_trip_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_default.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_validate_headers_checksum_set(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)headers;\\\\\\\\n    struct aws_s3_meta_request_test_results *meta_request_test_results =\\\\\\\\n        (struct aws_s3_meta_request_test_results *)user_data;\\\\\\\\n    ASSERT_NOT_NULL(meta_request->meta_request_level_running_response_sum);\\\\\\\\n    ASSERT_INT_EQUALS(\\\\\\\\n        meta_request->meta_request_level_running_response_sum->algorithm, meta_request_test_results->algorithm);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_validate_headers_checksum_unset(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)user_data;\\\\\\\\n    ASSERT_NULL(meta_request->meta_request_level_running_response_sum);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nvoid s_s3_test_validate_checksum(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *result,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    struct aws_s3_meta_request_test_results *meta_request_test_results =\\\\\\\\n        (struct aws_s3_meta_request_test_results *)user_data;\\\\\\\\n    AWS_FATAL_ASSERT(result->did_validate);\\\\\\\\n    AWS_FATAL_ASSERT(result->validation_algorithm == meta_request_test_results->algorithm);\\\\\\\\n    AWS_FATAL_ASSERT(result->error_code == AWS_OP_SUCCESS);\\\\\\\\n}\\\\\\\\nvoid s_s3_test_no_validate_checksum(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *result,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)user_data;\\\\\\\\n    AWS_FATAL_ASSERT(!result->did_validate);\\\\\\\\n    AWS_FATAL_ASSERT(result->error_code == AWS_OP_SUCCESS);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* TODO: maybe refactor the fc -> flexible checksum tests to be less copy/paste */\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header,\\\\\\\\n    uint32_t object_size_mb,\\\\\\\\n    enum aws_s3_tester_full_object_checksum full_object_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_ARRAY_SIZE(s_checksum_algo_priority_list); i++) {\\\\\\\\n        enum aws_s3_checksum_algorithm algorithm = s_checksum_algo_priority_list[i];\\\\\\\\n        char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n        snprintf(\\\\\\\\n            object_path_sprintf_buffer,\\\\\\\\n            sizeof(object_path_sprintf_buffer),\\\\\\\\n            \\\\\\\\\\\\\"/prefix/round_trip/test_default_fc_%d_%d.txt\\\\\\\\\\\\\",\\\\\\\\n            algorithm,\\\\\\\\n            object_size_mb);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n            allocator, &path_buf, aws_byte_cursor_from_c_str(object_path_sprintf_buffer)));\\\\\\\\n        struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n        /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n        struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n            .client = client,\\\\\\\\n            .checksum_algorithm = algorithm,\\\\\\\\n            .validate_get_response_checksum = false,\\\\\\\\n            .checksum_via_header = via_header,\\\\\\\\n            .put_options =\\\\\\\\n                {\\\\\\\\n                    .object_size_mb = object_size_mb,\\\\\\\\n                    .object_path_override = object_path,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n        if (algorithm != AWS_SCA_SHA1 && algorithm != AWS_SCA_SHA256) {\\\\\\\\n            /* Full object checksums doesn\\'t support SHA. */\\\\\\\\n            put_options.put_options.full_object_checksum = full_object_checksum;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n        /*** GET FILE ***/\\\\\\\\n\\\\\\\\n        struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .client = client,\\\\\\\\n            .expected_validate_checksum_alg = algorithm,\\\\\\\\n            .validate_get_response_checksum = true,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = object_path,\\\\\\\\n                },\\\\\\\\n            .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n            .headers_callback = s_s3_validate_headers_checksum_set,\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n        aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get_fc, s_test_s3_round_trip_default_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 1 /*object_size_mb*/, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_empty_fc, s_test_s3_round_trip_empty_fc)\\\\\\\\nstatic int s_test_s3_round_trip_empty_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 0, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get_fc_header, s_test_s3_round_trip_default_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, true, 1, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_default_get_full_object_checksum_fc,\\\\\\\\n    s_test_s3_round_trip_default_get_full_object_checksum_fc)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_full_object_checksum_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 1, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc_helper(struct aws_allocator *allocator, void *ctx, bool via_header) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC64NVME,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC64NVME,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .headers_callback = s_s3_validate_headers_checksum_set,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_multipart_get_fc, s_test_s3_round_trip_multipart_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_multipart_get_fc_helper(allocator, ctx, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_multipart_get_fc_header, s_test_s3_round_trip_multipart_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_multipart_get_fc_helper(allocator, ctx, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test the multipart uploaded object was downloaded with same part size, which will download the object matches all the\\\\\\\\n * parts and validate the parts checksum. */\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header,\\\\\\\\n    enum aws_s3_tester_full_object_checksum full_object_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n    struct aws_byte_cursor object_name;\\\\\\\\n    /* Use different name to avoid collision when tests run concurrently. */\\\\\\\\n    switch (full_object_checksum) {\\\\\\\\n        case AWS_TEST_FOC_CALLBACK:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc_full_object_via_callback.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n        case AWS_TEST_FOC_HEADER:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc_full_object_via_header.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(allocator, &path_buf, object_name));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .full_object_checksum = full_object_checksum,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_multipart_get_fc, s_test_s3_round_trip_mpu_multipart_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_multipart_get_fc_header, s_test_s3_round_trip_mpu_multipart_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, true, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, true, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_CALLBACK);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/empty-file-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 0,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE WITH GET_FIRST_PART ***/\\\\\\\\n    uint64_t small_object_size_hint = 1;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .object_size_hint =\\\\\\\\n            &small_object_size_hint /* pass a object_size_hint > 0 so that the request goes through the getPart flow */,\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE WITH HEAD_OBJECT ***/\\\\\\\\n    get_options.object_size_hint = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_empty_file_with_checksum, s_test_s3_download_empty_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_download_empty_file_with_checksum_helper(allocator, ctx, false);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(test_s3_download_empty_file_with_checksum_header, s_test_s3_download_empty_file_with_checksum_header)\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_download_empty_file_with_checksum_helper(allocator, ctx, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_single_part_file_with_checksum, s_test_s3_download_single_part_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_single_part_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(10),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/single-part-10Mb-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    uint64_t object_size_hint = MB_TO_BYTES(object_size_mb);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .object_size_hint = &object_size_hint,\\\\\\\\n    };\\\\\\\\n    uint64_t small_object_size_hint = MB_TO_BYTES(1);\\\\\\\\n\\\\\\\\n    /* will do headRequest */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(20);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n\\\\\\\\n    /* will do getPart */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /* will do getPart */\\\\\\\\n    /*** GET FILE with part_size = file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(10);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < file_size and wrong object_size_hint ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.object_size_hint = &small_object_size_hint;\\\\\\\\n    /* will do getPart first, cancel it and then rangedGet */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_multipart_file_with_checksum, s_test_s3_download_multipart_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_multipart_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/multipart-10Mb-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    uint64_t object_size_hint = MB_TO_BYTES(object_size_mb);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .object_size_hint = &object_size_hint,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* will do HeadRequest first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(7);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    /* will do HeadObject first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size = first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(5);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    /* will do HeadObject First */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    uint64_t small_object_size_hint = 1;\\\\\\\\n\\\\\\\\n    /*** GET FILE with with wrong object_size_hint ***/\\\\\\\\n    get_options.object_size_hint = &small_object_size_hint;\\\\\\\\n    get_options.finish_callback = NULL;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < first_part_size***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n\\\\\\\\n    /* will do GetPart, cancel the request and then do ranged Gets. */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(7);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n\\\\\\\\n    /* will do GetPart first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size = first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(5);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    /* will do GetPart first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > fileSize ***/\\\\\\\\n    /* TODO: Enable this test once the checksum issue is resolved. Currently, when the S3 GetObject API is called with\\\\\\\\n     * the range 0-contentLength, it returns a checksum of checksums without the -numParts portion. This leads to a\\\\\\\\n     * checksum mismatch error, as it is incorrectly validated as a part checksum. */\\\\\\\\n    /*\\\\\\\\n    client_options.part_size = MB_TO_BYTES(20);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n    */\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_array_list response_checksum_list;\\\\\\\\n    /* Check for all algorithm but the CRC32 */\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_array_list_init_dynamic(&response_checksum_list, allocator, 4, sizeof(enum aws_s3_checksum_algorithm)));\\\\\\\\n    enum aws_s3_checksum_algorithm alg = AWS_SCA_CRC32C;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    alg = AWS_SCA_SHA1;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    alg = AWS_SCA_SHA256;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .validate_checksum_algorithms = &response_checksum_list,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_no_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    /* Push all the algorithms to the list for validation, now we should have the checksum validated. */\\\\\\\\n    alg = AWS_SCA_CRC32;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_array_list_clean_up(&response_checksum_list);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_default_get_fc, s_test_s3_round_trip_mpu_default_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_default_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_default_get_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_no_validate_checksum,\\\\\\\\n        .headers_callback = s_s3_validate_headers_checksum_unset,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor key,\\\\\\\\n    int object_size_mb,\\\\\\\\n    bool unknown_content_length) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(allocator, &path_buf, key));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .skip_content_length = unknown_content_length,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(\\\\\\\\n        MB_TO_BYTES(put_options.put_options.object_size_mb), test_results.progress.total_bytes_transferred);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_with_filepath, s_test_s3_round_trip_with_filepath)\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath\\\\\\\\\\\\\"), 1, false /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_with_filepath, s_test_s3_round_trip_mpu_with_filepath)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_mpu\\\\\\\\\\\\\"),\\\\\\\\n        50,\\\\\\\\n        false /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_with_filepath_no_content_length, s_test_s3_round_trip_with_filepath_no_content_length)\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_no_content_length\\\\\\\\\\\\\"),\\\\\\\\n        1,\\\\\\\\n        true /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_with_filepath_no_content_length,\\\\\\\\n    s_test_s3_round_trip_mpu_with_filepath_no_content_length)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_with_filepath_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_mpu_no_content_length\\\\\\\\\\\\\"),\\\\\\\\n        50,\\\\\\\\n        true /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_chunked_then_unchunked, s_test_s3_chunked_then_unchunked)\\\\\\\\nstatic int s_test_s3_chunked_then_unchunked(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Test to see if signed_body_value modified when signing chunked request */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/chunked_unchunked/test_chunked.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor chunked_object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options chunked_put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = chunked_object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &chunked_put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/chunked_unchunked/test_unchunked.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor unchunked_object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options unchunked_put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_NONE,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = unchunked_object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &unchunked_put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_meta_request_default, s_test_s3_meta_request_default)\\\\\\\\nstatic int s_test_s3_meta_request_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n\\\\\\\\n    /* Pass the request through as a default request so that it goes through as-is. */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    /* Check the size of the metrics should be the same as the number of\\\\\\\\n    requests, which should be 1 */\\\\\\\\n    ASSERT_UINT_EQUALS(1, aws_array_list_length(&meta_request_test_results.synced_data.metrics));\\\\\\\\n    struct aws_s3_request_metrics *metrics = NULL;\\\\\\\\n    aws_array_list_back(&meta_request_test_results.synced_data.metrics, (void **)&metrics);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_error_missing_file, s_test_s3_error_missing_file)\\\\\\\\nstatic int s_test_s3_error_missing_file(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor test_object_path =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/non-existing-file12345.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message =\\\\\\\\n        aws_s3_test_get_object_request_new(allocator, aws_byte_cursor_from_string(host_name), test_object_path);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_response_status == 404);\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.error_response_headers != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_NOT_NULL(meta_request_test_results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(meta_request_test_results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(meta_request_test_results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_test_s3_existing_host_entry_address_resolved_callback(\\\\\\\\n    struct aws_host_resolver *resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    int err_code,\\\\\\\\n    const struct aws_array_list *host_addresses,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)err_code;\\\\\\\\n    (void)host_addresses;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = user_data;\\\\\\\\n    AWS_ASSERT(tester);\\\\\\\\n    aws_s3_tester_notify_signal(tester);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_existing_host_entry, s_test_s3_existing_host_entry)\\\\\\\\nstatic int s_test_s3_existing_host_entry(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_host_resolution_config host_resolver_config;\\\\\\\\n        AWS_ZERO_STRUCT(host_resolver_config);\\\\\\\\n        host_resolver_config.impl = aws_default_dns_resolve;\\\\\\\\n        host_resolver_config.max_ttl = 30;\\\\\\\\n        host_resolver_config.impl_data = NULL;\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_host_resolver_resolve_host(\\\\\\\\n            client_config.client_bootstrap->host_resolver,\\\\\\\\n            host_name,\\\\\\\\n            s_test_s3_existing_host_entry_address_resolved_callback,\\\\\\\\n            &host_resolver_config,\\\\\\\\n            &tester));\\\\\\\\n\\\\\\\\n        aws_s3_tester_wait_for_signal(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_bad_endpoint, s_test_s3_bad_endpoint)\\\\\\\\nstatic int s_test_s3_bad_endpoint(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"test_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    AWS_STATIC_STRING_FROM_LITERAL(invalid_host_name, \\\\\\\\\\\\\"invalid_host_name_totally_absolutely\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Construct a message that points to an invalid host name. Key can be anything. */\\\\\\\\n    struct aws_http_message *message =\\\\\\\\n        aws_s3_test_get_object_request_new(allocator, aws_byte_cursor_from_string(invalid_host_name), test_key);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(&tester, client, &options, &meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        meta_request_test_results.finished_error_code == AWS_IO_DNS_INVALID_NAME ||\\\\\\\\n        meta_request_test_results.finished_error_code == AWS_IO_DNS_QUERY_FAILED);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_raise_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_body_callback_raise_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)body;\\\\\\\\n    (void)range_start;\\\\\\\\n    (void)user_data;\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_fail_headers_callback, s_test_s3_put_object_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_put_object_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_fail_body_callback, s_test_s3_put_object_fail_body_callback)\\\\\\\\nstatic int s_test_s3_put_object_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n\\\\\\\\n        /* Put object currently never invokes the body callback, which means it should not fail. */\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, NULL));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_fail_headers_callback, s_test_s3_get_object_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_get_object_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_fail_body_callback, s_test_s3_get_object_fail_body_callback)\\\\\\\\nstatic int s_test_s3_get_object_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_headers_callback, s_test_s3_default_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_default_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_atomic_var s_test_headers_callback_invoked;\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_check_returns_success(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    /* increments counter to check if callback was invoked exactly once */\\\\\\\\n    aws_atomic_fetch_add(&s_test_headers_callback_invoked, 1);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_check_returns_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    /* increments counter to check if callback was invoked exactly once */\\\\\\\\n    aws_atomic_fetch_add(&s_test_headers_callback_invoked, 1);\\\\\\\\n\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_invoke_headers_callback_on_error, s_test_s3_default_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_default_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_default_invoke_headers_callback_cancels_on_error,\\\\\\\\n    s_test_s3_default_invoke_headers_callback_cancels_on_error)\\\\\\\\nstatic int s_test_s3_default_invoke_headers_callback_cancels_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_invoke_headers_callback_on_error,\\\\\\\\n    s_test_s3_get_object_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_get_object_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_invoke_headers_callback_on_error,\\\\\\\\n    s_test_s3_put_object_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_put_object_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .invalid_request = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INVALID_RESPONSE_STATUS, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation,\\\\\\\\n    s_test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation)\\\\\\\\nstatic int s_test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_UNKNOWN, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_body_callback, s_test_s3_default_fail_body_callback)\\\\\\\\nstatic int s_test_s3_default_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that if a DEFAULt meta-request sets the operation_name, and gets an error response,\\\\\\\\n * then aws_s3_meta_request_result.error_response_operation_name is set. */\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_operation_name, s_test_s3_default_fail_operation_name)\\\\\\\\nstatic int s_test_s3_default_fail_operation_name(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\", aws_string_c_str(meta_request_test_results.error_response_operation_name));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_invalid_request, s_test_s3_put_fail_object_invalid_request)\\\\\\\\nstatic int s_test_s3_put_fail_object_invalid_request(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .invalid_request = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INVALID_RESPONSE_STATUS, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    /* Since 1MB is under part_size, there will be a single PutObject request */\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"PutObject\\\\\\\\\\\\\", aws_string_c_str(meta_request_test_results.error_response_operation_name));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that we fail to create a metarequest when an invalid `send_filepath` is passed in */\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_invalid_send_filepath, s_test_s3_put_fail_object_invalid_send_filepath)\\\\\\\\nstatic int s_test_s3_put_fail_object_invalid_send_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor object_key = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = aws_s3_test_put_object_request_new_without_body(\\\\\\\\n        allocator, &host_name, g_test_body_content_type, object_key, 1024 /*content_length*/, 0 /*flags*/);\\\\\\\\n    ASSERT_NOT_NULL(message);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options meta_request_options = {\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .message = message,\\\\\\\\n        .send_filepath = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"obviously_invalid_file_path\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &meta_request_options);\\\\\\\\n    ASSERT_NULL(meta_request);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_ERROR_FILE_INVALID_PATH, aws_last_error());\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the parallel read stream failed to send read the second part. */\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_bad_parallel_read_stream, s_test_s3_put_fail_object_bad_parallel_read_stream)\\\\\\\\nstatic int s_test_s3_put_fail_object_bad_parallel_read_stream(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    /* Override the parallel input stream new function to create a bad parallel input stream */\\\\\\\\n    client->vtable->parallel_input_stream_new_from_file = aws_parallel_input_stream_new_from_file_failure_tester;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 100,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_UNIMPLEMENTED, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_single_part_fail_object_inputstream_fail_reading,\\\\\\\\n    s_test_s3_put_single_part_fail_object_inputstream_fail_reading)\\\\\\\\nstatic int s_test_s3_put_single_part_fail_object_inputstream_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n                .content_length = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_single_part_fail_object_inputstream_mismatch_content_length,\\\\\\\\n    s_test_s3_put_single_part_fail_object_inputstream_mismatch_content_length)\\\\\\\\nstatic int s_test_s3_put_single_part_fail_object_inputstream_mismatch_content_length(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .content_length = MB_TO_BYTES(2),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_inputstream_fail_reading, s_test_s3_put_fail_object_inputstream_fail_reading)\\\\\\\\nstatic int s_test_s3_put_fail_object_inputstream_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n                .content_length = 10 * 1024 * 1024,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_IO_STREAM_READ_FAILED, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_fail_object_inputstream_mismatch_content_length,\\\\\\\\n    s_test_s3_put_fail_object_inputstream_mismatch_content_length)\\\\\\\\nstatic int s_test_s3_put_fail_object_inputstream_mismatch_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = false,\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .content_length = 10 * 1024 * 1024,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INCORRECT_CONTENT_LENGTH, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_clamp_part_size, s_test_s3_put_object_clamp_part_size)\\\\\\\\nstatic int s_test_s3_put_object_clamp_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n        .max_part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client_config.part_size < g_s3_min_upload_part_size);\\\\\\\\n    ASSERT_TRUE(client_config.max_part_size < g_s3_min_upload_part_size);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    /* Upload should now succeed even when specifying a smaller than allowed part size. */\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(test_results.part_size == g_s3_min_upload_part_size);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_get_expected_user_agent(struct aws_allocator *allocator, struct aws_byte_buf *dest) {\\\\\\\\n    AWS_ASSERT(allocator);\\\\\\\\n    AWS_ASSERT(dest);\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor forward_slash = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/\\\\\\\\\\\\\");\\\\\\\\n    const struct aws_byte_cursor single_space = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\" \\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_init(dest, allocator, 32));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_product_name));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &forward_slash));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_s3_client_version));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &single_space));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_platform));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &forward_slash));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_unknown));\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_add_user_agent_header, s_test_add_user_agent_header)\\\\\\\\nstatic int s_test_add_user_agent_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor single_space = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\" \\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_buf expected_user_agent_value_buf;\\\\\\\\n    s_get_expected_user_agent(allocator, &expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor expected_user_agent_value = aws_byte_cursor_from_buf(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_byte_cursor user_agent_value;\\\\\\\\n        AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n\\\\\\\\n        struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n\\\\\\\\n        aws_s3_add_user_agent_header(allocator, message);\\\\\\\\n\\\\\\\\n        struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(headers != NULL);\\\\\\\\n        ASSERT_SUCCESS(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value));\\\\\\\\n        ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n            user_agent_value.ptr, user_agent_value.len, expected_user_agent_value.ptr, expected_user_agent_value.len);\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        const struct aws_byte_cursor dummy_agent_header_value =\\\\\\\\n            AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_user_agent_product/dummy_user_agent_value\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        struct aws_byte_buf total_expected_user_agent_value_buf;\\\\\\\\n        aws_byte_buf_init(&total_expected_user_agent_value_buf, allocator, 64);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &dummy_agent_header_value);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &single_space);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &expected_user_agent_value);\\\\\\\\n\\\\\\\\n        struct aws_byte_cursor total_expected_user_agent_value =\\\\\\\\n            aws_byte_cursor_from_buf(&total_expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n        struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n        struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n        ASSERT_TRUE(headers != NULL);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_http_headers_add(headers, g_user_agent_header_name, dummy_agent_header_value));\\\\\\\\n\\\\\\\\n        aws_s3_add_user_agent_header(allocator, message);\\\\\\\\n\\\\\\\\n        {\\\\\\\\n            struct aws_byte_cursor user_agent_value;\\\\\\\\n            AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n            ASSERT_SUCCESS(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value));\\\\\\\\n            ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n                user_agent_value.ptr,\\\\\\\\n                user_agent_value.len,\\\\\\\\n                total_expected_user_agent_value.ptr,\\\\\\\\n                total_expected_user_agent_value.len);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_byte_buf_clean_up(&total_expected_user_agent_value_buf);\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&expected_user_agent_value_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_user_agent_meta_request_finished_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *results = meta_request->user_data;\\\\\\\\n    AWS_ASSERT(results != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = results->tester;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf expected_user_agent_value_buf;\\\\\\\\n    s_get_expected_user_agent(meta_request->allocator, &expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor expected_user_agent_value = aws_byte_cursor_from_buf(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = request->send_data.message;\\\\\\\\n    struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor user_agent_value;\\\\\\\\n    AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n\\\\\\\\n    AWS_FATAL_ASSERT(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value) == AWS_OP_SUCCESS);\\\\\\\\n    AWS_FATAL_ASSERT(aws_byte_cursor_eq(&user_agent_value, &expected_user_agent_value));\\\\\\\\n    aws_byte_buf_clean_up(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *original_meta_request_vtable =\\\\\\\\n        aws_s3_tester_get_meta_request_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    original_meta_request_vtable->finished_request(meta_request, request, error_code);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_s3_meta_request *s_s3_meta_request_factory_override_finished_request(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    const struct aws_s3_meta_request_options *options) {\\\\\\\\n    AWS_ASSERT(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = client->shutdown_callback_user_data;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *original_client_vtable =\\\\\\\\n        aws_s3_tester_get_client_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = original_client_vtable->meta_request_factory(client, options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *patched_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(tester, meta_request, NULL);\\\\\\\\n    patched_meta_request_vtable->finished_request = s_s3_test_user_agent_meta_request_finished_request;\\\\\\\\n\\\\\\\\n    return meta_request;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_test_sending_user_agent_create_client(struct aws_s3_tester *tester, struct aws_s3_client **client) {\\\\\\\\n    AWS_ASSERT(tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(tester, &client_options, client));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(tester, *client, NULL);\\\\\\\\n    patched_client_vtable->meta_request_factory = s_s3_meta_request_factory_override_finished_request;\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_auto_ranged_get_sending_user_agent, s_test_s3_auto_ranged_get_sending_user_agent)\\\\\\\\nstatic int s_test_s3_auto_ranged_get_sending_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = g_pre_existing_object_1MB,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_auto_ranged_put_sending_user_agent, s_test_s3_auto_ranged_put_sending_user_agent)\\\\\\\\nstatic int s_test_s3_auto_ranged_put_sending_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .put_options =\\\\\\\\n                {\\\\\\\\n                    .ensure_multipart = true,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_sending_meta_request_user_agent, s_test_s3_default_sending_meta_request_user_agent)\\\\\\\\nstatic int s_test_s3_default_sending_meta_request_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .default_type_options =\\\\\\\\n                {\\\\\\\\n                    .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                    .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n                },\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = g_pre_existing_object_1MB,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct range_requests_test_user_data {\\\\\\\\n    struct aws_http_headers *headers;\\\\\\\\n    struct aws_byte_buf *body_buffer;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic int s_range_requests_headers_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)response_status;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results = user_data;\\\\\\\\n    struct range_requests_test_user_data *test_user_data = test_results->tester->user_data;\\\\\\\\n\\\\\\\\n    if (test_user_data != NULL) {\\\\\\\\n        copy_http_headers(headers, test_user_data->headers);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_range_requests_receive_body_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)range_start;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results = user_data;\\\\\\\\n    struct range_requests_test_user_data *test_user_data = test_results->tester->user_data;\\\\\\\\n\\\\\\\\n    aws_byte_buf_append_dynamic(test_user_data->body_buffer, body);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_range_requests, s_test_s3_range_requests)\\\\\\\\nstatic int s_test_s3_range_requests(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor object_names[] = {\\\\\\\\n        g_pre_existing_object_1MB,\\\\\\\\n        g_pre_existing_object_kms_10MB,\\\\\\\\n        g_pre_existing_object_aes256_10MB,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    enum aws_s3_tester_sse_type object_sse_types[] = {\\\\\\\\n        AWS_S3_TESTER_SSE_NONE,\\\\\\\\n        AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        AWS_S3_TESTER_SSE_AES256,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor ranges[] = {\\\\\\\\n        // No range at all.\\\\\\\\n        {0, NULL},\\\\\\\\n\\\\\\\\n        // Single byte range.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=8-8\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Single byte range (first byte).\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-0\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // First 8K.  8K < client\\'s 16K part size.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-8191\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // First 0.5 MB.  0.5 MB < 1 MB test file.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-524287\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // 0.5 MB - 2 MB range.  This overlaps and goes beyond the 1 MB test file size.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=524288-2097151\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Get everything after the first 0.5 MB\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=524288-\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Last 0.5 MB\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=-524288\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Everything after first 8K\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=8192-\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Last 8K\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=-8192\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* List of headers that should have matching values between the auto_ranged_get and default (which sends the HTTP\\\\\\\\n     * request as-is to S3) meta request.*/\\\\\\\\n    const struct aws_byte_cursor headers_that_should_match[] = {\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"ETag\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Accept-Ranges\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Range\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Type\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Length\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Server\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"x-amz-server-side-encryption\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"x-amz-server-side-encryption-aws-kms-key\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* List of headers that are okay to be in the auto_ranged_get response and not in the default response, or vice\\\\\\\\n     * versa.*/\\\\\\\\n    const struct aws_byte_cursor headers_to_ignore[] = {\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Connection\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    const size_t num_object_names = AWS_ARRAY_SIZE(object_names);\\\\\\\\n    const size_t num_ranges = AWS_ARRAY_SIZE(ranges);\\\\\\\\n\\\\\\\\n    for (size_t object_name_index = 0; object_name_index < num_object_names; ++object_name_index) {\\\\\\\\n        for (size_t range_index = 0; range_index < num_ranges; ++range_index) {\\\\\\\\n\\\\\\\\n            AWS_LOGF_INFO(\\\\\\\\n                AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Testing object name %d and range %d\\\\\\\\\\\\\", (int)object_name_index, (int)range_index);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf range_get_buffer;\\\\\\\\n            aws_byte_buf_init(&range_get_buffer, allocator, 256);\\\\\\\\n            struct aws_http_headers *range_get_headers = aws_http_headers_new(allocator);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf verify_range_get_buffer;\\\\\\\\n            aws_byte_buf_init(&verify_range_get_buffer, allocator, 256);\\\\\\\\n            struct aws_http_headers *verify_range_get_headers = aws_http_headers_new(allocator);\\\\\\\\n\\\\\\\\n            struct aws_s3_tester_meta_request_options options = {\\\\\\\\n                .allocator = allocator,\\\\\\\\n                .client = client,\\\\\\\\n                .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n                .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n                .headers_callback = s_range_requests_headers_callback,\\\\\\\\n                .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n                .get_options =\\\\\\\\n                    {\\\\\\\\n                        .object_path = object_names[object_name_index],\\\\\\\\n                        .object_range = ranges[range_index],\\\\\\\\n                    },\\\\\\\\n                .sse_type = object_sse_types[object_name_index],\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            {\\\\\\\\n                struct range_requests_test_user_data test_user_data = {\\\\\\\\n                    .headers = range_get_headers,\\\\\\\\n                    .body_buffer = &range_get_buffer,\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                tester.user_data = &test_user_data;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            /* Send a default meta request (which just pushes the request directly to S3) with the same options to\\\\\\\\n             * verify the format of each request. */\\\\\\\\n            struct aws_s3_tester_meta_request_options verify_options = {\\\\\\\\n                .allocator = allocator,\\\\\\\\n                .client = client,\\\\\\\\n                .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n                .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n                .headers_callback = s_range_requests_headers_callback,\\\\\\\\n                .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n                .default_type_options =\\\\\\\\n                    {\\\\\\\\n                        .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                        .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n                    },\\\\\\\\n                .get_options =\\\\\\\\n                    {\\\\\\\\n                        .object_path = object_names[object_name_index],\\\\\\\\n                        .object_range = ranges[range_index],\\\\\\\\n                    },\\\\\\\\n                .sse_type = object_sse_types[object_name_index],\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            {\\\\\\\\n                struct range_requests_test_user_data test_user_data = {\\\\\\\\n                    .headers = verify_range_get_headers,\\\\\\\\n                    .body_buffer = &verify_range_get_buffer,\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                tester.user_data = &test_user_data;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &verify_options, NULL));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            /* Compare headers. */\\\\\\\\n            for (size_t i = 0; i < aws_http_headers_count(verify_range_get_headers); ++i) {\\\\\\\\n                struct aws_http_header verify_header;\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get_index(verify_range_get_headers, i, &verify_header));\\\\\\\\n\\\\\\\\n                bool ignore_header = false;\\\\\\\\n\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_to_ignore); ++j) {\\\\\\\\n                    if (aws_byte_cursor_eq_ignore_case(&headers_to_ignore[j], &verify_header.name)) {\\\\\\\\n                        ignore_header = true;\\\\\\\\n                        break;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                if (ignore_header) {\\\\\\\\n                    aws_http_headers_erase(range_get_headers, verify_header.name);\\\\\\\\n                    continue;\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                AWS_LOGF_INFO(\\\\\\\\n                    AWS_LS_S3_GENERAL,\\\\\\\\n                    \\\\\\\\\\\\\"%d,%d Checking for header \\\\\\\\\\\\\" PRInSTR,\\\\\\\\n                    (int)object_name_index,\\\\\\\\n                    (int)range_index,\\\\\\\\n                    AWS_BYTE_CURSOR_PRI(verify_header.name));\\\\\\\\n\\\\\\\\n                struct aws_byte_cursor header_value;\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get(range_get_headers, verify_header.name, &header_value));\\\\\\\\n\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_that_should_match); ++j) {\\\\\\\\n                    if (!aws_byte_cursor_eq_ignore_case(&headers_that_should_match[j], &verify_header.name)) {\\\\\\\\n                        continue;\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    AWS_LOGF_INFO(\\\\\\\\n                        AWS_LS_S3_GENERAL,\\\\\\\\n                        \\\\\\\\\\\\\"%d,%d Header Contents \\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\" vs \\\\\\\\\\\\\" PRInSTR,\\\\\\\\n                        (int)object_name_index,\\\\\\\\n                        (int)range_index,\\\\\\\\n                        AWS_BYTE_CURSOR_PRI(verify_header.value),\\\\\\\\n                        AWS_BYTE_CURSOR_PRI(header_value));\\\\\\\\n\\\\\\\\n                    ASSERT_TRUE(aws_byte_cursor_eq(&verify_header.value, &header_value));\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_erase(range_get_headers, verify_header.name));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            for (size_t i = 0; i < aws_http_headers_count(range_get_headers); ++i) {\\\\\\\\n                struct aws_http_header header;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get_index(range_get_headers, i, &header));\\\\\\\\n                bool ignore_header = false;\\\\\\\\n\\\\\\\\n                /* If the ignore header doesn\\'t exist in the verify_range_get_headers, ignore it here. */\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_to_ignore); ++j) {\\\\\\\\n                    if (aws_byte_cursor_eq_ignore_case(&headers_to_ignore[j], &header.name)) {\\\\\\\\n                        ignore_header = true;\\\\\\\\n                        break;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                if (ignore_header) {\\\\\\\\n                    ASSERT_SUCCESS(aws_http_headers_erase(range_get_headers, header.name));\\\\\\\\n                    continue;\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                AWS_LOGF_INFO(AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Left over header: \\\\\\\\\\\\\" PRInSTR, AWS_BYTE_CURSOR_PRI(header.name));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(aws_http_headers_count(range_get_headers) == 0);\\\\\\\\n\\\\\\\\n            /* Compare Body Contents */\\\\\\\\n            ASSERT_TRUE(aws_byte_buf_eq(&range_get_buffer, &verify_range_get_buffer));\\\\\\\\n\\\\\\\\n            aws_http_headers_release(range_get_headers);\\\\\\\\n            aws_byte_buf_clean_up(&range_get_buffer);\\\\\\\\n\\\\\\\\n            aws_http_headers_release(verify_range_get_headers);\\\\\\\\n            aws_byte_buf_clean_up(&verify_range_get_buffer);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_not_satisfiable_range, s_test_s3_not_satisfiable_range)\\\\\\\\nstatic int s_test_s3_not_satisfiable_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .headers_callback = s_range_requests_headers_callback,\\\\\\\\n        .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=2097151-\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_416_REQUESTED_RANGE_NOT_SATISFIABLE, results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_invalid_start_range_greator_than_end_range, s_test_s3_invalid_start_range_greator_than_end_range)\\\\\\\\nstatic int s_test_s3_invalid_start_range_greator_than_end_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=20-10\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n    ASSERT_INT_EQUALS(results.finished_error_code, AWS_ERROR_S3_INVALID_RANGE_HEADER);\\\\\\\\n    ASSERT_INT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_invalid_empty_file_with_range, s_test_s3_invalid_empty_file_with_range)\\\\\\\\nstatic int s_test_s3_invalid_empty_file_with_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_empty_object,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-0\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_416_REQUESTED_RANGE_NOT_SATISFIABLE, results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_copy_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor source_key,\\\\\\\\n    struct aws_byte_cursor destination_key,\\\\\\\\n    int expected_error_code,\\\\\\\\n    int expected_response_status,\\\\\\\\n    uint64_t expected_size) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    struct aws_byte_buf encoded_path;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n    AWS_ZERO_STRUCT(encoded_path);\\\\\\\\n\\\\\\\\n    aws_byte_buf_init(&encoded_path, allocator, source_key.len);\\\\\\\\n    aws_byte_buf_append_encoding_uri_path(&encoded_path, &source_key);\\\\\\\\n\\\\\\\\n    /* without copy_source_uri */\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    /* with path style copy_source_uri */\\\\\\\\n    char source_url[1024];\\\\\\\\n    snprintf(\\\\\\\\n        source_url,\\\\\\\\n        sizeof(source_url),\\\\\\\\n        \\\\\\\\\\\\\"https://s3.%s.amazonaws.com/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"\\\\\\\\\\\\\",\\\\\\\\n        g_test_s3_region.ptr,\\\\\\\\n        AWS_BYTE_CURSOR_PRI(source_bucket),\\\\\\\\n        AWS_BYTE_BUF_PRI(encoded_path));\\\\\\\\n    copy_source_uri = aws_byte_cursor_from_c_str(source_url);\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    /* with virtual style copy_source_uri */\\\\\\\\n    snprintf(\\\\\\\\n        source_url,\\\\\\\\n        sizeof(source_url),\\\\\\\\n        \\\\\\\\\\\\\"https://\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\".s3.%s.amazonaws.com/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(source_bucket),\\\\\\\\n        g_test_s3_region.ptr,\\\\\\\\n        AWS_BYTE_BUF_PRI(encoded_path));\\\\\\\\n    copy_source_uri = aws_byte_cursor_from_c_str(source_url);\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_byte_buf_clean_up(&encoded_path);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_small_object, s_test_s3_copy_small_object)\\\\\\\\nstatic int s_test_s3_copy_small_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, MB_TO_BYTES(1));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_small_object_special_char, s_test_s3_copy_small_object_special_char)\\\\\\\\nstatic int s_test_s3_copy_small_object_special_char(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB-@\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB_@\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, MB_TO_BYTES(1));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_copy_large_object_special_char, s_test_s3_multipart_copy_large_object_special_char)\\\\\\\\nstatic int s_test_s3_multipart_copy_large_object_special_char(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-2GB-@\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_2GB-@\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, GB_TO_BYTES(2));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_copy_large_object, s_test_s3_multipart_copy_large_object)\\\\\\\\nstatic int s_test_s3_multipart_copy_large_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-2GB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_2GB\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, GB_TO_BYTES(2));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_object_invalid_source_key, s_test_s3_copy_object_invalid_source_key)\\\\\\\\nstatic int s_test_s3_copy_object_invalid_source_key(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"__INVALID__\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/__INVALID__\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        source_key,\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_S3_INVALID_RESPONSE_STATUS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_404_NOT_FOUND,\\\\\\\\n        0 /* expected_size is ignored */);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test a bypass Copy Object meta request using a slash prefix in the x_amz_copy_source header.\\\\\\\\n * S3 supports both bucket/key and /bucket/key\\\\\\\\n * This test validates the fix for the bug described in https://sim.amazon.com/issues/AWSCRT-730\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_copy_source_prefixed_by_slash, s_test_s3_copy_source_prefixed_by_slash)\\\\\\\\nstatic int s_test_s3_copy_source_prefixed_by_slash(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK,\\\\\\\\n        MB_TO_BYTES(1),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_invalid_source_uri, s_test_s3_copy_invalid_source_uri)\\\\\\\\nstatic int s_test_s3_copy_invalid_source_uri(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"http://invalid-uri.com:80:80/path\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_MALFORMED_INPUT_STRING,\\\\\\\\n        0,\\\\\\\\n        MB_TO_BYTES(1),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test multipart Copy Object meta request using a slash prefix in the x_amz_copy_source header.\\\\\\\\n * S3 supports both bucket/key and /bucket/key\\\\\\\\n * This test validates the fix for the bug described in https://sim.amazon.com/issues/AWSCRT-730\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_copy_source_prefixed_by_slash_multipart, s_test_s3_copy_source_prefixed_by_slash_multipart)\\\\\\\\nstatic int s_test_s3_copy_source_prefixed_by_slash_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-256MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_256MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK,\\\\\\\\n        MB_TO_BYTES(256),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_get_object_mrap_helper(struct aws_allocator *allocator, bool multipart) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_signing_config_aws signing_config = tester.default_signing_config;\\\\\\\\n    /* Use Sigv4A for signing */\\\\\\\\n    signing_config.algorithm = AWS_SIGNING_ALGORITHM_V4_ASYMMETRIC;\\\\\\\\n    /* Use * for region to sign */\\\\\\\\n    signing_config.region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = multipart ? 64 * 1024 : 20 * 1024 * 1024,\\\\\\\\n        .region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\"),\\\\\\\\n        .signing_config = &signing_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0 /*flag*/));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .mrap_test = true,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test single-part get object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_less_than_part_size_mrap, s_test_s3_get_object_less_than_part_size_mrap)\\\\\\\\nstatic int s_test_s3_get_object_less_than_part_size_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_get_object_mrap_helper(allocator, false /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test multi-part get object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multipart_mrap, s_test_s3_get_object_multipart_mrap)\\\\\\\\nstatic int s_test_s3_get_object_multipart_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_get_object_mrap_helper(allocator, true /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_put_object_mrap_helper(struct aws_allocator *allocator, bool multipart) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_signing_config_aws signing_config = tester.default_signing_config;\\\\\\\\n    /* Use Sigv4A for signing */\\\\\\\\n    signing_config.algorithm = AWS_SIGNING_ALGORITHM_V4_ASYMMETRIC;\\\\\\\\n    /* Use * for region to sign */\\\\\\\\n    signing_config.region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n        .region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\"),\\\\\\\\n        .signing_config = &signing_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0 /*flag*/));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .mrap_test = true,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = multipart ? 10 : 1,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test single-part put object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_less_than_part_size_mrap, s_test_s3_put_object_less_than_part_size_mrap)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_put_object_mrap_helper(allocator, false /*multipart*/);\\\\\\\\n}\\\\\\\\n/* Test multi-part put object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multipart_mrap, s_test_s3_put_object_multipart_mrap)\\\\\\\\nstatic int s_test_s3_put_object_multipart_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_put_object_mrap_helper(allocator, true /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_http_message *s_put_object_request_new(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor key,\\\\\\\\n    struct aws_byte_cursor endpoint,\\\\\\\\n    struct aws_input_stream *body_stream,\\\\\\\\n    uint64_t content_length) {\\\\\\\\n\\\\\\\\n    AWS_PRECONDITION(allocator);\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n\\\\\\\\n    if (message == NULL) {\\\\\\\\n        return NULL;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if (aws_http_message_set_request_path(message, key)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_http_header host_header = {\\\\\\\\n        .name = g_host_header_name,\\\\\\\\n        .value = endpoint,\\\\\\\\n    };\\\\\\\\n    if (aws_http_message_add_header(message, host_header)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    char content_length_c_str[1024];\\\\\\\\n    snprintf(content_length_c_str, sizeof(content_length_c_str), \\\\\\\\\\\\\"%\\\\\\\\\\\\\" PRIu64, content_length);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_length_header = {\\\\\\\\n        .name = g_content_length_header_name,\\\\\\\\n        .value = aws_byte_cursor_from_c_str(content_length_c_str),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    if (aws_http_message_add_header(message, content_length_header)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if (aws_http_message_set_request_method(message, aws_http_method_put)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_set_body_stream(message, body_stream);\\\\\\\\n\\\\\\\\n    return message;\\\\\\\\n\\\\\\\\nerror_clean_up_message:\\\\\\\\n\\\\\\\\n    if (message != NULL) {\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n        message = NULL;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return NULL;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct put_object_pause_resume_test_data {\\\\\\\\n    struct aws_mutex mutex;\\\\\\\\n    struct aws_condition_variable c_var;\\\\\\\\n\\\\\\\\n    /* execution of the test meta request completed */\\\\\\\\n    bool execution_completed;\\\\\\\\n\\\\\\\\n    /* accumulator of amount of bytes uploaded */\\\\\\\\n    struct aws_atomic_var total_bytes_uploaded;\\\\\\\\n\\\\\\\\n    /* the offset where upload should be paused */\\\\\\\\n    struct aws_atomic_var request_pause_offset;\\\\\\\\n\\\\\\\\n    struct aws_atomic_var pause_requested;\\\\\\\\n\\\\\\\\n    struct aws_atomic_var pause_result;\\\\\\\\n\\\\\\\\n    /* the persistable state of the paused request */\\\\\\\\n    struct aws_atomic_var persistable_state_ptr;\\\\\\\\n\\\\\\\\n    int meta_request_error_code;\\\\\\\\n    int response_status_code;\\\\\\\\n\\\\\\\\n    /* (Optional) content_length to send. If not set, use the length of the input stream. */\\\\\\\\n    uint64_t content_length;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic void s_put_pause_resume_meta_request_finish(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *meta_request_result,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    struct aws_s3_tester *tester = user_data;\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = tester->user_data;\\\\\\\\n\\\\\\\\n    /* if error response body is available, dump it to test result to help investigation of failed tests */\\\\\\\\n    if (meta_request_result->error_response_body != NULL && meta_request_result->error_response_body->len > 0) {\\\\\\\\n        AWS_LOGF_ERROR(\\\\\\\\n            AWS_LS_S3_GENERAL,\\\\\\\\n            \\\\\\\\\\\\\"Response error body: %.*s\\\\\\\\\\\\\",\\\\\\\\n            (int)meta_request_result->error_response_body->len,\\\\\\\\n            meta_request_result->error_response_body->buffer);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_mutex_lock(&test_data->mutex);\\\\\\\\n    test_data->meta_request_error_code = meta_request_result->error_code;\\\\\\\\n    test_data->response_status_code = meta_request_result->response_status;\\\\\\\\n    test_data->execution_completed = true;\\\\\\\\n    aws_mutex_unlock(&test_data->mutex);\\\\\\\\n    aws_condition_variable_notify_one(&test_data->c_var);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic bool s_put_pause_resume_test_completion_predicate(void *arg) {\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = arg;\\\\\\\\n    return test_data->execution_completed;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Patched version of aws_s3_meta_request_vtable->finished_request() for pause/resume tests.\\\\\\\\n * It can pause the meta-request immediately after a part completes.\\\\\\\\n * We use a patched vtable, instead of the progress_callback, because\\\\\\\\n * the progress_callback fires on another thread, which might be too late to\\\\\\\\n * prevent more parts from being sent. */\\\\\\\\nstatic void s_meta_request_finished_request_patched_for_pause_resume_tests(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    struct aws_s3_tester *tester = meta_request->user_data;\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = tester->user_data;\\\\\\\\n    AWS_ASSERT(test_data);\\\\\\\\n\\\\\\\\n    if ((error_code == AWS_ERROR_SUCCESS) && (meta_request->type == AWS_S3_META_REQUEST_TYPE_PUT_OBJECT) &&\\\\\\\\n        (request->request_tag == AWS_S3_AUTO_RANGED_PUT_REQUEST_TAG_PART)) {\\\\\\\\n\\\\\\\\n        if (!request->is_noop) {\\\\\\\\n            /* If the request is noop, we are not really uploading the part */\\\\\\\\n            aws_atomic_fetch_add(&test_data->total_bytes_uploaded, request->request_body.len);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        size_t total_bytes_uploaded = aws_atomic_load_int(&test_data->total_bytes_uploaded);\\\\\\\\n        uint64_t offset_to_pause = aws_atomic_load_int(&test_data->request_pause_offset);\\\\\\\\n\\\\\\\\n        if (total_bytes_uploaded >= offset_to_pause) {\\\\\\\\n            /* offset of the upload at which we should pause was reached. let\\'s pause the upload */\\\\\\\\n            /* if the meta request has already been paused previously, do nothing. */\\\\\\\\n            size_t expected = false;\\\\\\\\n            bool request_pause = aws_atomic_compare_exchange_int(&test_data->pause_requested, &expected, true);\\\\\\\\n            if (request_pause) {\\\\\\\\n                struct aws_s3_meta_request_resume_token *resume_token = NULL;\\\\\\\\n                int pause_result = aws_s3_meta_request_pause(meta_request, &resume_token);\\\\\\\\n                struct aws_byte_cursor upload_id = aws_s3_meta_request_resume_token_upload_id(resume_token);\\\\\\\\n                /* Make Sure we have upload ID */\\\\\\\\n                AWS_FATAL_ASSERT(aws_byte_cursor_eq_c_str(&upload_id, \\\\\\\\\\\\\"\\\\\\\\\\\\\") == false);\\\\\\\\n                aws_atomic_store_int(&test_data->pause_result, pause_result);\\\\\\\\n                aws_atomic_store_ptr(&test_data->persistable_state_ptr, resume_token);\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Continue with original vtable function... */\\\\\\\\n    struct aws_s3_meta_request_vtable *original_meta_request_vtable =\\\\\\\\n        aws_s3_tester_get_meta_request_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    original_meta_request_vtable->finished_request(meta_request, request, error_code);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_s3_meta_request *s_meta_request_factory_patch_for_pause_resume_tests(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    const struct aws_s3_meta_request_options *options) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(client != NULL);\\\\\\\\n    struct aws_s3_tester *tester = client->shutdown_callback_user_data;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *original_client_vtable =\\\\\\\\n        aws_s3_tester_get_client_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = original_client_vtable->meta_request_factory(client, options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *patched_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(tester, meta_request, NULL);\\\\\\\\n    patched_meta_request_vtable->finished_request = s_meta_request_finished_request_patched_for_pause_resume_tests;\\\\\\\\n\\\\\\\\n    return meta_request;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* total length of the object to simulate for upload */\\\\\\\\nstatic const size_t s_pause_resume_object_length_128MB = 128 * 1024 * 1024;\\\\\\\\n\\\\\\\\n/* this runs when a RESUMED upload is about to successfully complete */\\\\\\\\nstatic int s_pause_resume_upload_review_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_upload_review *review,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)user_data;\\\\\\\\n    struct aws_allocator *allocator = meta_request->allocator;\\\\\\\\n\\\\\\\\n    /* A bit hacky, but stream the same data that the test always uploads, and ensure the checksums match */\\\\\\\\n\\\\\\\\n    struct aws_input_stream *reread_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    for (size_t part_index = 0; part_index < review->part_count; ++part_index) {\\\\\\\\n        const struct aws_s3_upload_part_review *part_review = &review->part_array[part_index];\\\\\\\\n        struct aws_byte_buf reread_part_buf;\\\\\\\\n        ASSERT_TRUE(part_review->size <= SIZE_MAX);\\\\\\\\n        aws_byte_buf_init(&reread_part_buf, allocator, (size_t)part_review->size);\\\\\\\\n        ASSERT_SUCCESS(aws_input_stream_read(reread_stream, &reread_part_buf));\\\\\\\\n\\\\\\\\n        /* part sizes should match */\\\\\\\\n        ASSERT_UINT_EQUALS(part_review->size, reread_part_buf.len);\\\\\\\\n\\\\\\\\n        if (review->checksum_algorithm != AWS_SCA_NONE) {\\\\\\\\n            struct aws_byte_cursor reread_part_cursor = aws_byte_cursor_from_buf(&reread_part_buf);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf checksum_buf;\\\\\\\\n            aws_byte_buf_init(&checksum_buf, allocator, 128);\\\\\\\\n            ASSERT_SUCCESS(\\\\\\\\n                aws_checksum_compute(allocator, review->checksum_algorithm, &reread_part_cursor, &checksum_buf));\\\\\\\\n            struct aws_byte_cursor checksum_cursor = aws_byte_cursor_from_buf(&checksum_buf);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf encoded_checksum_buf;\\\\\\\\n            aws_byte_buf_init(&encoded_checksum_buf, allocator, 128);\\\\\\\\n\\\\\\\\n            ASSERT_SUCCESS(aws_base64_encode(&checksum_cursor, &encoded_checksum_buf));\\\\\\\\n\\\\\\\\n            /* part checksums should match */\\\\\\\\n            ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n                encoded_checksum_buf.buffer,\\\\\\\\n                encoded_checksum_buf.len,\\\\\\\\n                part_review->checksum.ptr,\\\\\\\\n                part_review->checksum.len);\\\\\\\\n\\\\\\\\n            aws_byte_buf_clean_up(&checksum_buf);\\\\\\\\n            aws_byte_buf_clean_up(&encoded_checksum_buf);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_byte_buf_clean_up(&reread_part_buf);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_input_stream_release(reread_stream);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_pause_resume_receive_body_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)range_start;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    // TODO: this is a bit hacky, as it will try to compare every partial get result we receive to the input stream.\\\\\\\\n    // Something better?\\\\\\\\n\\\\\\\\n    struct aws_input_stream *input_stream =\\\\\\\\n        aws_s3_test_input_stream_new(meta_request->allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf buf;\\\\\\\\n    aws_byte_buf_init(&buf, meta_request->allocator, (size_t)range_start);\\\\\\\\n    aws_input_stream_read(input_stream, &buf);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&buf);\\\\\\\\n    aws_byte_buf_init(&buf, meta_request->allocator, body->len);\\\\\\\\n    aws_input_stream_read(input_stream, &buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor input_cur = aws_byte_cursor_from_buf(&buf);\\\\\\\\n\\\\\\\\n    bool body_matches_expected = aws_byte_cursor_eq(&input_cur, body);\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(input_stream);\\\\\\\\n    aws_byte_buf_clean_up(&buf);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_matches_expected);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_pause_resume_helper(\\\\\\\\n    struct aws_s3_tester *tester,\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    struct put_object_pause_resume_test_data *test_data,\\\\\\\\n    struct aws_byte_cursor destination_key,\\\\\\\\n    struct aws_input_stream *upload_body_stream,\\\\\\\\n    struct aws_s3_meta_request_resume_token *resume_state,\\\\\\\\n    enum aws_s3_checksum_algorithm checksum_algorithm,\\\\\\\\n    int expected_error_code,\\\\\\\\n    int expected_response_status) {\\\\\\\\n\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    if (resume_state == NULL) {\\\\\\\\n        /* If we\\'re going to cancel this operation, limit the client to 1 HTTP connection.\\\\\\\\n         * That way, we don\\'t end up \\\\\\\\\\\\\"cancelling\\\\\\\\\\\\\" but all the parts actually\\\\\\\\n         * succeed anyway on other connections */\\\\\\\\n        client_config.max_active_connections_override = 1;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(tester, client, NULL);\\\\\\\\n    patched_client_vtable->meta_request_factory = s_meta_request_factory_patch_for_pause_resume_tests;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    /* creates a PutObject request */\\\\\\\\n    int64_t content_length = test_data->content_length;\\\\\\\\n    if (content_length == 0) {\\\\\\\\n        /* If not set, use the length of the input stream */\\\\\\\\n        aws_input_stream_get_length(upload_body_stream, &content_length);\\\\\\\\n    }\\\\\\\\n    struct aws_http_message *message = s_put_object_request_new(\\\\\\\\n        allocator, destination_key, aws_byte_cursor_from_c_str(endpoint), upload_body_stream, content_length);\\\\\\\\n\\\\\\\\n    test_data->c_var = (struct aws_condition_variable)AWS_CONDITION_VARIABLE_INIT;\\\\\\\\n    aws_mutex_init(&test_data->mutex);\\\\\\\\n    test_data->execution_completed = false;\\\\\\\\n\\\\\\\\n    tester->user_data = test_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_checksum_config checksum_config = {\\\\\\\\n        .checksum_algorithm = checksum_algorithm,\\\\\\\\n        .location = checksum_algorithm == AWS_SCA_NONE ? AWS_SCL_NONE : AWS_SCL_TRAILER,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options meta_request_options = {\\\\\\\\n        .user_data = tester,\\\\\\\\n        .body_callback = NULL,\\\\\\\\n        .signing_config = client_config.signing_config,\\\\\\\\n        .finish_callback = s_put_pause_resume_meta_request_finish,\\\\\\\\n        .headers_callback = NULL,\\\\\\\\n        .upload_review_callback = s_pause_resume_upload_review_callback,\\\\\\\\n        .message = message,\\\\\\\\n        .shutdown_callback = NULL,\\\\\\\\n        .resume_token = NULL,\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_config = &checksum_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    if (resume_state) {\\\\\\\\n        meta_request_options.resume_token = resume_state;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &meta_request_options);\\\\\\\\n    ASSERT_NOT_NULL(meta_request);\\\\\\\\n\\\\\\\\n    /* wait completion of the meta request */\\\\\\\\n    aws_mutex_lock(&test_data->mutex);\\\\\\\\n    aws_condition_variable_wait_pred(\\\\\\\\n        &test_data->c_var, &test_data->mutex, s_put_pause_resume_test_completion_predicate, test_data);\\\\\\\\n    aws_mutex_unlock(&test_data->mutex);\\\\\\\\n\\\\\\\\n    /* assert error_code and response_status_code */\\\\\\\\n    ASSERT_INT_EQUALS(expected_error_code, test_data->meta_request_error_code);\\\\\\\\n    ASSERT_INT_EQUALS(expected_response_status, test_data->response_status_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_mutex_clean_up(&test_data->mutex);\\\\\\\\n    aws_http_message_destroy(message);\\\\\\\\n\\\\\\\\n    /* release this client with its crazy patched vtables */\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_wait_for_client_shutdown(tester);\\\\\\\\n    tester->bound_to_client = false;\\\\\\\\n\\\\\\\\n    if (expected_error_code == AWS_ERROR_SUCCESS) {\\\\\\\\n        /* get the file and verify it matches what we uploaded */\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .body_callback = s_pause_resume_receive_body_callback,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = destination_key,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_test_results results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(tester, &options, &results));\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_happy_path, s_test_s3_put_pause_resume_happy_path)\\\\\\\\nstatic int s_test_s3_put_pause_resume_happy_path(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded < s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_all_parts_done, s_test_s3_put_pause_resume_all_parts_done)\\\\\\\\nstatic int s_test_s3_put_pause_resume_all_parts_done(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_all_parts_done.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 128 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_NONE,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    AWS_LOGF_INFO(AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Persistable state %p\\\\\\\\\\\\\", persistable_state);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_NONE,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_INT_EQUALS(0, bytes_uploaded);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_resume_data, s_test_s3_put_pause_resume_invalid_resume_data)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_resume_data(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_resume_data.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_s3_test_input_stream_new_with_value_type(\\\\\\\\n        allocator, s_pause_resume_object_length_128MB, TEST_STREAM_VALUE_2);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_RESUMED_PART_CHECKSUM_MISMATCH,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded < s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_resume_stream, s_test_s3_put_pause_resume_invalid_resume_stream)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_resume_stream(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_bad_resume_stream.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_release(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* a bad input stream to resume from */\\\\\\\\n    struct aws_input_stream_tester_options stream_options = {\\\\\\\\n        .autogen_length = s_pause_resume_object_length_128MB,\\\\\\\\n        .fail_on_nth_read = 1,\\\\\\\\n        .fail_with_error_code = AWS_IO_STREAM_READ_FAILED,\\\\\\\\n    };\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_input_stream_new_tester(allocator, &stream_options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    /* Each failed resume will delete the MPU */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_IO_STREAM_READ_FAILED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* resume didn\\'t read any bytes because the bad input stream failed to read. */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded == 0);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_release(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_content_length, s_test_s3_put_pause_resume_invalid_content_length)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_bad_resume_stream.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n    test_data.content_length = s_pause_resume_object_length_128MB;\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_release(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* a small input stream to resume with */\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_s3_test_input_stream_new(allocator, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    /* Each failed resume will delete the MPU */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_INCORRECT_CONTENT_LENGTH,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* resume didn\\'t read any bytes because the bad input stream failed to read. */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded == 0);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_release(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Most basic test of the upload_review_callback */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review, s_test_s3_upload_review)\\\\\\\\nstatic int s_test_s3_upload_review(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_CRC32.txt\\\\\\\\\\\\\"),\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(2, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(8), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(10) - MB_TO_BYTES(8), test_results.upload_review.part_sizes_array[1]);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_SCA_CRC32, test_results.upload_review.checksum_algorithm);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"9J8ZNA==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"BNjxzQ==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[1]));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test upload_review_callback when Content-Length is not declared */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_no_content_length, s_test_s3_upload_review_no_content_length)\\\\\\\\nstatic int s_test_s3_upload_review_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_1MB_CRC32.txt\\\\\\\\\\\\\"),\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"4hP4ig==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_upload_review_raise_canceled_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_upload_review *review,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)review;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    return aws_raise_error(AWS_ERROR_S3_CANCELED);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that if upload_review_callback raises an error, then the upload is canceled. */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_rejection, s_test_s3_upload_review_rejection)\\\\\\\\nstatic int s_test_s3_upload_review_rejection(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_rejection.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    /* Send meta-request that will raise an error from the review_upload_callback */\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .upload_review_callback = s_upload_review_raise_canceled_error,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* Check that meta-request failed with the error raised by the upload_review_callback */\\\\\\\\n    ASSERT_INT_EQUALS(AWS_ERROR_S3_CANCELED, test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    /*\\\\\\\\n     * Now check that the upload did not complete on the server either\\\\\\\\n     * (server should have received AbortMultipartUpload).\\\\\\\\n     * Check by attempting to GET the object, which should fail with 404 NOT FOUND.\\\\\\\\n     */\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &test_results));\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_404_NOT_FOUND, test_results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(test_results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(test_results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(test_results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that an MPU can be done with checksum location = NONE as long as an upload review callback\\\\\\\\n * is used, and the resulting object doesn\\'t have checksums uploaded. */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_checksum_location_none, s_test_s3_upload_review_checksum_location_none)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(2, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(5), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(5), test_results.upload_review.part_sizes_array[1]);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_SCA_CRC32, test_results.upload_review.checksum_algorithm);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"7/xUXw==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"PCOjcw==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[1]));\\\\\\\\n\\\\\\\\n    /* S3 will store the crc64 checksum for the whole object, and we can still have validate the checksum, but the algo\\\\\\\\n     * be validated will be crc64, instead of the crc32 we get from the client. */\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC64NVME,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_checksum_location_none_async, s_test_s3_upload_review_checksum_location_none_async)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none_async(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Trying to reach the noop case of async read */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_upload_review_checksum_location_none_async_noop_part,\\\\\\\\n    s_test_s3_upload_review_checksum_location_none_async_noop_part)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none_async_noop_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n                .eof_requires_extra_read = true, /* don\\'t report EOF until it tries to read 2nd part */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_http_stream *s_http_connection_make_request_patch(\\\\\\\\n    struct aws_http_connection *client_connection,\\\\\\\\n    const struct aws_http_make_request_options *options) {\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = options->request;\\\\\\\\n    struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n    struct aws_byte_cursor out_value;\\\\\\\\n    int e = aws_http_headers_get(headers, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"Content-Length\\\\\\\\\\\\\"), &out_value);\\\\\\\\n    AWS_FATAL_ASSERT(e == AWS_OP_ERR); // Assert that the header is not present\\\\\\\\n    AWS_FATAL_ASSERT(aws_last_error() == AWS_ERROR_HTTP_HEADER_NOT_FOUND);\\\\\\\\n\\\\\\\\n    return aws_http_connection_make_request(client_connection, options);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_get_without_content_length, s_test_s3_default_get_without_content_length)\\\\\\\\nstatic int s_test_s3_default_get_without_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    /* Send default type */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.message = message;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct aws_string *test_helper(struct aws_allocator *allocator) {\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n    return host_name;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_get, aws_test_s3_default_get)\\\\\\\\nstatic int aws_test_s3_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_string *hsot_name = test_helper(allocator);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(hsot_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    /* Send default type */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.message = message;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\",\\\\n  \\\\\"encoding\\\\\": \\\\\"base64\\\\\",\\\\n  \\\\\"_links\\\\\": {\\\\n    \\\\\"self\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests/s3_data_plane_tests.c?ref=dummy-delete-me\\\\\",\\\\n    \\\\\"git\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/git/blobs/dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n    \\\\\"html\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\"\\\\n  }\\\\n}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now let me query the knowledge base to understand more about error handling in the code:\"},{\"type\":\"tool_use\",\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"input\":{\"knowledge_base_id\":\"8BRIG4RFWU\",\"query\":\"What are the error handling patterns in the AWS C S3 library?\",\"number_of_results\":5},\"id\":\"toolu_bdrk_01WycqmzHSkvRLbB6mQaFMFs\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01WycqmzHSkvRLbB6mQaFMFs\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"We\\'ll outline them here. These conventions are followed in every library in the AWS C SDK ecosystem. #### Error handling Every function that returns an `int` type, returns `AWS_OP_SUCCESS` ( 0 ) or `AWS_OP_ERR` (-1) on failure. To retrieve the error code, use the function `aws_last_error()`. Each error code also has a corresponding error string that can be accessed via the `aws_error_str()` function. In addition, you can install both a global and a thread local error handler by using the `aws_set_global_error_handler_fn()` and `aws_set_thread_local_error_handler_fn()` functions. All error functions are in the `include/aws/common/error.h` header file. #### Naming Any function that allocates and initializes an object will be suffixed with `new` (e.g. `aws_myobj_new()`). Similarly, these objects will always have a corresponding function with a `destroy` suffix. The `new` functions will return the allocated object on success and `NULL` on failure. To respond to the error, call `aws_last_error()`. If several `new` or `destroy` functions are available, the variants should be named like `new_x` or `destroy_x` (e.g. `aws_myobj_new_copy()` or `aws_myobj_destroy_secure()`). Any function that initializes an existing object will be suffixed with `init` (e.g.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.6022877}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"#ifndef AWS_S3_H #define AWS_S3_H  /**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include <aws/common/common.h> #include <aws/io/logging.h> #include <aws/s3/exports.h>  AWS_PUSH_SANE_WARNING_LEVEL  #define AWS_C_S3_PACKAGE_ID 14  enum aws_s3_errors {     AWS_ERROR_S3_MISSING_CONTENT_RANGE_HEADER = AWS_ERROR_ENUM_BEGIN_RANGE(AWS_C_S3_PACKAGE_ID),     AWS_ERROR_S3_INVALID_CONTENT_RANGE_HEADER,     AWS_ERROR_S3_MISSING_CONTENT_LENGTH_HEADER,     AWS_ERROR_S3_INVALID_CONTENT_LENGTH_HEADER,     AWS_ERROR_S3_MISSING_ETAG,     AWS_ERROR_S3_INTERNAL_ERROR,     AWS_ERROR_S3_SLOW_DOWN,     AWS_ERROR_S3_INVALID_RESPONSE_STATUS,     AWS_ERROR_S3_MISSING_UPLOAD_ID,     AWS_ERROR_S3_PROXY_PARSE_FAILED,     AWS_ERROR_S3_UNSUPPORTED_PROXY_SCHEME,     AWS_ERROR_S3_CANCELED,     AWS_ERROR_S3_INVALID_RANGE_HEADER,     AWS_ERROR_S3_MULTIRANGE_HEADER_UNSUPPORTED,     AWS_ERROR_S3_RESPONSE_CHECKSUM_MISMATCH,     AWS_ERROR_S3_CHECKSUM_CALCULATION_FAILED,     AWS_ERROR_S3_PAUSED,     AWS_ERROR_S3_LIST_PARTS_PARSE_FAILED,     AWS_ERROR_S3_RESUMED_PART_CHECKSUM_MISMATCH,\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/include/aws/s3/s3.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5958285}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"While this design pattern makes for graceful looking user code, it is very easy to make mistakes in implementation code, if you forget to call `aws_raise_error()` in all possible failure branches. Hence, this guide... ### Catching Errors Error handling in a toy application might look like: ```c /* For functions that return a pointer, NULL means failure */ struct aws_thing *thing = aws_thing_new(...); if (thing == NULL) { int error_code = aws_last_error(); printf(\\\\\\\\\\\\\"Failed to create thing: %s\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\", aws_error_str(error_code)); exit(error_code); } /* For functions that return an int, AWS_OP_ERR means failure */ if (aws_thing_do_something_that_may_fail(thing, ...) == AWS_OP_ERR) { int error_code = aws_last_error(); printf(\\\\\\\\\\\\\"Failed to do something: %s\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\", aws_error_str(error_code)); exit(error_code); } /* You\\'ll also see lots of code that doesn\\'t explicitly compare the return value * against `AWS_OP_ERR` or `AWS_OP_SUCCESS`.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/docs/error-handling.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5890754}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include <aws/s3/private/s3_platform_info.h> #include <aws/s3/private/s3_util.h> #include <aws/s3/s3.h> #include <aws/s3/s3_client.h>  #include <aws/auth/auth.h> #include <aws/checksums/checksums.h> #include <aws/common/error.h> #include <aws/common/hash_table.h> #include <aws/http/http.h>  #define AWS_DEFINE_ERROR_INFO_S3(CODE, STR) AWS_DEFINE_ERROR_INFO(CODE, STR, \\\\\\\\\\\\\"aws-c-s3\\\\\\\\\\\\\")  /* clang-format off */ static struct aws_error_info s_errors[] = {     AWS_DEFINE_ERROR_INFO_S3(AWS_ERROR_S3_MISSING_CONTENT_RANGE_HEADER, \\\\\\\\\\\\\"Response missing required Content-Range header.\\\\\\\\\\\\\"),     AWS_DEFINE_ERROR_INFO_S3(AWS_ERROR_S3_INVALID_CONTENT_RANGE_HEADER, \\\\\\\\\\\\\"Response contains invalid Content-Range header.\\\\\\\\\\\\\"),     AWS_DEFINE_ERROR_INFO_S3(AWS_ERROR_S3_MISSING_CONTENT_LENGTH_HEADER, \\\\\\\\\\\\\"Response missing required Content-Length header.\\\\\\\\\\\\\"),     AWS_DEFINE_ERROR_INFO_S3(AWS_ERROR_S3_INVALID_CONTENT_LENGTH_HEADER, \\\\\\\\\\\\\"Response contains invalid Content-Length header.\\\\\\\\\\\\\"),     AWS_DEFINE_ERROR_INFO_S3(AWS_ERROR_S3_MISSING_ETAG, \\\\\\\\\\\\\"Response missing required ETag header.\\\\\\\\\\\\\"),\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/source/s3.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.56430465}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"`AWS_OP_ERR` and `AWS_OP_SUCCESS` are not used. DO NOT call `aws_raise_error()` before invoking a callback. DO NOT call `aws_last_error()` within a callback to check for error. ## Best Practices Error handling is extra difficult in C, because C doesn\\'t have automatic destructors or garbage collection. If you need to do several things in sequence, and the last thing fails, you need to manually undo all previous steps. We suggest keeping things as simple and maintainable as we can get away with. Our style has evolved with time, and you\\'ll find lots of old code violating these rules, but here are best practices. ### If a function can\\'t fail, make it void Don\\'t return `int` \\\\\\\\\\\\\"just in case it might fail someday\\\\\\\\\\\\\" or \\\\\\\\\\\\\"for consistency with other functions\\\\\\\\\\\\\". This is especially important for low-level datastructure APIs, or any function that cleans up or destroys something. Imagine there\\'s some \\\\\\\\\\\\\"clean up\\\\\\\\\\\\\" function that needs to use your function, and your function returns `int`. What is that clean up function supposed to do? Try to handle the error? How? Should it stop even trying to clean up? Leak memory? If your function creates some complex stateful class, that takes lots of parameters, and can\\'t currently fail, but you can totally imagine a future where it can, then yeah give it an API where it might fail.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/docs/error-handling.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.56409335}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"tool_use\",\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"input\":{\"knowledge_base_id\":\"8BRIG4RFWU\",\"query\":\"How does the AWS C S3 library handle error cases with resource cleanup?\",\"number_of_results\":5},\"id\":\"toolu_bdrk_012d1LjvbHL1FVFrVDWVZGye\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_012d1LjvbHL1FVFrVDWVZGye\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/byte_buf.h> #include <aws/common/clock.h> #include <aws/common/common.h> #include <aws/common/environment.h> #include <aws/common/ref_count.h> #include <aws/http/request_response.h> #include <aws/io/channel_bootstrap.h> #include <aws/io/event_loop.h> #include <aws/io/host_resolver.h> #include <aws/io/stream.h> #include <aws/io/tls_channel_handler.h> #include <aws/testing/aws_test_harness.h> #include <inttypes.h> #include <stdio.h>  /* Ensure the library can go through the init/cleanup cycle multiple times */ AWS_TEST_CASE(test_s3_library_init_cleanup_init_cleanup, s_test_s3_library_init_cleanup_init_cleanup) static int s_test_s3_library_init_cleanup_init_cleanup(struct aws_allocator *allocator, void *ctx) {     (void)ctx;      aws_s3_library_init(allocator);     aws_s3_library_clean_up();      aws_s3_library_init(allocator);\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_util_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.54213405}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"We\\'ll outline them here. These conventions are followed in every library in the AWS C SDK ecosystem. #### Error handling Every function that returns an `int` type, returns `AWS_OP_SUCCESS` ( 0 ) or `AWS_OP_ERR` (-1) on failure. To retrieve the error code, use the function `aws_last_error()`. Each error code also has a corresponding error string that can be accessed via the `aws_error_str()` function. In addition, you can install both a global and a thread local error handler by using the `aws_set_global_error_handler_fn()` and `aws_set_thread_local_error_handler_fn()` functions. All error functions are in the `include/aws/common/error.h` header file. #### Naming Any function that allocates and initializes an object will be suffixed with `new` (e.g. `aws_myobj_new()`). Similarly, these objects will always have a corresponding function with a `destroy` suffix. The `new` functions will return the allocated object on success and `NULL` on failure. To respond to the error, call `aws_last_error()`. If several `new` or `destroy` functions are available, the variants should be named like `new_x` or `destroy_x` (e.g. `aws_myobj_new_copy()` or `aws_myobj_destroy_secure()`). Any function that initializes an existing object will be suffixed with `init` (e.g.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5310991}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"* Must be called before using any functionality in aws-c-http.  */ AWS_HTTP_API void aws_http_library_init(struct aws_allocator *alloc);  /**  * Clean up internal datastructures used by aws-c-http.  * Must not be called until application is done using functionality in aws-c-http.  */ AWS_HTTP_API void aws_http_library_clean_up(void);  /**  * Returns the description of common status codes.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-http/include/aws/http/http.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5265677}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"Use this to catch bugs that might occur in language binding code (which is seldom built in Debug), or for internal bugs you worry are too complex to encounter in a Debug build. Use `aws_raise_error()` (real error handling) for everything else. ### init() / clean_up() example Here\\'s an example, with an \\\\\\\\\\\\\"init / clean_up\\\\\\\\\\\\\" style struct, where any initialization step may fail, and we\\'d need to undo the previous steps: ```c int aws_thing_init(struct aws_thing *thing) { /* First, zero things out, in case memory was uninitialized. * That way we can safely call clean_up() on each member, * even if we didn\\'t fully initialize everything.*/ AWS_ZERO_STRUCT(*thing); if (aws_complex_part_1_init(&thing->part_1) != AWS_OP_SUCCESS) { /* Prefer early-out patterns, vs deeply embedded if-branches */ goto error; } if (aws_complex_part_2_init(&thing->part_2) != AWS_OP_SUCCESS) { /* goto is fine in C */ goto error; } if (aws_complex_part_3_init(&thing->part_3) !\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/docs/error-handling.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.52323866}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"= AWS_OP_SUCCESS) { goto error; } return AWS_OP_SUCCESS; error: /* Just call the clean_up() function, rather than repeating * the code that cleans up individual members */ aws_thing_clean_up(thing); /* Note: we didn\\'t set thread-local error code before returning AWS_OP_ERR, * because we assume it was already set by the aws_complex_part_N_init() * failure that led us here */ return AWS_OP_ERR; } void aws_thing_clean_up(struct aws_thing *thing) { /* It\\'s safe to try and clean up aws_ types, even if they were never * initialized. We build all our \\\\\\\\\\\\\"destructors\\\\\\\\\\\\\" to be idempotent * and safe to call on zeroed-out memory. * This lets us have nice clean simple clean up code like so: */ aws_complex_part_3_clean_up(&thing->part_3); aws_complex_part_2_clean_up(&thing->part_2); aws_complex_part_1_clean_up(&thing->part_1); /* Finally, zero things out so the clean_up() is idempotent */ AWS_ZERO_STRUCT(*thing); } ``` And here are some ways NOT to do it: ```c /* DO NOT DO THIS (each failed step tries to clean up previous steps) */ int aws_thing_init(struct aws_thing *thing) { AWS_ZERO_STRUCT(*thing); if (aws_complex_part_1_init(&thing->part_1) !\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/docs/error-handling.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.52147466}\"}],\"is_error\":false}]}],\"stop_sequences\":null,\"system\":\"Given a github pull request.         The code in the pull request is very related to the knowledge base, fetch the details of the code base you want to learn about the code from the knowledge base.             Use 8BRIG4RFWU as Knowledge Base ID and aws profile as bedrock, region us-east-1                But if the code is just added by the pull request, then the knowledge base will not help         and follow the guidance in /Users/dengket/project/hackthon/fast-agent/crt_c_reviewer/summarization/comments_styles.md to be how you will make comments then make your comments             as details as you can for each specific lines about the error handling on the pull request,                 save your comments about the specific line or lines with the number of the lines to a folder naming followed by ./new_comments_s3_PR<the PR number> with name related to the Pull request like PR454_Comments_Impl.md.                     And then, generates the comments only if needed and keep the positive comments out for the specific line or lines as the input for create_pull_request_review,                         save it to a file to the same folder with naming like `input_PR454_comments_Error_handling.json`, but don\\'t really submit the comments\",\"tools\":[{\"name\":\"github-create_or_update_file\",\"description\":\"Create or update a single file in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"path\":{\"type\":\"string\",\"description\":\"Path where to create/update the file\"},\"content\":{\"type\":\"string\",\"description\":\"Content of the file\"},\"message\":{\"type\":\"string\",\"description\":\"Commit message\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to create/update the file in\"},\"sha\":{\"type\":\"string\",\"description\":\"SHA of the file being replaced (required when updating existing files)\"}},\"required\":[\"owner\",\"repo\",\"path\",\"content\",\"message\",\"branch\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_repositories\",\"description\":\"Search for GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"query\":{\"type\":\"string\",\"description\":\"Search query (see GitHub search syntax)\"},\"page\":{\"type\":\"number\",\"description\":\"Page number for pagination (default: 1)\"},\"perPage\":{\"type\":\"number\",\"description\":\"Number of results per page (default: 30, max: 100)\"}},\"required\":[\"query\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_repository\",\"description\":\"Create a new GitHub repository in your account\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\",\"description\":\"Repository name\"},\"description\":{\"type\":\"string\",\"description\":\"Repository description\"},\"private\":{\"type\":\"boolean\",\"description\":\"Whether the repository should be private\"},\"autoInit\":{\"type\":\"boolean\",\"description\":\"Initialize with README.md\"}},\"required\":[\"name\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_file_contents\",\"description\":\"Get the contents of a file or directory from a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"path\":{\"type\":\"string\",\"description\":\"Path to the file or directory\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to get contents from\"}},\"required\":[\"owner\",\"repo\",\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-push_files\",\"description\":\"Push multiple files to a GitHub repository in a single commit\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to push to (e.g., \\'main\\' or \\'master\\')\"},\"files\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"content\":{\"type\":\"string\"}},\"required\":[\"path\",\"content\"],\"additionalProperties\":false},\"description\":\"Array of files to push\"},\"message\":{\"type\":\"string\",\"description\":\"Commit message\"}},\"required\":[\"owner\",\"repo\",\"branch\",\"files\",\"message\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_issue\",\"description\":\"Create a new issue in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"body\":{\"type\":\"string\"},\"assignees\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"milestone\":{\"type\":\"number\"},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"owner\",\"repo\",\"title\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_pull_request\",\"description\":\"Create a new pull request in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"title\":{\"type\":\"string\",\"description\":\"Pull request title\"},\"body\":{\"type\":\"string\",\"description\":\"Pull request body/description\"},\"head\":{\"type\":\"string\",\"description\":\"The name of the branch where your changes are implemented\"},\"base\":{\"type\":\"string\",\"description\":\"The name of the branch you want the changes pulled into\"},\"draft\":{\"type\":\"boolean\",\"description\":\"Whether to create the pull request as a draft\"},\"maintainer_can_modify\":{\"type\":\"boolean\",\"description\":\"Whether maintainers can modify the pull request\"}},\"required\":[\"owner\",\"repo\",\"title\",\"head\",\"base\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-fork_repository\",\"description\":\"Fork a GitHub repository to your account or specified organization\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"organization\":{\"type\":\"string\",\"description\":\"Optional: organization to fork to (defaults to your personal account)\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_branch\",\"description\":\"Create a new branch in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"branch\":{\"type\":\"string\",\"description\":\"Name for the new branch\"},\"from_branch\":{\"type\":\"string\",\"description\":\"Optional: source branch to create from (defaults to the repository\\'s default branch)\"}},\"required\":[\"owner\",\"repo\",\"branch\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_commits\",\"description\":\"Get list of commits of a branch in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"sha\":{\"type\":\"string\"},\"page\":{\"type\":\"number\"},\"perPage\":{\"type\":\"number\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_issues\",\"description\":\"List issues in a GitHub repository with filtering options\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"direction\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"page\":{\"type\":\"number\"},\"per_page\":{\"type\":\"number\"},\"since\":{\"type\":\"string\"},\"sort\":{\"type\":\"string\",\"enum\":[\"created\",\"updated\",\"comments\"]},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\",\"all\"]}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-update_issue\",\"description\":\"Update an existing issue in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"},\"title\":{\"type\":\"string\"},\"body\":{\"type\":\"string\"},\"assignees\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"milestone\":{\"type\":\"number\"},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\"]}},\"required\":[\"owner\",\"repo\",\"issue_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-add_issue_comment\",\"description\":\"Add a comment to an existing issue\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"},\"body\":{\"type\":\"string\"}},\"required\":[\"owner\",\"repo\",\"issue_number\",\"body\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_code\",\"description\":\"Search for code across GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_issues\",\"description\":\"Search for issues and pull requests across GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100},\"sort\":{\"type\":\"string\",\"enum\":[\"comments\",\"reactions\",\"reactions-+1\",\"reactions--1\",\"reactions-smile\",\"reactions-thinking_face\",\"reactions-heart\",\"reactions-tada\",\"interactions\",\"created\",\"updated\"]}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_users\",\"description\":\"Search for users on GitHub\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100},\"sort\":{\"type\":\"string\",\"enum\":[\"followers\",\"repositories\",\"joined\"]}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_issue\",\"description\":\"Get details of a specific issue in a GitHub repository.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"}},\"required\":[\"owner\",\"repo\",\"issue_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request\",\"description\":\"Get details of a specific pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_pull_requests\",\"description\":\"List and filter repository pull requests\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\",\"all\"],\"description\":\"State of the pull requests to return\"},\"head\":{\"type\":\"string\",\"description\":\"Filter by head user or head organization and branch name\"},\"base\":{\"type\":\"string\",\"description\":\"Filter by base branch name\"},\"sort\":{\"type\":\"string\",\"enum\":[\"created\",\"updated\",\"popularity\",\"long-running\"],\"description\":\"What to sort results by\"},\"direction\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"],\"description\":\"The direction of the sort\"},\"per_page\":{\"type\":\"number\",\"description\":\"Results per page (max 100)\"},\"page\":{\"type\":\"number\",\"description\":\"Page number of the results\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_pull_request_review\",\"description\":\"Create a review on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"commit_id\":{\"type\":\"string\",\"description\":\"The SHA of the commit that needs a review\"},\"body\":{\"type\":\"string\",\"description\":\"The body text of the review\"},\"event\":{\"type\":\"string\",\"enum\":[\"APPROVE\",\"REQUEST_CHANGES\",\"COMMENT\"],\"description\":\"The review action to perform\"},\"comments\":{\"type\":\"array\",\"items\":{\"anyOf\":[{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\",\"description\":\"The relative path to the file being commented on\"},\"position\":{\"type\":\"number\",\"description\":\"The position in the diff where you want to add a review comment\"},\"body\":{\"type\":\"string\",\"description\":\"Text of the review comment\"}},\"required\":[\"path\",\"position\",\"body\"],\"additionalProperties\":false},{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\",\"description\":\"The relative path to the file being commented on\"},\"line\":{\"type\":\"number\",\"description\":\"The line number in the file where you want to add a review comment\"},\"body\":{\"type\":\"string\",\"description\":\"Text of the review comment\"}},\"required\":[\"path\",\"line\",\"body\"],\"additionalProperties\":false}]},\"description\":\"Comments to post as part of the review (specify either position or line, not both)\"}},\"required\":[\"owner\",\"repo\",\"pull_number\",\"body\",\"event\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-merge_pull_request\",\"description\":\"Merge a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"commit_title\":{\"type\":\"string\",\"description\":\"Title for the automatic commit message\"},\"commit_message\":{\"type\":\"string\",\"description\":\"Extra detail to append to automatic commit message\"},\"merge_method\":{\"type\":\"string\",\"enum\":[\"merge\",\"squash\",\"rebase\"],\"description\":\"Merge method to use\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_files\",\"description\":\"Get the list of files changed in a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_status\",\"description\":\"Get the combined status of all status checks for a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-update_pull_request_branch\",\"description\":\"Update a pull request branch with the latest changes from the base branch\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"expected_head_sha\":{\"type\":\"string\",\"description\":\"The expected SHA of the pull request\\'s HEAD ref\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_comments\",\"description\":\"Get the review comments on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_reviews\",\"description\":\"Get the reviews on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-read_file\",\"description\":\"Read the complete contents of a file from the file system. Handles various text encodings and provides detailed error messages if the file cannot be read. Use this tool when you need to examine the contents of a single file. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-read_multiple_files\",\"description\":\"Read the contents of multiple files simultaneously. This is more efficient than reading files one by one when you need to analyze or compare multiple files. Each file\\'s content is returned with its path as a reference. Failed reads for individual files won\\'t stop the entire operation. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"paths\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"paths\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-write_file\",\"description\":\"Create a new file or completely overwrite an existing file with new content. Use with caution as it will overwrite existing files without warning. Handles text content with proper encoding. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"content\":{\"type\":\"string\"}},\"required\":[\"path\",\"content\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-edit_file\",\"description\":\"Make line-based edits to a text file. Each edit replaces exact line sequences with new content. Returns a git-style diff showing the changes made. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"edits\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"oldText\":{\"type\":\"string\",\"description\":\"Text to search for - must match exactly\"},\"newText\":{\"type\":\"string\",\"description\":\"Text to replace with\"}},\"required\":[\"oldText\",\"newText\"],\"additionalProperties\":false}},\"dryRun\":{\"type\":\"boolean\",\"default\":false,\"description\":\"Preview changes using git-style diff format\"}},\"required\":[\"path\",\"edits\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-create_directory\",\"description\":\"Create a new directory or ensure a directory exists. Can create multiple nested directories in one operation. If the directory already exists, this operation will succeed silently. Perfect for setting up directory structures for projects or ensuring required paths exist. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-list_directory\",\"description\":\"Get a detailed listing of all files and directories in a specified path. Results clearly distinguish between files and directories with [FILE] and [DIR] prefixes. This tool is essential for understanding directory structure and finding specific files within a directory. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-directory_tree\",\"description\":\"Get a recursive tree view of files and directories as a JSON structure. Each entry includes \\'name\\', \\'type\\' (file/directory), and \\'children\\' for directories. Files have no children array, while directories always have a children array (which may be empty). The output is formatted with 2-space indentation for readability. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-move_file\",\"description\":\"Move or rename files and directories. Can move files between directories and rename them in a single operation. If the destination exists, the operation will fail. Works across different directories and can be used for simple renaming within the same directory. Both source and destination must be within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"source\":{\"type\":\"string\"},\"destination\":{\"type\":\"string\"}},\"required\":[\"source\",\"destination\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-search_files\",\"description\":\"Recursively search for files and directories matching a pattern. Searches through all subdirectories from the starting path. The search is case-insensitive and matches partial names. Returns full paths to all matching items. Great for finding files when you don\\'t know their exact location. Only searches within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"pattern\":{\"type\":\"string\"},\"excludePatterns\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"default\":[]}},\"required\":[\"path\",\"pattern\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-get_file_info\",\"description\":\"Retrieve detailed metadata about a file or directory. Returns comprehensive information including size, creation time, last modified time, permissions, and type. This tool is perfect for understanding file characteristics without reading the actual content. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-list_allowed_directories\",\"description\":\"Returns the list of directories that this server is allowed to access. Use this to understand which directories are available before trying to access files.\",\"input_schema\":{\"type\":\"object\",\"properties\":{},\"required\":[]}},{\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"description\":\"Query an Amazon Bedrock Knowledge Base using natural language.\\\\n\\\\n    ## Usage Requirements\\\\n    - You MUST first use the `resource://knowledgebases` resource to get valid knowledge base IDs\\\\n    - You can query different knowledge bases or make multiple queries to the same knowledge base\\\\n\\\\n    ## Query Tips\\\\n    - Use clear, specific natural language queries for best results\\\\n    - You can use this tool MULTIPLE TIMES with different queries to gather comprehensive information\\\\n    - Break complex questions into multiple focused queries\\\\n    - Consider querying for factual information and explanations separately\\\\n\\\\n    ## Tool output format\\\\n    The response contains multiple JSON objects (one per line), each representing a retrieved document with:\\\\n    - content: The text content of the document\\\\n    - location: The source location of the document\\\\n    - score: The relevance score of the document\\\\n\\\\n\\\\n    ## Interpretation Best Practices\\\\n    1. Extract and combine key information from multiple results\\\\n    2. Consider the source and relevance score when evaluating information\\\\n    3. Use follow-up queries to clarify ambiguous or incomplete information\\\\n    4. If the response is not relevant, try a different query, knowledge base, and/or data source\\\\n    5. After a few attempts, ask the user for clarification or a different query.\\\\n    \",\"input_schema\":{\"properties\":{\"query\":{\"description\":\"A natural language query to search the knowledge base with\",\"title\":\"Query\",\"type\":\"string\"},\"knowledge_base_id\":{\"description\":\"The knowledge base ID to query. It must be a valid ID from the resource://knowledgebases MCP resource\",\"title\":\"Knowledge Base Id\",\"type\":\"string\"},\"number_of_results\":{\"default\":10,\"description\":\"The number of results to return. Use smaller values for focused results and larger values for broader coverage.\",\"title\":\"Number Of Results\",\"type\":\"integer\"},\"reranking\":{\"default\":false,\"description\":\"Whether to rerank the results. Useful for improving relevance and sorting. Can be globally configured with BEDROCK_KB_RERANKING_ENABLED environment variable.\",\"title\":\"Reranking\",\"type\":\"boolean\"},\"reranking_model_name\":{\"default\":\"AMAZON\",\"description\":\"The name of the reranking model to use. Options: \\'COHERE\\', \\'AMAZON\\'\",\"enum\":[\"COHERE\",\"AMAZON\"],\"title\":\"Reranking Model Name\",\"type\":\"string\"},\"data_source_ids\":{\"anyOf\":[{\"items\":{\"type\":\"string\"},\"type\":\"array\"},{\"type\":\"null\"}],\"default\":null,\"description\":\"The data source IDs to filter the knowledge base by. It must be a list of valid data source IDs from the resource://knowledgebases MCP resource\",\"title\":\"Data Source Ids\"}},\"required\":[\"query\",\"knowledge_base_id\"],\"title\":\"query_knowledge_bases_toolArguments\",\"type\":\"object\"}}],\"anthropic_version\":\"bedrock-2023-05-31\"}'"},"message":"Error code: 429 - {'message': 'Too many tokens, please wait before trying again.'}","body":{"message":"Too many tokens, please wait before trying again."},"response":"<httpx.Response [429] https://bedrock-runtime.us-west-2.amazonaws.com/model/us.anthropic.claude-3-7-sonnet-20250219-v1:0/invoke>","status_code":429,"request_id":null}]}}
{"level":"ERROR","timestamp":"2025-05-15T11:01:52.052285","namespace":"mcp_agent.llm.augmented_llm","message":"Error: Error code: 429 - {'message': 'Too many tokens, please wait before trying again.'}","data":{"data":[{"request":{"method":"POST","url":{"_uri_reference":["https","","bedrock-runtime.us-west-2.amazonaws.com",null,"/model/us.anthropic.claude-3-7-sonnet-20250219-v1:0/invoke",null,null]},"headers":["connection","host","accept-encoding","x-stainless-timeout","accept","content-type","user-agent","x-stainless-lang","x-stainless-package-version","x-stainless-os","x-stainless-arch","x-stainless-runtime","x-stainless-runtime-version","x-stainless-retry-count","x-stainless-read-timeout","content-length","x-amz-date","x-amz-security-token","authorization"],"extensions":{"timeout":{"connect":5.0,"read":600,"write":"600","pool":"600"}},"stream":[{"capitalize":"<callable: capitalize>","center":"<callable: center>","count":"<callable: count>","decode":"<callable: decode>","endswith":"<callable: endswith>","expandtabs":"<callable: expandtabs>","find":"<callable: find>","fromhex":"<callable: fromhex>","hex":"<callable: hex>","index":"<callable: index>","isalnum":"<callable: isalnum>","isalpha":"<callable: isalpha>","isascii":"<callable: isascii>","isdigit":"<callable: isdigit>","islower":"<callable: islower>","isspace":"<callable: isspace>","istitle":"<callable: istitle>","isupper":"<callable: isupper>","join":"<callable: join>","ljust":"<callable: ljust>","lower":"<callable: lower>","lstrip":"<callable: lstrip>","maketrans":"<callable: maketrans>","partition":"<callable: partition>","removeprefix":"<callable: removeprefix>","removesuffix":"<callable: removesuffix>","replace":"<callable: replace>","rfind":"<callable: rfind>","rindex":"<callable: rindex>","rjust":"<callable: rjust>","rpartition":"<callable: rpartition>","rsplit":"<callable: rsplit>","rstrip":"<callable: rstrip>","split":"<callable: split>","splitlines":"<callable: splitlines>","startswith":"<callable: startswith>","strip":"<callable: strip>","swapcase":"<callable: swapcase>","title":"<callable: title>","translate":"<callable: translate>","upper":"<callable: upper>","zfill":"<callable: zfill>"}],"_content":"b'{\"max_tokens\":4096,\"messages\":[{\"role\":\"user\",\"content\":[{\"type\":\"text\",\"text\":\"please review https://github.com/awslabs/aws-c-s3/pull/519\"}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"I\\'ll review the pull request at https://github.com/awslabs/aws-c-s3/pull/519. First, let me get the details of this pull request to understand what changes are being proposed.\"},{\"type\":\"tool_use\",\"name\":\"github-get_pull_request\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"pull_number\":519},\"id\":\"toolu_bdrk_0197qdquYDiMSnpipsHzef6T\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_0197qdquYDiMSnpipsHzef6T\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\n  \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/pulls/519\\\\\",\\\\n  \\\\\"id\\\\\": 2520395028,\\\\n  \\\\\"node_id\\\\\": \\\\\"PR_kwDOEJB4Sc6WOi0U\\\\\",\\\\n  \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519\\\\\",\\\\n  \\\\\"diff_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519.diff\\\\\",\\\\n  \\\\\"patch_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519.patch\\\\\",\\\\n  \\\\\"issue_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/issues/519\\\\\",\\\\n  \\\\\"number\\\\\": 519,\\\\n  \\\\\"state\\\\\": \\\\\"open\\\\\",\\\\n  \\\\\"locked\\\\\": false,\\\\n  \\\\\"title\\\\\": \\\\\"dummy test\\\\\",\\\\n  \\\\\"user\\\\\": {\\\\n    \\\\\"login\\\\\": \\\\\"TingDaoK\\\\\",\\\\n    \\\\\"id\\\\\": 26829806,\\\\n    \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/26829806?v=4\\\\\",\\\\n    \\\\\"url\\\\\": \\\\\"https://api.github.com/users/TingDaoK\\\\\",\\\\n    \\\\\"html_url\\\\\": \\\\\"https://github.com/TingDaoK\\\\\"\\\\n  },\\\\n  \\\\\"body\\\\\": \\\\\"*Issue #, if available:*\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n*Description of changes:*\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.\\\\\\\\r\\\\\\\\n\\\\\",\\\\n  \\\\\"created_at\\\\\": \\\\\"2025-05-14T21:35:46Z\\\\\",\\\\n  \\\\\"updated_at\\\\\": \\\\\"2025-05-14T23:38:00Z\\\\\",\\\\n  \\\\\"closed_at\\\\\": null,\\\\n  \\\\\"merged_at\\\\\": null,\\\\n  \\\\\"merge_commit_sha\\\\\": \\\\\"b8fc1c78ceeba7906b6ac56483199a3faaf5e9cd\\\\\",\\\\n  \\\\\"assignee\\\\\": null,\\\\n  \\\\\"assignees\\\\\": [],\\\\n  \\\\\"requested_reviewers\\\\\": [],\\\\n  \\\\\"labels\\\\\": [],\\\\n  \\\\\"head\\\\\": {\\\\n    \\\\\"label\\\\\": \\\\\"awslabs:dummy-delete-me\\\\\",\\\\n    \\\\\"ref\\\\\": \\\\\"dummy-delete-me\\\\\",\\\\n    \\\\\"sha\\\\\": \\\\\"e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6\\\\\",\\\\n    \\\\\"user\\\\\": {\\\\n      \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n      \\\\\"id\\\\\": 3299148,\\\\n      \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\"\\\\n    },\\\\n    \\\\\"repo\\\\\": {\\\\n      \\\\\"id\\\\\": 277903433,\\\\n      \\\\\"node_id\\\\\": \\\\\"MDEwOlJlcG9zaXRvcnkyNzc5MDM0MzM=\\\\\",\\\\n      \\\\\"name\\\\\": \\\\\"aws-c-s3\\\\\",\\\\n      \\\\\"full_name\\\\\": \\\\\"awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"private\\\\\": false,\\\\n      \\\\\"owner\\\\\": {\\\\n        \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n        \\\\\"id\\\\\": 3299148,\\\\n        \\\\\"node_id\\\\\": \\\\\"MDEyOk9yZ2FuaXphdGlvbjMyOTkxNDg=\\\\\",\\\\n        \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n        \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n        \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\",\\\\n        \\\\\"type\\\\\": \\\\\"Organization\\\\\"\\\\n      },\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"description\\\\\": \\\\\"C99 library implementation for communicating with the S3 service, designed for maximizing throughput on high bandwidth EC2 instances.\\\\\",\\\\n      \\\\\"fork\\\\\": false,\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"created_at\\\\\": \\\\\"2020-07-07T19:21:45Z\\\\\",\\\\n      \\\\\"updated_at\\\\\": \\\\\"2025-05-15T17:15:47Z\\\\\",\\\\n      \\\\\"pushed_at\\\\\": \\\\\"2025-05-15T17:16:08Z\\\\\",\\\\n      \\\\\"git_url\\\\\": \\\\\"git://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"ssh_url\\\\\": \\\\\"git@github.com:awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"clone_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"default_branch\\\\\": \\\\\"main\\\\\"\\\\n    }\\\\n  },\\\\n  \\\\\"base\\\\\": {\\\\n    \\\\\"label\\\\\": \\\\\"awslabs:main\\\\\",\\\\n    \\\\\"ref\\\\\": \\\\\"main\\\\\",\\\\n    \\\\\"sha\\\\\": \\\\\"7d2d4b3070109c882ff78e8719f60597c7ba0472\\\\\",\\\\n    \\\\\"user\\\\\": {\\\\n      \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n      \\\\\"id\\\\\": 3299148,\\\\n      \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\"\\\\n    },\\\\n    \\\\\"repo\\\\\": {\\\\n      \\\\\"id\\\\\": 277903433,\\\\n      \\\\\"node_id\\\\\": \\\\\"MDEwOlJlcG9zaXRvcnkyNzc5MDM0MzM=\\\\\",\\\\n      \\\\\"name\\\\\": \\\\\"aws-c-s3\\\\\",\\\\n      \\\\\"full_name\\\\\": \\\\\"awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"private\\\\\": false,\\\\n      \\\\\"owner\\\\\": {\\\\n        \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n        \\\\\"id\\\\\": 3299148,\\\\n        \\\\\"node_id\\\\\": \\\\\"MDEyOk9yZ2FuaXphdGlvbjMyOTkxNDg=\\\\\",\\\\n        \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n        \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n        \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\",\\\\n        \\\\\"type\\\\\": \\\\\"Organization\\\\\"\\\\n      },\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"description\\\\\": \\\\\"C99 library implementation for communicating with the S3 service, designed for maximizing throughput on high bandwidth EC2 instances.\\\\\",\\\\n      \\\\\"fork\\\\\": false,\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"created_at\\\\\": \\\\\"2020-07-07T19:21:45Z\\\\\",\\\\n      \\\\\"updated_at\\\\\": \\\\\"2025-05-15T17:15:47Z\\\\\",\\\\n      \\\\\"pushed_at\\\\\": \\\\\"2025-05-15T17:16:08Z\\\\\",\\\\n      \\\\\"git_url\\\\\": \\\\\"git://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"ssh_url\\\\\": \\\\\"git@github.com:awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"clone_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"default_branch\\\\\": \\\\\"main\\\\\"\\\\n    }\\\\n  }\\\\n}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now, let me get the list of files changed in this pull request to understand the scope of the changes.\"},{\"type\":\"tool_use\",\"name\":\"github-get_pull_request_files\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"pull_number\":519},\"id\":\"toolu_bdrk_01FKYjr3KCdsobbEmdyTdk66\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01FKYjr3KCdsobbEmdyTdk66\",\"content\":[{\"type\":\"text\",\"text\":\"[\\\\n  {\\\\n    \\\\\"sha\\\\\": \\\\\"dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n    \\\\\"filename\\\\\": \\\\\"tests/s3_data_plane_tests.c\\\\\",\\\\n    \\\\\"status\\\\\": \\\\\"modified\\\\\",\\\\n    \\\\\"additions\\\\\": 49,\\\\n    \\\\\"deletions\\\\\": 0,\\\\n    \\\\\"changes\\\\\": 49,\\\\n    \\\\\"blob_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6/tests%2Fs3_data_plane_tests.c\\\\\",\\\\n    \\\\\"raw_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/raw/e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6/tests%2Fs3_data_plane_tests.c\\\\\",\\\\n    \\\\\"contents_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests%2Fs3_data_plane_tests.c?ref=e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6\\\\\",\\\\n    \\\\\"patch\\\\\": \\\\\"@@ -8114,3 +8114,52 @@ static int s_test_s3_default_get_without_content_length(struct aws_allocator *al\\\\\\\\n \\\\\\\\n     return AWS_OP_SUCCESS;\\\\\\\\n }\\\\\\\\n+\\\\\\\\n+struct aws_string *test_helper(struct aws_allocator *allocator) {\\\\\\\\n+    struct aws_string *host_name =\\\\\\\\n+        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n+    return host_name;\\\\\\\\n+}\\\\\\\\n+\\\\\\\\n+AWS_TEST_CASE(test_s3_default_get, aws_test_s3_default_get)\\\\\\\\n+static int aws_test_s3_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n+    (void)ctx;\\\\\\\\n+\\\\\\\\n+    struct aws_s3_tester tester;\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n+\\\\\\\\n+    struct aws_s3_client *client = NULL;\\\\\\\\n+    struct aws_s3_tester_client_options client_options;\\\\\\\\n+    AWS_ZERO_STRUCT(client_options);\\\\\\\\n+\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n+    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n+    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n+\\\\\\\\n+    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n+    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n+\\\\\\\\n+    struct aws_string *hsot_name = test_helper(allocator);\\\\\\\\n+\\\\\\\\n+    /* Put together a simple S3 Get Object request. */\\\\\\\\n+    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n+        allocator, aws_byte_cursor_from_string(hsot_name), g_pre_existing_object_1MB);\\\\\\\\n+\\\\\\\\n+    struct aws_s3_meta_request_options options;\\\\\\\\n+    AWS_ZERO_STRUCT(options);\\\\\\\\n+    /* Send default type */\\\\\\\\n+    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n+    options.message = message;\\\\\\\\n+    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n+\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n+        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n+\\\\\\\\n+    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n+    aws_http_message_release(message);\\\\\\\\n+    aws_s3_client_release(client);\\\\\\\\n+    aws_s3_tester_clean_up(&tester);\\\\\\\\n+\\\\\\\\n+    return AWS_OP_SUCCESS;\\\\\\\\n+}\\\\\"\\\\n  }\\\\n]\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Let me get the content of the file that was modified to better understand the changes:\"},{\"type\":\"tool_use\",\"name\":\"github-get_file_contents\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"path\":\"tests/s3_data_plane_tests.c\",\"branch\":\"dummy-delete-me\"},\"id\":\"toolu_bdrk_012zMwWDT5hcHEXh1grmo42J\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_012zMwWDT5hcHEXh1grmo42J\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\n  \\\\\"name\\\\\": \\\\\"s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"path\\\\\": \\\\\"tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"sha\\\\\": \\\\\"dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n  \\\\\"size\\\\\": 319574,\\\\n  \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests/s3_data_plane_tests.c?ref=dummy-delete-me\\\\\",\\\\n  \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"git_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/git/blobs/dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n  \\\\\"download_url\\\\\": \\\\\"https://raw.githubusercontent.com/awslabs/aws-c-s3/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"type\\\\\": \\\\\"file\\\\\",\\\\n  \\\\\"content\\\\\": \\\\\"/**\\\\\\\\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\\\\\\\\n * SPDX-License-Identifier: Apache-2.0.\\\\\\\\n */\\\\\\\\n\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_checksums.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\"\\\\\\\\n#include <aws/common/byte_buf.h>\\\\\\\\n#include <aws/common/clock.h>\\\\\\\\n#include <aws/common/common.h>\\\\\\\\n#include <aws/common/encoding.h>\\\\\\\\n#include <aws/common/environment.h>\\\\\\\\n#include <aws/common/ref_count.h>\\\\\\\\n#include <aws/http/request_response.h>\\\\\\\\n#include <aws/http/status_code.h>\\\\\\\\n#include <aws/io/channel_bootstrap.h>\\\\\\\\n#include <aws/io/event_loop.h>\\\\\\\\n#include <aws/io/host_resolver.h>\\\\\\\\n#include <aws/io/stream.h>\\\\\\\\n#include <aws/io/tls_channel_handler.h>\\\\\\\\n#include <aws/io/uri.h>\\\\\\\\n#include <aws/testing/aws_test_harness.h>\\\\\\\\n#include <aws/testing/stream_tester.h>\\\\\\\\n#include <inttypes.h>\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_create_destroy, s_test_s3_client_create_destroy)\\\\\\\\nstatic int s_test_s3_client_create_destroy(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_create_error, s_test_s3_client_create_error)\\\\\\\\nstatic int s_test_s3_client_create_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    struct aws_http_proxy_options proxy_options = {\\\\\\\\n        .connection_type = AWS_HPCT_HTTP_LEGACY,\\\\\\\\n        .host = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"localhost\\\\\\\\\\\\\"),\\\\\\\\n        .port = 8899,\\\\\\\\n    };\\\\\\\\n    client_config.proxy_options = &proxy_options;\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_client_create_error_with_invalid_memory_limit_config,\\\\\\\\n    s_test_s3_client_create_error_with_invalid_memory_limit_config)\\\\\\\\nstatic int s_test_s3_client_create_error_with_invalid_memory_limit_config(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    client_config.memory_limit_in_bytes = 100;\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n    client_config.memory_limit_in_bytes = GB_TO_BYTES(1);\\\\\\\\n    client_config.max_part_size = GB_TO_BYTES(2);\\\\\\\\n    client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_client_create_error_with_invalid_network_interface,\\\\\\\\n    s_test_s3_client_create_error_with_invalid_network_interface)\\\\\\\\nstatic int s_test_s3_client_create_error_with_invalid_network_interface(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor *interface_names_array = aws_mem_calloc(allocator, 1, sizeof(struct aws_byte_cursor));\\\\\\\\n    interface_names_array[0] = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"invalid-nic\\\\\\\\\\\\\");\\\\\\\\n    client_config.network_interface_names_array = interface_names_array;\\\\\\\\n    client_config.num_network_interface_names = 1;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_mem_release(allocator, interface_names_array);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_monitoring_options_override, s_test_s3_client_monitoring_options_override)\\\\\\\\nstatic int s_test_s3_client_monitoring_options_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_http_connection_monitoring_options monitoring_options = {.minimum_throughput_bytes_per_second = 3000};\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.monitoring_options = &monitoring_options};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        client->monitoring_options.minimum_throughput_bytes_per_second ==\\\\\\\\n        client_config.monitoring_options->minimum_throughput_bytes_per_second);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_proxy_ev_settings_override, s_test_s3_client_proxy_ev_settings_override)\\\\\\\\nstatic int s_test_s3_client_proxy_ev_settings_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_tls_connection_options tls_conn_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_conn_options);\\\\\\\\n\\\\\\\\n    struct proxy_env_var_settings proxy_ev_settings = {\\\\\\\\n        .env_var_type = AWS_HPEV_ENABLE,\\\\\\\\n        .tls_options = &tls_conn_options,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.proxy_ev_settings = &proxy_ev_settings};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->proxy_ev_settings->env_var_type == client_config.proxy_ev_settings->env_var_type);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_tcp_keep_alive_options_override, s_test_s3_client_tcp_keep_alive_options_override)\\\\\\\\nstatic int s_test_s3_client_tcp_keep_alive_options_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tcp_keep_alive_options keep_alive_options = {.keep_alive_interval_sec = 20};\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.tcp_keep_alive_options = &keep_alive_options};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        client->tcp_keep_alive_options->keep_alive_interval_sec ==\\\\\\\\n        client_config.tcp_keep_alive_options->keep_alive_interval_sec);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_max_active_connections_override, s_test_s3_client_max_active_connections_override)\\\\\\\\nstatic int s_test_s3_client_max_active_connections_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .max_active_connections_override = 10,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->max_active_connections_override == client_config.max_active_connections_override);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_byo_crypto_no_options, s_test_s3_client_byo_crypto_no_options)\\\\\\\\nstatic int s_test_s3_client_byo_crypto_no_options(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .tls_mode = AWS_MR_TLS_ENABLED,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_last_error() == AWS_ERROR_INVALID_ARGUMENT);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_byo_crypto_with_options, s_test_s3_client_byo_crypto_with_options)\\\\\\\\nstatic int s_test_s3_client_byo_crypto_with_options(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_conn_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_conn_options);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n    client_config.tls_connection_options = &tls_conn_options;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nsize_t s_test_max_active_connections_host_count = 0;\\\\\\\\n\\\\\\\\nsize_t s_test_get_max_active_connections_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    return s_test_max_active_connections_host_count;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_get_max_active_connections, s_test_s3_client_get_max_active_connections)\\\\\\\\nstatic int s_test_s3_client_get_max_active_connections(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)allocator;\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_client_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_client_bootstrap);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    *((uint32_t *)&mock_client->max_active_connections_override) = 0;\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = 100;\\\\\\\\n    mock_client->client_bootstrap = &mock_client_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_get_max_active_connections_host_address_count;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_requests[AWS_S3_META_REQUEST_TYPE_MAX];\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n        /* Setup test data. */\\\\\\\\n        mock_meta_requests[i] = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n        mock_meta_requests[i]->type = i;\\\\\\\\n        mock_meta_requests[i]->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    s_test_max_active_connections_host_count = 2;\\\\\\\\n\\\\\\\\n    /* Behavior should not be affected by max_active_connections_override since it is 0, and should just be in relation\\\\\\\\n     * to ideal-connection-count. */\\\\\\\\n    {\\\\\\\\n        ASSERT_TRUE(aws_s3_client_get_max_active_connections(mock_client, NULL) == mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->ideal_connection_count);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Max active connections override should now cap the calculated amount of active connections. */\\\\\\\\n    {\\\\\\\\n        *((uint32_t *)&mock_client->max_active_connections_override) = 3;\\\\\\\\n\\\\\\\\n        /* Assert that override is low enough to have effect */\\\\\\\\n        ASSERT_TRUE(mock_client->max_active_connections_override < mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(\\\\\\\\n            aws_s3_client_get_max_active_connections(mock_client, NULL) ==\\\\\\\\n            mock_client->max_active_connections_override);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(mock_client->max_active_connections_override < mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->max_active_connections_override);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Max active connections override should be ignored since the calculated amount of max connections is less. */\\\\\\\\n    {\\\\\\\\n        *((uint32_t *)&mock_client->max_active_connections_override) = 100000;\\\\\\\\n\\\\\\\\n        /* Assert that override is NOT low enough to have effect */\\\\\\\\n        ASSERT_TRUE(mock_client->max_active_connections_override > mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(aws_s3_client_get_max_active_connections(mock_client, NULL) == mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(mock_client->max_active_connections_override > mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->ideal_connection_count);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n        mock_meta_requests[i] = aws_s3_meta_request_release(mock_meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_request_create_destroy, s_test_s3_request_create_destroy)\\\\\\\\nstatic int s_test_s3_request_create_destroy(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const int request_tag = 1234;\\\\\\\\n    const enum aws_s3_request_type request_type = AWS_S3_REQUEST_TYPE_LIST_PARTS;\\\\\\\\n    const uint32_t part_number = 5678;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n    meta_request->client = aws_s3_client_acquire(client);\\\\\\\\n\\\\\\\\n    struct aws_http_message *request_message = aws_s3_tester_dummy_http_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(request_message != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n        meta_request, request_tag, request_type, part_number, AWS_S3_REQUEST_FLAG_RECORD_RESPONSE_HEADERS);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->meta_request == meta_request);\\\\\\\\n    ASSERT_TRUE(request->part_number == part_number);\\\\\\\\n    ASSERT_TRUE(request->request_tag == request_tag);\\\\\\\\n    ASSERT_TRUE(request->request_type == request_type);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"ListParts\\\\\\\\\\\\\", aws_string_c_str(request->operation_name));\\\\\\\\n    ASSERT_TRUE(request->record_response_headers == true);\\\\\\\\n\\\\\\\\n    aws_s3_request_setup_send_data(request, request_message);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->send_data.message != NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers == NULL);\\\\\\\\n\\\\\\\\n    request->send_data.response_headers = aws_http_headers_new(allocator);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers != NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.metrics != NULL);\\\\\\\\n    request->send_data.metrics = aws_s3_request_metrics_release(request->send_data.metrics);\\\\\\\\n\\\\\\\\n    aws_s3_request_clean_up_send_data(request);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->send_data.message == NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers == NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_status == 0);\\\\\\\\n\\\\\\\\n    aws_s3_request_release(request);\\\\\\\\n    aws_http_message_release(request_message);\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct s3_test_body_streaming_user_data {\\\\\\\\n    struct aws_s3_tester *tester;\\\\\\\\n    struct aws_allocator *allocator;\\\\\\\\n    uint64_t expected_range_start;\\\\\\\\n    uint64_t received_body_size;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic int s_s3_meta_request_test_body_streaming_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)body;\\\\\\\\n    (void)range_start;\\\\\\\\n\\\\\\\\n    struct s3_test_body_streaming_user_data *body_streaming_user_data = user_data;\\\\\\\\n\\\\\\\\n    body_streaming_user_data->received_body_size += body->len;\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_streaming_user_data->expected_range_start == range_start);\\\\\\\\n    body_streaming_user_data->expected_range_start += body->len;\\\\\\\\n\\\\\\\\n    aws_s3_tester_inc_counter1(body_streaming_user_data->tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test the meta request body streaming functionality. */\\\\\\\\nAWS_TEST_CASE(test_s3_meta_request_body_streaming, s_test_s3_meta_request_body_streaming)\\\\\\\\nstatic int s_test_s3_meta_request_body_streaming(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const uint32_t part_range0_start = 1;\\\\\\\\n    const uint32_t part_range0_end = part_range0_start + 4;\\\\\\\\n\\\\\\\\n    const uint32_t part_range1_start = part_range0_end + 1;\\\\\\\\n    const uint32_t part_range1_end = part_range1_start + 4;\\\\\\\\n\\\\\\\\n    const size_t request_response_body_size = 16;\\\\\\\\n\\\\\\\\n    const uint64_t total_object_size = (uint64_t)part_range1_end * request_response_body_size;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf response_body_source_buffer;\\\\\\\\n    aws_byte_buf_init(&response_body_source_buffer, allocator, request_response_body_size);\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor test_byte_cursor = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"0\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < request_response_body_size; ++i) {\\\\\\\\n        aws_byte_buf_append(&response_body_source_buffer, &test_byte_cursor);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct s3_test_body_streaming_user_data body_streaming_user_data = {\\\\\\\\n        .tester = &tester,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_event_loop_group *event_loop_group = aws_event_loop_group_new_default(allocator, 0, NULL);\\\\\\\\n    meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    meta_request->user_data = &body_streaming_user_data;\\\\\\\\n    *((size_t *)&meta_request->part_size) = request_response_body_size;\\\\\\\\n    meta_request->body_callback = s_s3_meta_request_test_body_streaming_callback;\\\\\\\\n    meta_request->io_event_loop = aws_event_loop_group_get_next_loop(event_loop_group);\\\\\\\\n\\\\\\\\n    /* Queue the first range of parts in order. Each part should be flushed one-by-one. */\\\\\\\\n    {\\\\\\\\n        for (uint32_t part_number = part_range0_start; part_number <= part_range0_end; ++part_number) {\\\\\\\\n            struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n                meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_number, 0 /*flags*/);\\\\\\\\n\\\\\\\\n            aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n                0ULL,\\\\\\\\n                total_object_size - 1,\\\\\\\\n                request_response_body_size /*part_size*/,\\\\\\\\n                (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n                part_number,\\\\\\\\n                &request->part_range_start,\\\\\\\\n                &request->part_range_end);\\\\\\\\n\\\\\\\\n            aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n            aws_s3_tester_set_counter1_desired(&tester, part_number);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n            ASSERT_TRUE(aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == 0);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_tester_wait_for_counters(&tester);\\\\\\\\n\\\\\\\\n            aws_s3_request_release(request);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_set_counter1_desired(&tester, part_range1_end);\\\\\\\\n\\\\\\\\n    /* Queue parts for second range, but skip over the first part.*/\\\\\\\\n    {\\\\\\\\n        uint32_t num_parts_queued = 0;\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(part_range1_start != part_range1_end);\\\\\\\\n\\\\\\\\n        for (uint32_t part_number = part_range1_start + 1; part_number <= part_range1_end; ++part_number) {\\\\\\\\n            struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n                meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_number, 0 /*flags*/);\\\\\\\\n\\\\\\\\n            aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n                0ULL,\\\\\\\\n                total_object_size - 1,\\\\\\\\n                request_response_body_size /*part_size*/,\\\\\\\\n                (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n                part_number,\\\\\\\\n                &request->part_range_start,\\\\\\\\n                &request->part_range_end);\\\\\\\\n\\\\\\\\n            aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n            aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n            aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_request_release(request);\\\\\\\\n            ++num_parts_queued;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        ASSERT_TRUE(\\\\\\\\n            aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == num_parts_queued);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Stream the last part of the body, which should flush the priority queue. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n            meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_range1_start, 0 /*flags*/);\\\\\\\\n\\\\\\\\n        aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n            0ULL,\\\\\\\\n            total_object_size - 1,\\\\\\\\n            request_response_body_size /*part_size*/,\\\\\\\\n            (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n            part_range1_start,\\\\\\\\n            &request->part_range_start,\\\\\\\\n            &request->part_range_end);\\\\\\\\n\\\\\\\\n        aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        ASSERT_TRUE(aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == 0);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n        aws_s3_request_release(request);\\\\\\\\n\\\\\\\\n        aws_s3_tester_wait_for_counters(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_streaming_user_data.received_body_size == (request_response_body_size * part_range1_end));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_event_loop_group_release(event_loop_group);\\\\\\\\n    aws_byte_buf_clean_up(&response_body_source_buffer);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test aws_s3_client_queue_requests_threaded and aws_s3_client_dequeue_request_threaded */\\\\\\\\nAWS_TEST_CASE(test_s3_client_queue_requests, s_test_s3_client_queue_requests)\\\\\\\\nstatic int s_test_s3_client_queue_requests(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *pivot_request = aws_s3_request_new(mock_meta_request, 0, 0, 0, 0);\\\\\\\\n\\\\\\\\n    struct aws_linked_list pivot_request_list;\\\\\\\\n    aws_linked_list_init(&pivot_request_list);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *requests[] = {\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    const uint32_t num_requests = AWS_ARRAY_SIZE(requests);\\\\\\\\n\\\\\\\\n    struct aws_linked_list request_list;\\\\\\\\n    aws_linked_list_init(&request_list);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        aws_linked_list_push_back(&pivot_request_list, &pivot_request->node);\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &pivot_request_list, false);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 1);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n            aws_linked_list_push_back(&request_list, &requests[i]->node);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Move the requests to the back of the queue. */\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &request_list, false);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&request_list));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests + 1));\\\\\\\\n    ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        /* The first request should be the pivot request since the other requests were pushed to the back. */\\\\\\\\n        struct aws_s3_request *first_request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n        ASSERT_TRUE(first_request == pivot_request);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == num_requests);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        struct aws_s3_request *request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(request == requests[i]);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests - (i + 1)));\\\\\\\\n\\\\\\\\n        if (i < num_requests - 1) {\\\\\\\\n            ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        aws_linked_list_push_back(&pivot_request_list, &pivot_request->node);\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &pivot_request_list, false);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 1);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n            aws_linked_list_push_back(&request_list, &requests[i]->node);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Move the requests to the front of the queue. */\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &request_list, true);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&request_list));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests + 1));\\\\\\\\n    ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        struct aws_s3_request *request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(request == requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        /* The last request should be the pivot request since the other requests were pushed to the front. */\\\\\\\\n        struct aws_s3_request *last_request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n        ASSERT_TRUE(last_request == pivot_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        aws_s3_request_release(requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_request_release(pivot_request);\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct test_work_meta_request_update_user_data {\\\\\\\\n    bool has_work_remaining;\\\\\\\\n    uint32_t num_prepares;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic bool s_s3_test_work_meta_request_update(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    uint32_t flags,\\\\\\\\n    struct aws_s3_request **out_request) {\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data *user_data = meta_request->user_data;\\\\\\\\n\\\\\\\\n    if (out_request) {\\\\\\\\n        if (user_data->has_work_remaining) {\\\\\\\\n            *out_request = aws_s3_request_new(meta_request, 0, 0, 0, 0);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return user_data->has_work_remaining;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_work_meta_request_schedule_prepare_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    aws_s3_meta_request_prepare_request_callback_fn *callback,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)request;\\\\\\\\n    (void)callback;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data *test_user_data = meta_request->user_data;\\\\\\\\n    ++test_user_data->num_prepares;\\\\\\\\n\\\\\\\\n    aws_s3_request_release(request);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic size_t s_test_s3_update_meta_request_trigger_prepare_host_address_count = 0;\\\\\\\\n\\\\\\\\nstatic size_t s_test_s3_update_meta_request_trigger_prepare_get_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n    return s_test_s3_update_meta_request_trigger_prepare_host_address_count;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_validate_prepared_requests(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    size_t expected_num_being_prepared,\\\\\\\\n    struct aws_s3_meta_request *meta_request_with_work,\\\\\\\\n    struct aws_s3_meta_request *meta_request_without_work) {\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->threaded_data.request_queue_size == 0);\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&client->threaded_data.request_queue));\\\\\\\\n    ASSERT_TRUE(client->threaded_data.num_requests_being_prepared == expected_num_being_prepared);\\\\\\\\n    ASSERT_TRUE(aws_atomic_load_int(&client->stats.num_requests_in_flight) == expected_num_being_prepared);\\\\\\\\n\\\\\\\\n    uint32_t num_meta_requests_in_list = 0;\\\\\\\\n    bool meta_request_with_work_found = false;\\\\\\\\n\\\\\\\\n    for (struct aws_linked_list_node *node = aws_linked_list_begin(&client->threaded_data.meta_requests);\\\\\\\\n         node != aws_linked_list_end(&client->threaded_data.meta_requests);\\\\\\\\n         node = aws_linked_list_next(node)) {\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request *meta_request =\\\\\\\\n            AWS_CONTAINER_OF(node, struct aws_s3_meta_request, client_process_work_threaded_data);\\\\\\\\n\\\\\\\\n        if (meta_request == meta_request_with_work) {\\\\\\\\n            meta_request_with_work_found = true;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_request != meta_request_without_work);\\\\\\\\n\\\\\\\\n        ++num_meta_requests_in_list;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_with_work_found);\\\\\\\\n    ASSERT_TRUE(num_meta_requests_in_list == 1);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the client will prepare requests correctly. */\\\\\\\\nAWS_TEST_CASE(test_s3_update_meta_requests_trigger_prepare, s_test_s3_update_meta_requests_trigger_prepare)\\\\\\\\nstatic int s_test_s3_update_meta_requests_trigger_prepare(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_bootstrap);\\\\\\\\n\\\\\\\\n    const uint32_t ideal_connection_count = 100;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    mock_client->client_bootstrap = &mock_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_s3_update_meta_request_trigger_prepare_get_host_address_count;\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = ideal_connection_count;\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.meta_requests);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request_without_work = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request_without_work->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    mock_meta_request_without_work->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data mock_meta_request_without_work_data = {\\\\\\\\n        .has_work_remaining = false,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    mock_meta_request_without_work->user_data = &mock_meta_request_without_work_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *meta_request_without_work_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request_without_work, NULL);\\\\\\\\n    meta_request_without_work_vtable->update = s_s3_test_work_meta_request_update;\\\\\\\\n    meta_request_without_work_vtable->schedule_prepare_request = s_s3_test_work_meta_request_schedule_prepare_request;\\\\\\\\n\\\\\\\\n    /* Intentionally push this meta request first to test that it\\'s properly removed from the list. */\\\\\\\\n    aws_linked_list_push_back(\\\\\\\\n        &mock_client->threaded_data.meta_requests,\\\\\\\\n        &mock_meta_request_without_work->client_process_work_threaded_data.node);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_acquire(mock_meta_request_without_work);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request_with_work = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request_with_work->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    struct test_work_meta_request_update_user_data mock_meta_request_with_work_data = {\\\\\\\\n        .has_work_remaining = true,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    mock_meta_request_with_work->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n    mock_meta_request_with_work->user_data = &mock_meta_request_with_work_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *mock_meta_request_with_work_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request_with_work, NULL);\\\\\\\\n    mock_meta_request_with_work_vtable->update = s_s3_test_work_meta_request_update;\\\\\\\\n    mock_meta_request_with_work_vtable->schedule_prepare_request = s_s3_test_work_meta_request_schedule_prepare_request;\\\\\\\\n\\\\\\\\n    aws_linked_list_push_back(\\\\\\\\n        &mock_client->threaded_data.meta_requests,\\\\\\\\n        &mock_meta_request_with_work->client_process_work_threaded_data.node);\\\\\\\\n    aws_s3_meta_request_acquire(mock_meta_request_with_work);\\\\\\\\n\\\\\\\\n    /* With no known addresses, the amount of requests that can be prepared should be lower. */\\\\\\\\n    {\\\\\\\\n        s_test_s3_update_meta_request_trigger_prepare_host_address_count = 0;\\\\\\\\n        aws_s3_client_update_meta_requests_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(s_validate_prepared_requests(\\\\\\\\n            mock_client, g_min_num_connections, mock_meta_request_with_work, mock_meta_request_without_work));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* When the number of known addresses is 1+, the max number of requests should be reached. */\\\\\\\\n    {\\\\\\\\n        const uint32_t max_requests_prepare = aws_s3_client_get_max_requests_prepare(mock_client);\\\\\\\\n\\\\\\\\n        s_test_s3_update_meta_request_trigger_prepare_host_address_count = 1;\\\\\\\\n        aws_s3_client_update_meta_requests_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(s_validate_prepared_requests(\\\\\\\\n            mock_client, max_requests_prepare, mock_meta_request_with_work, mock_meta_request_without_work));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    while (!aws_linked_list_empty(&mock_client->threaded_data.meta_requests)) {\\\\\\\\n        struct aws_linked_list_node *meta_request_node =\\\\\\\\n            aws_linked_list_pop_front(&mock_client->threaded_data.meta_requests);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request *meta_request =\\\\\\\\n            AWS_CONTAINER_OF(meta_request_node, struct aws_s3_meta_request, client_process_work_threaded_data);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_release(meta_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request_without_work);\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request_with_work);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct s3_test_update_connections_finish_result_user_data {\\\\\\\\n    struct aws_s3_request *finished_request;\\\\\\\\n    struct aws_s3_request *create_connection_request;\\\\\\\\n\\\\\\\\n    uint32_t finished_request_call_counter;\\\\\\\\n    uint32_t create_connection_request_call_counter;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic void s_s3_test_meta_request_has_finish_result_finished_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    AWS_ASSERT(request);\\\\\\\\n    (void)error_code;\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data *user_data = meta_request->user_data;\\\\\\\\n    user_data->finished_request = request;\\\\\\\\n    ++user_data->finished_request_call_counter;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_meta_request_has_finish_result_client_create_connection_for_request(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    struct aws_s3_request *request) {\\\\\\\\n    (void)client;\\\\\\\\n    (void)request;\\\\\\\\n    AWS_ASSERT(client);\\\\\\\\n    AWS_ASSERT(request);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = request->meta_request;\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data *user_data = meta_request->user_data;\\\\\\\\n    user_data->create_connection_request = request;\\\\\\\\n    ++user_data->create_connection_request_call_counter;\\\\\\\\n}\\\\\\\\n\\\\\\\\nsize_t s_test_update_conns_finish_result_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    return 1;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the client will correctly discard requests for meta requests that are trying to finish. */\\\\\\\\nAWS_TEST_CASE(test_s3_client_update_connections_finish_result, s_test_s3_client_update_connections_finish_result)\\\\\\\\nstatic int s_test_s3_client_update_connections_finish_result(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_client_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_client_bootstrap);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    mock_client->client_bootstrap = &mock_client_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_update_conns_finish_result_host_address_count;\\\\\\\\n    mock_client->vtable->create_connection_for_request =\\\\\\\\n        s_s3_test_meta_request_has_finish_result_client_create_connection_for_request;\\\\\\\\n\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = 1;\\\\\\\\n\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data test_update_connections_finish_result_user_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_update_connections_finish_result_user_data);\\\\\\\\n\\\\\\\\n    /* Put together a mock meta request that is finished. */\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    mock_meta_request->synced_data.finish_result_set = true;\\\\\\\\n    mock_meta_request->user_data = &test_update_connections_finish_result_user_data;\\\\\\\\n    mock_meta_request->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *mock_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request, NULL);\\\\\\\\n    mock_meta_request_vtable->finished_request = s_s3_test_meta_request_has_finish_result_finished_request;\\\\\\\\n\\\\\\\\n    /* Verify that the request does not get sent because the meta request has finish-result. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request = aws_s3_request_new(mock_meta_request, 0, 0, 0, 0);\\\\\\\\n        aws_linked_list_push_back(&mock_client->threaded_data.request_queue, &request->node);\\\\\\\\n        ++mock_client->threaded_data.request_queue_size;\\\\\\\\n\\\\\\\\n        aws_s3_client_update_connections_threaded(mock_client);\\\\\\\\n\\\\\\\\n        /* Request should still have been dequeued, but immediately passed to the meta request finish function. */\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n        ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request == request);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request_call_counter == 1);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request == NULL);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request_call_counter == 0);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    AWS_ZERO_STRUCT(test_update_connections_finish_result_user_data);\\\\\\\\n\\\\\\\\n    /* Verify that a request with the \\'always send\\' flag still gets sent when the meta request has a finish-result. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request =\\\\\\\\n            aws_s3_request_new(mock_meta_request, 0, 0, 0, AWS_S3_REQUEST_FLAG_ALWAYS_SEND);\\\\\\\\n        aws_linked_list_push_back(&mock_client->threaded_data.request_queue, &request->node);\\\\\\\\n        ++mock_client->threaded_data.request_queue_size;\\\\\\\\n\\\\\\\\n        aws_s3_client_update_connections_threaded(mock_client);\\\\\\\\n\\\\\\\\n        /* Request should have been dequeued, and then sent on a connection. */\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n        ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request == NULL);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request_call_counter == 0);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request == request);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request_call_counter == 1);\\\\\\\\n\\\\\\\\n        aws_s3_request_release(request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_get_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    enum aws_s3_client_tls_usage tls_usage,\\\\\\\\n    uint32_t extra_meta_request_flag,\\\\\\\\n    struct aws_byte_cursor s3_path) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_connection_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_connection_options);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    struct aws_tls_ctx_options tls_context_options;\\\\\\\\n    aws_tls_ctx_options_init_default_client(&tls_context_options, allocator);\\\\\\\\n\\\\\\\\n    struct aws_tls_ctx *context = aws_tls_client_ctx_new(allocator, &tls_context_options);\\\\\\\\n    aws_tls_connection_options_init_from_ctx(&tls_connection_options, context);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    struct aws_string *endpoint =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n    struct aws_byte_cursor endpoint_cursor = aws_byte_cursor_from_string(endpoint);\\\\\\\\n\\\\\\\\n    tls_connection_options.server_name = aws_string_new_from_cursor(allocator, &endpoint_cursor);\\\\\\\\n\\\\\\\\n    switch (tls_usage) {\\\\\\\\n        case AWS_S3_TLS_ENABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n            client_config.tls_connection_options = &tls_connection_options;\\\\\\\\n            break;\\\\\\\\n        case AWS_S3_TLS_DISABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_DISABLED;\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS | extra_meta_request_flag;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_get_object_meta_request(&tester, client, s3_path, flags, NULL));\\\\\\\\n\\\\\\\\n    aws_string_destroy(endpoint);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    aws_tls_ctx_release(context);\\\\\\\\n    aws_tls_connection_options_clean_up(&tls_connection_options);\\\\\\\\n    aws_tls_ctx_options_clean_up(&tls_context_options);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_disabled, s_test_s3_get_object_tls_disabled)\\\\\\\\nstatic int s_test_s3_get_object_tls_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_DISABLED, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_enabled, s_test_s3_get_object_tls_enabled)\\\\\\\\nstatic int s_test_s3_get_object_tls_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_ENABLED, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_default, s_test_s3_get_object_tls_default)\\\\\\\\nstatic int s_test_s3_get_object_tls_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_DEFAULT, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_no_signing, s_test_s3_no_signing)\\\\\\\\nstatic int s_test_s3_no_signing(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_signing_override, s_test_s3_signing_override)\\\\\\\\nstatic int s_test_s3_signing_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    /* Getting without signing should fail since the client has no signing set up. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request.*/\\\\\\\\n        struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request(&tester, client, &options, &meta_request_test_results, 0));\\\\\\\\n        ASSERT_TRUE(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0) != AWS_OP_SUCCESS);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Getting with signing should succeed if we set up signing on the meta request. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n        options.signing_config = &tester.default_signing_config;\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request. */\\\\\\\\n        struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n            &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_less_than_part_size, s_test_s3_get_object_less_than_part_size)\\\\\\\\nstatic int s_test_s3_get_object_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_get_object_meta_request(\\\\\\\\n        &tester, client, g_pre_existing_object_1MB, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_with_part_remainder, s_test_s3_put_object_with_part_remainder)\\\\\\\\nstatic int s_test_s3_put_object_with_part_remainder(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Object size meant to be one megabyte larger than the part size of the client. */\\\\\\\\n                .object_size_mb = 6,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multiple, s_test_s3_get_object_multiple)\\\\\\\\nstatic int s_test_s3_get_object_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_requests[4];\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results[4];\\\\\\\\n    size_t num_meta_requests = AWS_ARRAY_SIZE(meta_requests);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(num_meta_requests == AWS_ARRAY_SIZE(meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        /* Put together a simple S3 Get Object request. */\\\\\\\\n        struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n            allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results[i], allocator);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results[i]));\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request. */\\\\\\\\n        meta_requests[i] = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_requests[i] != NULL);\\\\\\\\n\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        meta_requests[i] = aws_s3_meta_request_release(meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        aws_s3_tester_validate_get_object_results(&meta_request_test_results[i], 0);\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multiple_serial, s_test_s3_get_object_multiple_serial)\\\\\\\\nstatic int s_test_s3_get_object_multiple_serial(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-10MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < 4; ++i) {\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Sleep for some time to wait for the cleanup task to run */\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(7, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    /* BEGIN CRITICAL SECTION */\\\\\\\\n    aws_s3_client_lock_synced_data(client);\\\\\\\\n\\\\\\\\n    AWS_ASSERT(client->synced_data.num_endpoints_allocated == 0);\\\\\\\\n\\\\\\\\n    aws_s3_client_unlock_synced_data(client);\\\\\\\\n    /* END CRITICAL SECTION */\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path, s_test_s3_get_object_file_path)\\\\\\\\nstatic int s_test_s3_get_object_file_path(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_create_new, s_test_s3_get_object_file_path_create_new)\\\\\\\\nstatic int s_test_s3_get_object_file_path_create_new(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_CREATE_NEW,\\\\\\\\n                .pre_exist_file_length = 10,\\\\\\\\n                .recv_file_delete_on_failure = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_RECV_FILE_ALREADY_EXISTS, aws_last_error());\\\\\\\\n\\\\\\\\n    /* The request failed without invoking the finish callback. Reset the finish and shutdown count */\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_shutdown_count);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n    tester.synced_data.desired_meta_request_shutdown_count = 0;\\\\\\\\n    tester.synced_data.desired_meta_request_finish_count = 0;\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    get_options.validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS;\\\\\\\\n    get_options.get_options.pre_exist_file_length = 0;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_append, s_test_s3_get_object_file_path_append)\\\\\\\\nstatic int s_test_s3_get_object_file_path_append(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    uint64_t pre_exist_file_length = 10;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_CREATE_OR_APPEND,\\\\\\\\n                .pre_exist_file_length = pre_exist_file_length,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(pre_exist_file_length + MB_TO_BYTES(1), meta_request_test_results.received_file_size);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), meta_request_test_results.progress.total_bytes_transferred);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_to_position, s_test_s3_get_object_file_path_to_position)\\\\\\\\nstatic int s_test_s3_get_object_file_path_to_position(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    uint64_t pre_exist_file_length = 10;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_WRITE_TO_POSITION,\\\\\\\\n                .pre_exist_file_length = 0,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_RECV_FILE_NOT_FOUND, aws_last_error());\\\\\\\\n\\\\\\\\n    /* The request failed without invoking the finish callback. Reset the finish and shutdown count */\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_shutdown_count);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n    tester.synced_data.desired_meta_request_shutdown_count = 0;\\\\\\\\n    tester.synced_data.desired_meta_request_finish_count = 0;\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    get_options.validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS;\\\\\\\\n    get_options.get_options.pre_exist_file_length = pre_exist_file_length;\\\\\\\\n    get_options.get_options.recv_file_position = 20;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(\\\\\\\\n        get_options.get_options.recv_file_position + MB_TO_BYTES(1), meta_request_test_results.received_file_size);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), meta_request_test_results.progress.total_bytes_transferred);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_empty_object, s_test_s3_get_object_empty_default)\\\\\\\\nstatic int s_test_s3_get_object_empty_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    return (s_test_s3_get_object_helper(allocator, AWS_S3_TLS_ENABLED, 0, g_pre_existing_empty_object));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_sse_kms, s_test_s3_get_object_sse_kms)\\\\\\\\nstatic int s_test_s3_get_object_sse_kms(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Keep TLS enabled for SSE related download, or it will fail. */\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, AWS_S3_TESTER_SEND_META_REQUEST_SSE_KMS, g_pre_existing_object_kms_10MB);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_sse_aes256, s_test_s3_get_object_sse_aes256)\\\\\\\\nstatic int s_test_s3_get_object_sse_aes256(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Keep TLS enabled for SSE related download, or it will fail. */\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, AWS_S3_TESTER_SEND_META_REQUEST_SSE_AES256, g_pre_existing_object_aes256_10MB);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Assert that GetObject can download an object whose body is XML identical to an \\\\\\\\\\\\\"async error\\\\\\\\\\\\\" aka \\\\\\\\\\\\\"200 error\\\\\\\\\\\\\":\\\\\\\\n * <?xml version=\\\\\\\\\\\\\"1.0\\\\\\\\\\\\\" encoding=\\\\\\\\\\\\\"UTF-8\\\\\\\\\\\\\"?>\\\\\\\\\\\\\\\\n<Error><Code>InternalError</Code>... */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_looks_like_async_error_xml, s_test_s3_get_object_looks_like_async_error_xml)\\\\\\\\nstatic int s_test_s3_get_object_looks_like_async_error_xml(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, 0 /*extra_meta_request_flag*/, g_pre_existing_object_async_error_xml);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Same as above, but send the \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\" via AWS_S3_META_REQUEST_TYPE_DEFAULT\\\\\\\\n * (instead of the typical AWS_S3_META_REQUEST_TYPE_GET_OBJECT) */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_default_get_object_looks_like_async_error_xml,\\\\\\\\n    s_test_s3_default_get_object_looks_like_async_error_xml)\\\\\\\\nstatic int s_test_s3_default_get_object_looks_like_async_error_xml(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_async_error_xml,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test read-backpressure functionality by repeatedly:\\\\\\\\n * - letting the download stall\\\\\\\\n * - incrementing the read window\\\\\\\\n * - repeat...\\\\\\\\n */\\\\\\\\nstatic int s_apply_backpressure_until_meta_request_finish(\\\\\\\\n    struct aws_s3_tester *tester,\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results,\\\\\\\\n    size_t part_size,\\\\\\\\n    size_t window_initial_size,\\\\\\\\n    uint64_t window_increment_size) {\\\\\\\\n\\\\\\\\n    /* Remember the last time something happened (we received download data, or incremented read window) */\\\\\\\\n    uint64_t last_time_something_happened;\\\\\\\\n    ASSERT_SUCCESS(aws_sys_clock_get_ticks(&last_time_something_happened));\\\\\\\\n\\\\\\\\n    /* To ensure that backpressure is working, we wait a bit after download stalls\\\\\\\\n     * before incrementing the read window again.\\\\\\\\n     * This number also controls the max time we wait for bytes to start arriving\\\\\\\\n     * after incrementing the window.\\\\\\\\n     * If the magic number is too high the test will be slow,\\\\\\\\n     * if it\\'s too low the test will fail on slow networks */\\\\\\\\n    const uint64_t wait_duration_with_nothing_happening =\\\\\\\\n        aws_timestamp_convert(3, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL);\\\\\\\\n\\\\\\\\n    uint64_t accumulated_window_increments = window_initial_size;\\\\\\\\n    uint64_t accumulated_data_size = 0;\\\\\\\\n\\\\\\\\n    while (true) {\\\\\\\\n        /* Check if meta-request is done (don\\'t exit yet, we want to check some numbers first...) */\\\\\\\\n        aws_s3_tester_lock_synced_data(tester);\\\\\\\\n        bool done = tester->synced_data.meta_requests_finished != 0;\\\\\\\\n        aws_s3_tester_unlock_synced_data(tester);\\\\\\\\n\\\\\\\\n        /* Check how much data we\\'ve received */\\\\\\\\n        size_t received_body_size_delta = aws_atomic_exchange_int(&test_results->received_body_size_delta, 0);\\\\\\\\n        accumulated_data_size += (uint64_t)received_body_size_delta;\\\\\\\\n\\\\\\\\n        /* Check that we haven\\'t received more data than the window allows.\\\\\\\\n         * TODO: Stop allowing \\\\\\\\\\\\\"hacky wiggle room\\\\\\\\\\\\\". The current implementation\\\\\\\\n         *       may push more bytes to the user (up to 1 part) than they\\'ve asked for. */\\\\\\\\n        uint64_t hacky_wiggle_room = part_size;\\\\\\\\n        uint64_t max_data_allowed = accumulated_window_increments + hacky_wiggle_room;\\\\\\\\n        ASSERT_TRUE(accumulated_data_size <= max_data_allowed, \\\\\\\\\\\\\"Received more data than the read window allows\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        /* If we\\'re done, we\\'re done */\\\\\\\\n        if (done) {\\\\\\\\n            break;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Figure out how long it\\'s been since we last received data */\\\\\\\\n        uint64_t current_time;\\\\\\\\n        ASSERT_SUCCESS(aws_sys_clock_get_ticks(&current_time));\\\\\\\\n\\\\\\\\n        if (received_body_size_delta != 0) {\\\\\\\\n            last_time_something_happened = current_time;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        uint64_t duration_since_something_happened = current_time - last_time_something_happened;\\\\\\\\n\\\\\\\\n        /* If it seems like data has stopped flowing... */\\\\\\\\n        if (duration_since_something_happened >= wait_duration_with_nothing_happening) {\\\\\\\\n\\\\\\\\n            /* Assert that data stopped flowing because the window reached 0. */\\\\\\\\n            uint64_t current_window = aws_sub_u64_saturating(accumulated_window_increments, accumulated_data_size);\\\\\\\\n            ASSERT_INT_EQUALS(0, current_window, \\\\\\\\\\\\\"Data stopped flowing but read window isn\\'t 0 yet.\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n            /* Open the window a bit (this resets the \\\\\\\\\\\\\"something happened\\\\\\\\\\\\\" timer */\\\\\\\\n            accumulated_window_increments += window_increment_size;\\\\\\\\n            aws_s3_meta_request_increment_read_window(meta_request, window_increment_size);\\\\\\\\n\\\\\\\\n            last_time_something_happened = current_time;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Sleep a moment, and loop again... */\\\\\\\\n        aws_thread_current_sleep(aws_timestamp_convert(100, AWS_TIMESTAMP_MILLIS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_get_object_backpressure_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    size_t part_size,\\\\\\\\n    size_t window_initial_size,\\\\\\\\n    uint64_t window_increment_size,\\\\\\\\n    bool file_on_disk) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = part_size,\\\\\\\\n        .enable_read_backpressure = true,\\\\\\\\n        .initial_read_window = window_initial_size,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options = {\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .message = message,\\\\\\\\n    };\\\\\\\\n    struct aws_string *filepath_str = NULL;\\\\\\\\n    if (file_on_disk) {\\\\\\\\n        filepath_str = aws_s3_tester_create_file(allocator, g_pre_existing_object_1MB, NULL);\\\\\\\\n        options.recv_filepath = aws_byte_cursor_from_string(filepath_str);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Increment read window bit by bit until all data is downloaded */\\\\\\\\n    ASSERT_SUCCESS(s_apply_backpressure_until_meta_request_finish(\\\\\\\\n        &tester, meta_request, &meta_request_test_results, part_size, window_initial_size, window_increment_size));\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    /* Regression test:\\\\\\\\n     * Ensure that it\\'s safe to call increment-window even after the meta-request has finished */\\\\\\\\n    aws_s3_meta_request_increment_read_window(meta_request, 1024);\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    if (filepath_str) {\\\\\\\\n        aws_file_delete(filepath_str);\\\\\\\\n        aws_string_destroy(filepath_str);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_small_increments, s_test_s3_get_object_backpressure_small_increments)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_small_increments(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments smaller than part-size.\\\\\\\\n     * Only 1 part at a time should be in flight */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_big_increments, s_test_s3_get_object_backpressure_big_increments)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_big_increments(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments larger than part-size.\\\\\\\\n     * Multiple parts should be in flight at a time */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 8;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size * 3;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_initial_size_zero, s_test_s3_get_object_backpressure_initial_size_zero)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_initial_size_zero(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test with initial window size of zero */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 0;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_small_increments_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_small_increments_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_small_increments_recv_filepath(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    /* Test increments smaller than part-size.\\\\\\\\n     * Only 1 part at a time should be in flight */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_big_increments_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_big_increments_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_big_increments_recv_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments larger than part-size.\\\\\\\\n     * Multiple parts should be in flight at a time */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 8;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size * 3;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_initial_size_zero_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_initial_size_zero_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_initial_size_zero_recv_filepath(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    /* Test with initial window size of zero */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 0;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_part, s_test_s3_get_object_part)\\\\\\\\nstatic int s_test_s3_get_object_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/get_object_part_test\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /* GET FILE */\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_NO_VALIDATE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .part_number = 2,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_SUCCESS, meta_request_test_results.finished_error_code);\\\\\\\\n    /* Only one request was made to get the second part of the object */\\\\\\\\n    ASSERT_UINT_EQUALS(1, aws_array_list_length(&meta_request_test_results.synced_data.metrics));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    enum aws_s3_client_tls_usage tls_usage,\\\\\\\\n    uint32_t extra_meta_request_flag) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_connection_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_connection_options);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    struct aws_tls_ctx_options tls_context_options;\\\\\\\\n    aws_tls_ctx_options_init_default_client(&tls_context_options, allocator);\\\\\\\\n\\\\\\\\n    struct aws_tls_ctx *context = aws_tls_client_ctx_new(allocator, &tls_context_options);\\\\\\\\n    aws_tls_connection_options_init_from_ctx(&tls_connection_options, context);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    struct aws_string *endpoint =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n    struct aws_byte_cursor endpoint_cursor = aws_byte_cursor_from_string(endpoint);\\\\\\\\n\\\\\\\\n    tls_connection_options.server_name = aws_string_new_from_cursor(allocator, &endpoint_cursor);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    switch (tls_usage) {\\\\\\\\n        case AWS_S3_TLS_ENABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n            client_config.tls_connection_options = &tls_connection_options;\\\\\\\\n            break;\\\\\\\\n        case AWS_S3_TLS_DISABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_DISABLED;\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_put_object_meta_request(\\\\\\\\n        &tester, client, 10, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS | extra_meta_request_flag, NULL));\\\\\\\\n\\\\\\\\n    aws_string_destroy(endpoint);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    aws_tls_ctx_release(context);\\\\\\\\n    aws_tls_connection_options_clean_up(&tls_connection_options);\\\\\\\\n    aws_tls_ctx_options_clean_up(&tls_context_options);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_disabled, s_test_s3_put_object_tls_disabled)\\\\\\\\nstatic int s_test_s3_put_object_tls_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DISABLED, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_enabled, s_test_s3_put_object_tls_enabled)\\\\\\\\nstatic int s_test_s3_put_object_tls_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_ENABLED, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_default, s_test_s3_put_object_tls_default)\\\\\\\\nstatic int s_test_s3_put_object_tls_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DEFAULT, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_put_object_with_acl, s_test_s3_multipart_put_object_with_acl)\\\\\\\\nstatic int s_test_s3_multipart_put_object_with_acl(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DEFAULT, AWS_S3_TESTER_SEND_META_REQUEST_PUT_ACL));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_multiple_helper(struct aws_allocator *allocator, bool file_on_disk) {\\\\\\\\n\\\\\\\\n    enum s_numbers { NUM_REQUESTS = 5 };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_requests[NUM_REQUESTS];\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results[NUM_REQUESTS];\\\\\\\\n    struct aws_http_message *messages[NUM_REQUESTS];\\\\\\\\n    struct aws_input_stream *input_streams[NUM_REQUESTS];\\\\\\\\n    struct aws_byte_buf input_stream_buffers[NUM_REQUESTS];\\\\\\\\n    struct aws_string *filepath_str[NUM_REQUESTS];\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    size_t content_length = MB_TO_BYTES(10);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results[i], allocator);\\\\\\\\n        char object_path_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n        snprintf(\\\\\\\\n            object_path_buffer,\\\\\\\\n            sizeof(object_path_buffer),\\\\\\\\n            \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-10MB-%zu.txt\\\\\\\\\\\\\",\\\\\\\\n            AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n            i);\\\\\\\\n        AWS_ZERO_STRUCT(input_stream_buffers[i]);\\\\\\\\n        aws_s3_create_test_buffer(allocator, content_length, &input_stream_buffers[i]);\\\\\\\\n        struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&input_stream_buffers[i]);\\\\\\\\n        input_streams[i] = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n        struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(object_path_buffer);\\\\\\\\n        struct aws_byte_cursor host_cur = aws_byte_cursor_from_string(host_name);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT;\\\\\\\\n        if (file_on_disk) {\\\\\\\\n            filepath_str[i] = aws_s3_tester_create_file(allocator, test_object_path, input_streams[i]);\\\\\\\\n            messages[i] = aws_s3_test_put_object_request_new_without_body(\\\\\\\\n                allocator, &host_cur, g_test_body_content_type, test_object_path, content_length, 0 /*flags*/);\\\\\\\\n            options.send_filepath = aws_byte_cursor_from_string(filepath_str[i]);\\\\\\\\n        } else {\\\\\\\\n            filepath_str[i] = NULL;\\\\\\\\n            messages[i] = aws_s3_test_put_object_request_new(\\\\\\\\n                allocator, &host_cur, test_object_path, g_test_body_content_type, input_streams[i], 0);\\\\\\\\n        }\\\\\\\\n        options.message = messages[i];\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results[i]));\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Put Object request. */\\\\\\\\n        meta_requests[i] = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_requests[i] != NULL);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        meta_requests[i] = aws_s3_meta_request_release(meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_s3_tester_validate_get_object_results(&meta_request_test_results[i], 0);\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_http_message_release(messages[i]);\\\\\\\\n        aws_input_stream_release(input_streams[i]);\\\\\\\\n        aws_byte_buf_clean_up(&input_stream_buffers[i]);\\\\\\\\n        if (filepath_str[i]) {\\\\\\\\n            ASSERT_SUCCESS(aws_file_delete(filepath_str[i]));\\\\\\\\n            aws_string_destroy(filepath_str[i]);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multiple, s_test_s3_put_object_multiple)\\\\\\\\nstatic int s_test_s3_put_object_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_put_object_multiple_helper(allocator, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multiple_with_filepath, s_test_s3_put_object_multiple_with_filepath)\\\\\\\\nstatic int s_test_s3_put_object_multiple_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_put_object_multiple_helper(allocator, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_less_than_part_size, s_test_s3_put_object_less_than_part_size)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_buffer_pool_trim, s_test_s3_put_object_buffer_pool_trim)\\\\\\\\nstatic int s_test_s3_put_object_buffer_pool_trim(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 8 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 32,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    struct aws_s3_buffer_pool_usage_stats usage_before = aws_s3_buffer_pool_get_usage(client->buffer_pool);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(0 != usage_before.primary_num_blocks);\\\\\\\\n\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(6, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    struct aws_s3_buffer_pool_usage_stats usage_after = aws_s3_buffer_pool_get_usage(client->buffer_pool);\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(0, usage_after.primary_num_blocks);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_less_than_part_size_with_content_encoding,\\\\\\\\n    s_test_s3_put_object_less_than_part_size_with_content_encoding)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size_with_content_encoding(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor content_encoding_cursor = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"gzip\\\\\\\\\\\\\");\\\\\\\\n    uint32_t object_size_mb = 1;\\\\\\\\n    char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n    snprintf(\\\\\\\\n        object_path_sprintf_buffer,\\\\\\\\n        sizeof(object_path_sprintf_buffer),\\\\\\\\n        \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-content-encoding-%uMB.txt\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n        object_size_mb);\\\\\\\\n    struct aws_byte_cursor object_path_cursor = aws_byte_cursor_from_c_str(object_path_sprintf_buffer);\\\\\\\\n\\\\\\\\n    /*** put file with encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_SHA256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path_cursor,\\\\\\\\n                .content_encoding = content_encoding_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** get file and validate encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results get_object_result;\\\\\\\\n    aws_s3_meta_request_test_results_init(&get_object_result, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &get_object_result));\\\\\\\\n    struct aws_byte_cursor content_encoding_header_cursor;\\\\\\\\n    ASSERT_SUCCESS(aws_http_headers_get(\\\\\\\\n        get_object_result.response_headers, g_content_encoding_header_name, &content_encoding_header_cursor));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq(&content_encoding_cursor, &content_encoding_header_cursor));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&get_object_result);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_mpu_with_content_encoding, s_test_s3_put_object_mpu_with_content_encoding)\\\\\\\\nstatic int s_test_s3_put_object_mpu_with_content_encoding(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor content_encoding_cursor = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"gzip\\\\\\\\\\\\\");\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n    char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n    snprintf(\\\\\\\\n        object_path_sprintf_buffer,\\\\\\\\n        sizeof(object_path_sprintf_buffer),\\\\\\\\n        \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-content-encoding-%uMB.txt\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n        object_size_mb);\\\\\\\\n    struct aws_byte_cursor object_path_cursor = aws_byte_cursor_from_c_str(object_path_sprintf_buffer);\\\\\\\\n\\\\\\\\n    /*** put file with encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_SHA256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path_cursor,\\\\\\\\n                .content_encoding = content_encoding_cursor,\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** get file and validate encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results get_object_result;\\\\\\\\n    aws_s3_meta_request_test_results_init(&get_object_result, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &get_object_result));\\\\\\\\n    struct aws_byte_cursor content_encoding_header_cursor;\\\\\\\\n    ASSERT_SUCCESS(aws_http_headers_get(\\\\\\\\n        get_object_result.response_headers, g_content_encoding_header_name, &content_encoding_header_cursor));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq(&content_encoding_cursor, &content_encoding_header_cursor));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&get_object_result);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multipart_threshold, s_test_s3_put_object_multipart_threshold)\\\\\\\\nstatic int s_test_s3_put_object_multipart_threshold(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n        .multipart_upload_threshold = MB_TO_BYTES(15),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    /* First smaller than the part size */\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 5,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a single part upload, and have 0 as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(0, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    /* Second smaller than threshold and larger than part size */\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    put_options.put_options.object_size_mb = 10;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a single part upload, and have 0 as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(0, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    /* Third larger than threshold*/\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    put_options.put_options.object_size_mb = 20;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in multi-part upload, and have the real part size */\\\\\\\\n    ASSERT_UINT_EQUALS(client_config.part_size, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_threshold_less_than_part_size,\\\\\\\\n    s_test_s3_put_object_multipart_threshold_less_than_part_size)\\\\\\\\nstatic int s_test_s3_put_object_multipart_threshold_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n        .multipart_upload_threshold = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    /* First smaller than the part size */\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 6,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a one part of multipart upload, and have the content length as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(put_options.put_options.object_size_mb), meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_empty_object, s_test_s3_put_object_empty_object)\\\\\\\\nstatic int s_test_s3_put_object_empty_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 0,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s3_no_content_length_test_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    uint32_t object_size_in_mb,\\\\\\\\n    bool use_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = use_checksum ? AWS_SCA_CRC32 : AWS_SCA_NONE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_in_mb,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_no_content_length, s_test_s3_put_object_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 19, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_single_part_no_content_length, s_test_s3_put_object_single_part_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_single_part_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 5, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_zero_size_no_content_length, s_test_s3_put_object_zero_size_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_zero_size_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 0, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_large_object_no_content_length_with_checksum,\\\\\\\\n    s_test_s3_put_large_object_no_content_length_with_checksum)\\\\\\\\nstatic int s_test_s3_put_large_object_no_content_length_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 128, true));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Once upon a time, we have a bug that without content-length, we will schedule more requests to prepare than needed.\\\\\\\\n * And those extra request will be cleaned up, however, the client level count of `num_requests_being_prepared` will\\\\\\\\n * still keep record for those.\\\\\\\\n *\\\\\\\\n * To reproduce, we create bunch of requests with less than a part body. And then sleep for a while to let dns resolve\\\\\\\\n * purge all records. (Otherwise, we will always have one valid request to be available to send.) to trigger not going\\\\\\\\n * full speed code. And we will hang.\\\\\\\\n *\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_no_content_length_multiple, s_test_s3_put_object_no_content_length_multiple)\\\\\\\\nstatic int s_test_s3_put_object_no_content_length_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    aws_s3_set_dns_ttl(55);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    for (int i = 0; i < 6; i++) {\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    }\\\\\\\\n    /* Sleep more than the DNS ttl to purge all records. */\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(60, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    /* After sleep for a while, make another meta request */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream when we\\'re not doing multipart upload */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_singlepart, s_test_s3_put_object_async_singlepart)\\\\\\\\nstatic int s_test_s3_put_object_async_singlepart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 4,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream in multipart upload */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_multipart, s_test_s3_put_object_async_multipart)\\\\\\\\nstatic int s_test_s3_put_object_async_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 16,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, but the aws_async_input_stream_read() calls all complete synchronously */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_read_completes_synchronously,\\\\\\\\n    s_test_s3_put_object_async_read_completes_synchronously)\\\\\\\\nstatic int s_test_s3_put_object_async_read_completes_synchronously(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .async_read_strategy = AWS_ASYNC_READ_COMPLETES_IMMEDIATELY,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, where it takes multiple read() calls to fill each part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_small_reads, s_test_s3_put_object_async_small_reads)\\\\\\\\nstatic int s_test_s3_put_object_async_small_reads(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .max_bytes_per_read = KB_TO_BYTES(1001), /* something that doesn\\'t evenly divide into 8MB parts */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test synchronous input-stream, where it takes multiple read() calls to fill each part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_small_reads, s_test_s3_put_object_small_reads)\\\\\\\\nstatic int s_test_s3_put_object_small_reads(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .max_bytes_per_read = KB_TO_BYTES(1001), /* something that doesn\\'t evenly divide into 8MB parts */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that doesn\\'t end exactly on a part boundary */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_no_content_length_partial_part,\\\\\\\\n    s_test_s3_put_object_async_no_content_length_partial_part)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_partial_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 3,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that fills exactly 1 part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_no_content_length_1part, s_test_s3_put_object_async_no_content_length_1part)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_1part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 8,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that doesn\\'t realize\\\\\\\\n * it\\'s at EOF until it tries to read the 2nd part and gets 0 bytes */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_no_content_length_empty_part2,\\\\\\\\n    s_test_s3_put_object_async_no_content_length_empty_part2)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_empty_part2(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 8,             /* read 1 part\\'s worth of data */\\\\\\\\n                .eof_requires_extra_read = true, /* don\\'t report EOF until it tries to read 2nd part */\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that fills multiple parts */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_no_content_length_2parts, s_test_s3_put_object_async_no_content_length_2parts)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_2parts(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 16,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_fail_reading, s_test_s3_put_object_async_fail_reading)\\\\\\\\nstatic int s_test_s3_put_object_async_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(AWS_IO_STREAM_READ_FAILED, test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_validate_if_none_match_failure_response(struct aws_s3_meta_request_test_results *test_results) {\\\\\\\\n\\\\\\\\n    /**\\\\\\\\n     * response body should be like:\\\\\\\\n     * <Error>\\\\\\\\n     * <Code>PreconditionFailed</Code>\\\\\\\\n     * <Message>At least one of the pre-conditions you specified did not hold</Message>\\\\\\\\n     * <Condition>If-None-Match</Condition>\\\\\\\\n     * <RequestId></RequestId>\\\\\\\\n     * <HostId></HostId>\\\\\\\\n     * </Error>\\\\\\\\n     */\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor xml_doc = aws_byte_cursor_from_buf(&test_results->error_response_body);\\\\\\\\n    struct aws_byte_cursor error_code_string = {0};\\\\\\\\n    struct aws_byte_cursor condition_string = {0};\\\\\\\\n\\\\\\\\n    const char *error_code_path[] = {\\\\\\\\\\\\\"Error\\\\\\\\\\\\\", \\\\\\\\\\\\\"Code\\\\\\\\\\\\\", NULL};\\\\\\\\n    ASSERT_SUCCESS(aws_xml_get_body_at_path(test_results->allocator, xml_doc, error_code_path, &error_code_string));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq_c_str(&error_code_string, \\\\\\\\\\\\\"PreconditionFailed\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    const char *condition_path[] = {\\\\\\\\\\\\\"Error\\\\\\\\\\\\\", \\\\\\\\\\\\\"Condition\\\\\\\\\\\\\", NULL};\\\\\\\\n    ASSERT_SUCCESS(aws_xml_get_body_at_path(test_results->allocator, xml_doc, condition_path, &condition_string));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq_c_str(&condition_string, \\\\\\\\\\\\\"If-None-Match\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_if_none_match, s_test_s3_put_object_if_none_match)\\\\\\\\nstatic int s_test_s3_put_object_if_none_match(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n    struct aws_byte_cursor if_none_match_all = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Use pre_exist object so that the request should fail with the expected failure message. */\\\\\\\\n                .object_path_override = g_pre_existing_object_1MB,\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .if_none_match_header = if_none_match_all,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_HTTP_STATUS_CODE_412_PRECONDITION_FAILED, test_results.finished_response_status);\\\\\\\\n    ASSERT_SUCCESS(s_test_validate_if_none_match_failure_response(&test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_mpu_if_none_match, s_test_s3_put_object_mpu_if_none_match)\\\\\\\\nstatic int s_test_s3_put_object_mpu_if_none_match(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n    struct aws_byte_cursor if_none_match_all = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Use pre_exist object so that the request should fail with the expected failure message. */\\\\\\\\n                .object_path_override = g_pre_existing_object_10MB,\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .if_none_match_header = if_none_match_all,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /** Complete MPU can fail with 200 error */\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        AWS_HTTP_STATUS_CODE_412_PRECONDITION_FAILED == test_results.finished_response_status ||\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK == test_results.finished_response_status);\\\\\\\\n    ASSERT_SUCCESS(s_test_validate_if_none_match_failure_response(&test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_kms, s_test_s3_put_object_sse_kms)\\\\\\\\nstatic int s_test_s3_put_object_sse_kms(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_kms_multipart, s_test_s3_put_object_sse_kms_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_kms_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_aes256, s_test_s3_put_object_sse_aes256)\\\\\\\\nstatic int s_test_s3_put_object_sse_aes256(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_aes256_multipart, s_test_s3_put_object_sse_aes256_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_aes256_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_c_aes256_multipart, s_test_s3_put_object_sse_c_aes256_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_c_aes256_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    (void)allocator;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        tester.allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_sse_c.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_C_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_sse_c_aes256_multipart_with_checksum,\\\\\\\\n    s_test_s3_put_object_sse_c_aes256_multipart_with_checksum)\\\\\\\\nstatic int s_test_s3_put_object_sse_c_aes256_multipart_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        tester.allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_sse_c_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_C_AES256,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_content_md5_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    bool multipart_upload,\\\\\\\\n    uint32_t flags,\\\\\\\\n    enum aws_s3_meta_request_compute_content_md5 compute_content_md5) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    size_t part_size = 5 * 1024 * 1024;\\\\\\\\n    if (!multipart_upload) {\\\\\\\\n        /* content_length < part_size */\\\\\\\\n        part_size = 15 * 1024 * 1024;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = part_size,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    client_config.compute_content_md5 = compute_content_md5;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_put_object_meta_request(&tester, client, 10, flags, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_no_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_no_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_no_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_no_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_no_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_no_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_correct_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_correct_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_correct_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_correct_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_correct_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_correct_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_incorrect_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_incorrect_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_incorrect_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_incorrect_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_incorrect_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_incorrect_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_no_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_no_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_no_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_no_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_no_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_no_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_correct_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_correct_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_correct_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_correct_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_correct_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_correct_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_incorrect_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_incorrect_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_incorrect_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_incorrect_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_incorrect_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_incorrect_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_upload_part_message_helper(struct aws_allocator *allocator, bool should_compute_content_md5) {\\\\\\\\n\\\\\\\\n    aws_s3_library_init(allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n    /* base64 encoded md5 of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */\\\\\\\\n    struct aws_byte_cursor expected_content_md5 = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"+y3U+EY5uFXhVVmRoiJWyA==\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    uint32_t part_number = 1;\\\\\\\\n    struct aws_string *upload_id = aws_string_new_from_c_str(allocator, \\\\\\\\\\\\\"dummy_upload_id\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message = aws_s3_upload_part_message_new(\\\\\\\\n        allocator, base_message, &test_buffer, part_number, upload_id, should_compute_content_md5, NULL, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    if (should_compute_content_md5) {\\\\\\\\n        ASSERT_TRUE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n        struct aws_byte_cursor content_md5;\\\\\\\\n        aws_http_headers_get(new_headers, g_content_md5_header_name, &content_md5);\\\\\\\\n        ASSERT_BIN_ARRAYS_EQUALS(expected_content_md5.ptr, expected_content_md5.len, content_md5.ptr, content_md5.len);\\\\\\\\n    } else {\\\\\\\\n        ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(upload_id);\\\\\\\\n    upload_id = NULL;\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    aws_s3_library_clean_up();\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_part_message_with_content_md5, s_test_s3_upload_part_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_upload_part_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_upload_part_message_helper(allocator, true));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_part_message_without_content_md5, s_test_s3_upload_part_message_without_content_md5)\\\\\\\\nstatic int s_test_s3_upload_part_message_without_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_upload_part_message_helper(allocator, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_create_multipart_upload_message_with_content_md5,\\\\\\\\n    s_test_s3_create_multipart_upload_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_create_multipart_upload_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_md5_header = {\\\\\\\\n        .name = g_content_md5_header_name,\\\\\\\\n        .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_content_md5\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_http_message_add_header(base_message, content_md5_header));\\\\\\\\n\\\\\\\\n    struct aws_http_headers *base_headers = aws_http_message_get_headers(base_message);\\\\\\\\n    ASSERT_TRUE(aws_http_headers_has(base_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message = aws_s3_create_multipart_upload_message_new(allocator, base_message, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_complete_multipart_message_with_content_md5,\\\\\\\\n    s_test_s3_complete_multipart_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_complete_multipart_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_md5_header = {\\\\\\\\n        .name = g_content_md5_header_name,\\\\\\\\n        .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_content_md5\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_http_message_add_header(base_message, content_md5_header));\\\\\\\\n\\\\\\\\n    struct aws_http_headers *base_headers = aws_http_message_get_headers(base_message);\\\\\\\\n    ASSERT_TRUE(aws_http_headers_has(base_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf body_buffer;\\\\\\\\n    aws_byte_buf_init(&body_buffer, allocator, 512);\\\\\\\\n\\\\\\\\n    struct aws_string *upload_id = aws_string_new_from_c_str(allocator, \\\\\\\\\\\\\"dummy_upload_id\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_array_list parts;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_init_dynamic(&parts, allocator, 0, sizeof(struct aws_s3_mpu_part_info *)));\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message =\\\\\\\\n        aws_s3_complete_multipart_message_new(allocator, base_message, &body_buffer, upload_id, &parts, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_array_list_clean_up(&parts);\\\\\\\\n\\\\\\\\n    aws_string_destroy(upload_id);\\\\\\\\n    upload_id = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&body_buffer);\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_double_slashes, s_test_s3_put_object_double_slashes)\\\\\\\\nstatic int s_test_s3_put_object_double_slashes(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix//test.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip, s_test_s3_round_trip)\\\\\\\\nstatic int s_test_s3_round_trip(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get, s_test_s3_round_trip_default_get)\\\\\\\\nstatic int s_test_s3_round_trip_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_default.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_validate_headers_checksum_set(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)headers;\\\\\\\\n    struct aws_s3_meta_request_test_results *meta_request_test_results =\\\\\\\\n        (struct aws_s3_meta_request_test_results *)user_data;\\\\\\\\n    ASSERT_NOT_NULL(meta_request->meta_request_level_running_response_sum);\\\\\\\\n    ASSERT_INT_EQUALS(\\\\\\\\n        meta_request->meta_request_level_running_response_sum->algorithm, meta_request_test_results->algorithm);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_validate_headers_checksum_unset(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)user_data;\\\\\\\\n    ASSERT_NULL(meta_request->meta_request_level_running_response_sum);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nvoid s_s3_test_validate_checksum(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *result,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    struct aws_s3_meta_request_test_results *meta_request_test_results =\\\\\\\\n        (struct aws_s3_meta_request_test_results *)user_data;\\\\\\\\n    AWS_FATAL_ASSERT(result->did_validate);\\\\\\\\n    AWS_FATAL_ASSERT(result->validation_algorithm == meta_request_test_results->algorithm);\\\\\\\\n    AWS_FATAL_ASSERT(result->error_code == AWS_OP_SUCCESS);\\\\\\\\n}\\\\\\\\nvoid s_s3_test_no_validate_checksum(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *result,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)user_data;\\\\\\\\n    AWS_FATAL_ASSERT(!result->did_validate);\\\\\\\\n    AWS_FATAL_ASSERT(result->error_code == AWS_OP_SUCCESS);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* TODO: maybe refactor the fc -> flexible checksum tests to be less copy/paste */\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header,\\\\\\\\n    uint32_t object_size_mb,\\\\\\\\n    enum aws_s3_tester_full_object_checksum full_object_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_ARRAY_SIZE(s_checksum_algo_priority_list); i++) {\\\\\\\\n        enum aws_s3_checksum_algorithm algorithm = s_checksum_algo_priority_list[i];\\\\\\\\n        char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n        snprintf(\\\\\\\\n            object_path_sprintf_buffer,\\\\\\\\n            sizeof(object_path_sprintf_buffer),\\\\\\\\n            \\\\\\\\\\\\\"/prefix/round_trip/test_default_fc_%d_%d.txt\\\\\\\\\\\\\",\\\\\\\\n            algorithm,\\\\\\\\n            object_size_mb);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n            allocator, &path_buf, aws_byte_cursor_from_c_str(object_path_sprintf_buffer)));\\\\\\\\n        struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n        /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n        struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n            .client = client,\\\\\\\\n            .checksum_algorithm = algorithm,\\\\\\\\n            .validate_get_response_checksum = false,\\\\\\\\n            .checksum_via_header = via_header,\\\\\\\\n            .put_options =\\\\\\\\n                {\\\\\\\\n                    .object_size_mb = object_size_mb,\\\\\\\\n                    .object_path_override = object_path,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n        if (algorithm != AWS_SCA_SHA1 && algorithm != AWS_SCA_SHA256) {\\\\\\\\n            /* Full object checksums doesn\\'t support SHA. */\\\\\\\\n            put_options.put_options.full_object_checksum = full_object_checksum;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n        /*** GET FILE ***/\\\\\\\\n\\\\\\\\n        struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .client = client,\\\\\\\\n            .expected_validate_checksum_alg = algorithm,\\\\\\\\n            .validate_get_response_checksum = true,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = object_path,\\\\\\\\n                },\\\\\\\\n            .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n            .headers_callback = s_s3_validate_headers_checksum_set,\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n        aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get_fc, s_test_s3_round_trip_default_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 1 /*object_size_mb*/, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_empty_fc, s_test_s3_round_trip_empty_fc)\\\\\\\\nstatic int s_test_s3_round_trip_empty_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 0, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get_fc_header, s_test_s3_round_trip_default_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, true, 1, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_default_get_full_object_checksum_fc,\\\\\\\\n    s_test_s3_round_trip_default_get_full_object_checksum_fc)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_full_object_checksum_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 1, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc_helper(struct aws_allocator *allocator, void *ctx, bool via_header) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC64NVME,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC64NVME,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .headers_callback = s_s3_validate_headers_checksum_set,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_multipart_get_fc, s_test_s3_round_trip_multipart_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_multipart_get_fc_helper(allocator, ctx, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_multipart_get_fc_header, s_test_s3_round_trip_multipart_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_multipart_get_fc_helper(allocator, ctx, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test the multipart uploaded object was downloaded with same part size, which will download the object matches all the\\\\\\\\n * parts and validate the parts checksum. */\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header,\\\\\\\\n    enum aws_s3_tester_full_object_checksum full_object_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n    struct aws_byte_cursor object_name;\\\\\\\\n    /* Use different name to avoid collision when tests run concurrently. */\\\\\\\\n    switch (full_object_checksum) {\\\\\\\\n        case AWS_TEST_FOC_CALLBACK:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc_full_object_via_callback.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n        case AWS_TEST_FOC_HEADER:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc_full_object_via_header.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(allocator, &path_buf, object_name));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .full_object_checksum = full_object_checksum,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_multipart_get_fc, s_test_s3_round_trip_mpu_multipart_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_multipart_get_fc_header, s_test_s3_round_trip_mpu_multipart_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, true, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, true, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_CALLBACK);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/empty-file-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 0,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE WITH GET_FIRST_PART ***/\\\\\\\\n    uint64_t small_object_size_hint = 1;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .object_size_hint =\\\\\\\\n            &small_object_size_hint /* pass a object_size_hint > 0 so that the request goes through the getPart flow */,\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE WITH HEAD_OBJECT ***/\\\\\\\\n    get_options.object_size_hint = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_empty_file_with_checksum, s_test_s3_download_empty_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_download_empty_file_with_checksum_helper(allocator, ctx, false);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(test_s3_download_empty_file_with_checksum_header, s_test_s3_download_empty_file_with_checksum_header)\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_download_empty_file_with_checksum_helper(allocator, ctx, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_single_part_file_with_checksum, s_test_s3_download_single_part_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_single_part_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(10),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/single-part-10Mb-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    uint64_t object_size_hint = MB_TO_BYTES(object_size_mb);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .object_size_hint = &object_size_hint,\\\\\\\\n    };\\\\\\\\n    uint64_t small_object_size_hint = MB_TO_BYTES(1);\\\\\\\\n\\\\\\\\n    /* will do headRequest */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(20);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n\\\\\\\\n    /* will do getPart */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /* will do getPart */\\\\\\\\n    /*** GET FILE with part_size = file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(10);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < file_size and wrong object_size_hint ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.object_size_hint = &small_object_size_hint;\\\\\\\\n    /* will do getPart first, cancel it and then rangedGet */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_multipart_file_with_checksum, s_test_s3_download_multipart_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_multipart_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/multipart-10Mb-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    uint64_t object_size_hint = MB_TO_BYTES(object_size_mb);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .object_size_hint = &object_size_hint,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* will do HeadRequest first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(7);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    /* will do HeadObject first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size = first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(5);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    /* will do HeadObject First */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    uint64_t small_object_size_hint = 1;\\\\\\\\n\\\\\\\\n    /*** GET FILE with with wrong object_size_hint ***/\\\\\\\\n    get_options.object_size_hint = &small_object_size_hint;\\\\\\\\n    get_options.finish_callback = NULL;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < first_part_size***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n\\\\\\\\n    /* will do GetPart, cancel the request and then do ranged Gets. */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(7);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n\\\\\\\\n    /* will do GetPart first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size = first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(5);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    /* will do GetPart first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > fileSize ***/\\\\\\\\n    /* TODO: Enable this test once the checksum issue is resolved. Currently, when the S3 GetObject API is called with\\\\\\\\n     * the range 0-contentLength, it returns a checksum of checksums without the -numParts portion. This leads to a\\\\\\\\n     * checksum mismatch error, as it is incorrectly validated as a part checksum. */\\\\\\\\n    /*\\\\\\\\n    client_options.part_size = MB_TO_BYTES(20);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n    */\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_array_list response_checksum_list;\\\\\\\\n    /* Check for all algorithm but the CRC32 */\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_array_list_init_dynamic(&response_checksum_list, allocator, 4, sizeof(enum aws_s3_checksum_algorithm)));\\\\\\\\n    enum aws_s3_checksum_algorithm alg = AWS_SCA_CRC32C;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    alg = AWS_SCA_SHA1;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    alg = AWS_SCA_SHA256;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .validate_checksum_algorithms = &response_checksum_list,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_no_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    /* Push all the algorithms to the list for validation, now we should have the checksum validated. */\\\\\\\\n    alg = AWS_SCA_CRC32;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_array_list_clean_up(&response_checksum_list);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_default_get_fc, s_test_s3_round_trip_mpu_default_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_default_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_default_get_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_no_validate_checksum,\\\\\\\\n        .headers_callback = s_s3_validate_headers_checksum_unset,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor key,\\\\\\\\n    int object_size_mb,\\\\\\\\n    bool unknown_content_length) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(allocator, &path_buf, key));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .skip_content_length = unknown_content_length,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(\\\\\\\\n        MB_TO_BYTES(put_options.put_options.object_size_mb), test_results.progress.total_bytes_transferred);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_with_filepath, s_test_s3_round_trip_with_filepath)\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath\\\\\\\\\\\\\"), 1, false /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_with_filepath, s_test_s3_round_trip_mpu_with_filepath)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_mpu\\\\\\\\\\\\\"),\\\\\\\\n        50,\\\\\\\\n        false /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_with_filepath_no_content_length, s_test_s3_round_trip_with_filepath_no_content_length)\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_no_content_length\\\\\\\\\\\\\"),\\\\\\\\n        1,\\\\\\\\n        true /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_with_filepath_no_content_length,\\\\\\\\n    s_test_s3_round_trip_mpu_with_filepath_no_content_length)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_with_filepath_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_mpu_no_content_length\\\\\\\\\\\\\"),\\\\\\\\n        50,\\\\\\\\n        true /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_chunked_then_unchunked, s_test_s3_chunked_then_unchunked)\\\\\\\\nstatic int s_test_s3_chunked_then_unchunked(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Test to see if signed_body_value modified when signing chunked request */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/chunked_unchunked/test_chunked.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor chunked_object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options chunked_put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = chunked_object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &chunked_put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/chunked_unchunked/test_unchunked.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor unchunked_object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options unchunked_put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_NONE,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = unchunked_object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &unchunked_put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_meta_request_default, s_test_s3_meta_request_default)\\\\\\\\nstatic int s_test_s3_meta_request_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n\\\\\\\\n    /* Pass the request through as a default request so that it goes through as-is. */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    /* Check the size of the metrics should be the same as the number of\\\\\\\\n    requests, which should be 1 */\\\\\\\\n    ASSERT_UINT_EQUALS(1, aws_array_list_length(&meta_request_test_results.synced_data.metrics));\\\\\\\\n    struct aws_s3_request_metrics *metrics = NULL;\\\\\\\\n    aws_array_list_back(&meta_request_test_results.synced_data.metrics, (void **)&metrics);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_error_missing_file, s_test_s3_error_missing_file)\\\\\\\\nstatic int s_test_s3_error_missing_file(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor test_object_path =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/non-existing-file12345.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message =\\\\\\\\n        aws_s3_test_get_object_request_new(allocator, aws_byte_cursor_from_string(host_name), test_object_path);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_response_status == 404);\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.error_response_headers != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_NOT_NULL(meta_request_test_results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(meta_request_test_results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(meta_request_test_results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_test_s3_existing_host_entry_address_resolved_callback(\\\\\\\\n    struct aws_host_resolver *resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    int err_code,\\\\\\\\n    const struct aws_array_list *host_addresses,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)err_code;\\\\\\\\n    (void)host_addresses;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = user_data;\\\\\\\\n    AWS_ASSERT(tester);\\\\\\\\n    aws_s3_tester_notify_signal(tester);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_existing_host_entry, s_test_s3_existing_host_entry)\\\\\\\\nstatic int s_test_s3_existing_host_entry(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_host_resolution_config host_resolver_config;\\\\\\\\n        AWS_ZERO_STRUCT(host_resolver_config);\\\\\\\\n        host_resolver_config.impl = aws_default_dns_resolve;\\\\\\\\n        host_resolver_config.max_ttl = 30;\\\\\\\\n        host_resolver_config.impl_data = NULL;\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_host_resolver_resolve_host(\\\\\\\\n            client_config.client_bootstrap->host_resolver,\\\\\\\\n            host_name,\\\\\\\\n            s_test_s3_existing_host_entry_address_resolved_callback,\\\\\\\\n            &host_resolver_config,\\\\\\\\n            &tester));\\\\\\\\n\\\\\\\\n        aws_s3_tester_wait_for_signal(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_bad_endpoint, s_test_s3_bad_endpoint)\\\\\\\\nstatic int s_test_s3_bad_endpoint(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"test_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    AWS_STATIC_STRING_FROM_LITERAL(invalid_host_name, \\\\\\\\\\\\\"invalid_host_name_totally_absolutely\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Construct a message that points to an invalid host name. Key can be anything. */\\\\\\\\n    struct aws_http_message *message =\\\\\\\\n        aws_s3_test_get_object_request_new(allocator, aws_byte_cursor_from_string(invalid_host_name), test_key);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(&tester, client, &options, &meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        meta_request_test_results.finished_error_code == AWS_IO_DNS_INVALID_NAME ||\\\\\\\\n        meta_request_test_results.finished_error_code == AWS_IO_DNS_QUERY_FAILED);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_raise_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_body_callback_raise_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)body;\\\\\\\\n    (void)range_start;\\\\\\\\n    (void)user_data;\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_fail_headers_callback, s_test_s3_put_object_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_put_object_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_fail_body_callback, s_test_s3_put_object_fail_body_callback)\\\\\\\\nstatic int s_test_s3_put_object_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n\\\\\\\\n        /* Put object currently never invokes the body callback, which means it should not fail. */\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, NULL));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_fail_headers_callback, s_test_s3_get_object_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_get_object_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_fail_body_callback, s_test_s3_get_object_fail_body_callback)\\\\\\\\nstatic int s_test_s3_get_object_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_headers_callback, s_test_s3_default_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_default_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_atomic_var s_test_headers_callback_invoked;\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_check_returns_success(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    /* increments counter to check if callback was invoked exactly once */\\\\\\\\n    aws_atomic_fetch_add(&s_test_headers_callback_invoked, 1);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_check_returns_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    /* increments counter to check if callback was invoked exactly once */\\\\\\\\n    aws_atomic_fetch_add(&s_test_headers_callback_invoked, 1);\\\\\\\\n\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_invoke_headers_callback_on_error, s_test_s3_default_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_default_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_default_invoke_headers_callback_cancels_on_error,\\\\\\\\n    s_test_s3_default_invoke_headers_callback_cancels_on_error)\\\\\\\\nstatic int s_test_s3_default_invoke_headers_callback_cancels_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_invoke_headers_callback_on_error,\\\\\\\\n    s_test_s3_get_object_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_get_object_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_invoke_headers_callback_on_error,\\\\\\\\n    s_test_s3_put_object_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_put_object_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .invalid_request = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INVALID_RESPONSE_STATUS, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation,\\\\\\\\n    s_test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation)\\\\\\\\nstatic int s_test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_UNKNOWN, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_body_callback, s_test_s3_default_fail_body_callback)\\\\\\\\nstatic int s_test_s3_default_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that if a DEFAULt meta-request sets the operation_name, and gets an error response,\\\\\\\\n * then aws_s3_meta_request_result.error_response_operation_name is set. */\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_operation_name, s_test_s3_default_fail_operation_name)\\\\\\\\nstatic int s_test_s3_default_fail_operation_name(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\", aws_string_c_str(meta_request_test_results.error_response_operation_name));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_invalid_request, s_test_s3_put_fail_object_invalid_request)\\\\\\\\nstatic int s_test_s3_put_fail_object_invalid_request(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .invalid_request = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INVALID_RESPONSE_STATUS, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    /* Since 1MB is under part_size, there will be a single PutObject request */\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"PutObject\\\\\\\\\\\\\", aws_string_c_str(meta_request_test_results.error_response_operation_name));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that we fail to create a metarequest when an invalid `send_filepath` is passed in */\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_invalid_send_filepath, s_test_s3_put_fail_object_invalid_send_filepath)\\\\\\\\nstatic int s_test_s3_put_fail_object_invalid_send_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor object_key = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = aws_s3_test_put_object_request_new_without_body(\\\\\\\\n        allocator, &host_name, g_test_body_content_type, object_key, 1024 /*content_length*/, 0 /*flags*/);\\\\\\\\n    ASSERT_NOT_NULL(message);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options meta_request_options = {\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .message = message,\\\\\\\\n        .send_filepath = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"obviously_invalid_file_path\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &meta_request_options);\\\\\\\\n    ASSERT_NULL(meta_request);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_ERROR_FILE_INVALID_PATH, aws_last_error());\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the parallel read stream failed to send read the second part. */\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_bad_parallel_read_stream, s_test_s3_put_fail_object_bad_parallel_read_stream)\\\\\\\\nstatic int s_test_s3_put_fail_object_bad_parallel_read_stream(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    /* Override the parallel input stream new function to create a bad parallel input stream */\\\\\\\\n    client->vtable->parallel_input_stream_new_from_file = aws_parallel_input_stream_new_from_file_failure_tester;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 100,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_UNIMPLEMENTED, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_single_part_fail_object_inputstream_fail_reading,\\\\\\\\n    s_test_s3_put_single_part_fail_object_inputstream_fail_reading)\\\\\\\\nstatic int s_test_s3_put_single_part_fail_object_inputstream_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n                .content_length = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_single_part_fail_object_inputstream_mismatch_content_length,\\\\\\\\n    s_test_s3_put_single_part_fail_object_inputstream_mismatch_content_length)\\\\\\\\nstatic int s_test_s3_put_single_part_fail_object_inputstream_mismatch_content_length(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .content_length = MB_TO_BYTES(2),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_inputstream_fail_reading, s_test_s3_put_fail_object_inputstream_fail_reading)\\\\\\\\nstatic int s_test_s3_put_fail_object_inputstream_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n                .content_length = 10 * 1024 * 1024,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_IO_STREAM_READ_FAILED, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_fail_object_inputstream_mismatch_content_length,\\\\\\\\n    s_test_s3_put_fail_object_inputstream_mismatch_content_length)\\\\\\\\nstatic int s_test_s3_put_fail_object_inputstream_mismatch_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = false,\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .content_length = 10 * 1024 * 1024,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INCORRECT_CONTENT_LENGTH, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_clamp_part_size, s_test_s3_put_object_clamp_part_size)\\\\\\\\nstatic int s_test_s3_put_object_clamp_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n        .max_part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client_config.part_size < g_s3_min_upload_part_size);\\\\\\\\n    ASSERT_TRUE(client_config.max_part_size < g_s3_min_upload_part_size);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    /* Upload should now succeed even when specifying a smaller than allowed part size. */\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(test_results.part_size == g_s3_min_upload_part_size);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_get_expected_user_agent(struct aws_allocator *allocator, struct aws_byte_buf *dest) {\\\\\\\\n    AWS_ASSERT(allocator);\\\\\\\\n    AWS_ASSERT(dest);\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor forward_slash = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/\\\\\\\\\\\\\");\\\\\\\\n    const struct aws_byte_cursor single_space = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\" \\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_init(dest, allocator, 32));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_product_name));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &forward_slash));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_s3_client_version));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &single_space));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_platform));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &forward_slash));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_unknown));\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_add_user_agent_header, s_test_add_user_agent_header)\\\\\\\\nstatic int s_test_add_user_agent_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor single_space = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\" \\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_buf expected_user_agent_value_buf;\\\\\\\\n    s_get_expected_user_agent(allocator, &expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor expected_user_agent_value = aws_byte_cursor_from_buf(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_byte_cursor user_agent_value;\\\\\\\\n        AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n\\\\\\\\n        struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n\\\\\\\\n        aws_s3_add_user_agent_header(allocator, message);\\\\\\\\n\\\\\\\\n        struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(headers != NULL);\\\\\\\\n        ASSERT_SUCCESS(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value));\\\\\\\\n        ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n            user_agent_value.ptr, user_agent_value.len, expected_user_agent_value.ptr, expected_user_agent_value.len);\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        const struct aws_byte_cursor dummy_agent_header_value =\\\\\\\\n            AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_user_agent_product/dummy_user_agent_value\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        struct aws_byte_buf total_expected_user_agent_value_buf;\\\\\\\\n        aws_byte_buf_init(&total_expected_user_agent_value_buf, allocator, 64);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &dummy_agent_header_value);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &single_space);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &expected_user_agent_value);\\\\\\\\n\\\\\\\\n        struct aws_byte_cursor total_expected_user_agent_value =\\\\\\\\n            aws_byte_cursor_from_buf(&total_expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n        struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n        struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n        ASSERT_TRUE(headers != NULL);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_http_headers_add(headers, g_user_agent_header_name, dummy_agent_header_value));\\\\\\\\n\\\\\\\\n        aws_s3_add_user_agent_header(allocator, message);\\\\\\\\n\\\\\\\\n        {\\\\\\\\n            struct aws_byte_cursor user_agent_value;\\\\\\\\n            AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n            ASSERT_SUCCESS(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value));\\\\\\\\n            ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n                user_agent_value.ptr,\\\\\\\\n                user_agent_value.len,\\\\\\\\n                total_expected_user_agent_value.ptr,\\\\\\\\n                total_expected_user_agent_value.len);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_byte_buf_clean_up(&total_expected_user_agent_value_buf);\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&expected_user_agent_value_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_user_agent_meta_request_finished_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *results = meta_request->user_data;\\\\\\\\n    AWS_ASSERT(results != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = results->tester;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf expected_user_agent_value_buf;\\\\\\\\n    s_get_expected_user_agent(meta_request->allocator, &expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor expected_user_agent_value = aws_byte_cursor_from_buf(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = request->send_data.message;\\\\\\\\n    struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor user_agent_value;\\\\\\\\n    AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n\\\\\\\\n    AWS_FATAL_ASSERT(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value) == AWS_OP_SUCCESS);\\\\\\\\n    AWS_FATAL_ASSERT(aws_byte_cursor_eq(&user_agent_value, &expected_user_agent_value));\\\\\\\\n    aws_byte_buf_clean_up(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *original_meta_request_vtable =\\\\\\\\n        aws_s3_tester_get_meta_request_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    original_meta_request_vtable->finished_request(meta_request, request, error_code);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_s3_meta_request *s_s3_meta_request_factory_override_finished_request(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    const struct aws_s3_meta_request_options *options) {\\\\\\\\n    AWS_ASSERT(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = client->shutdown_callback_user_data;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *original_client_vtable =\\\\\\\\n        aws_s3_tester_get_client_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = original_client_vtable->meta_request_factory(client, options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *patched_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(tester, meta_request, NULL);\\\\\\\\n    patched_meta_request_vtable->finished_request = s_s3_test_user_agent_meta_request_finished_request;\\\\\\\\n\\\\\\\\n    return meta_request;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_test_sending_user_agent_create_client(struct aws_s3_tester *tester, struct aws_s3_client **client) {\\\\\\\\n    AWS_ASSERT(tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(tester, &client_options, client));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(tester, *client, NULL);\\\\\\\\n    patched_client_vtable->meta_request_factory = s_s3_meta_request_factory_override_finished_request;\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_auto_ranged_get_sending_user_agent, s_test_s3_auto_ranged_get_sending_user_agent)\\\\\\\\nstatic int s_test_s3_auto_ranged_get_sending_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = g_pre_existing_object_1MB,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_auto_ranged_put_sending_user_agent, s_test_s3_auto_ranged_put_sending_user_agent)\\\\\\\\nstatic int s_test_s3_auto_ranged_put_sending_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .put_options =\\\\\\\\n                {\\\\\\\\n                    .ensure_multipart = true,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_sending_meta_request_user_agent, s_test_s3_default_sending_meta_request_user_agent)\\\\\\\\nstatic int s_test_s3_default_sending_meta_request_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .default_type_options =\\\\\\\\n                {\\\\\\\\n                    .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                    .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n                },\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = g_pre_existing_object_1MB,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct range_requests_test_user_data {\\\\\\\\n    struct aws_http_headers *headers;\\\\\\\\n    struct aws_byte_buf *body_buffer;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic int s_range_requests_headers_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)response_status;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results = user_data;\\\\\\\\n    struct range_requests_test_user_data *test_user_data = test_results->tester->user_data;\\\\\\\\n\\\\\\\\n    if (test_user_data != NULL) {\\\\\\\\n        copy_http_headers(headers, test_user_data->headers);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_range_requests_receive_body_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)range_start;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results = user_data;\\\\\\\\n    struct range_requests_test_user_data *test_user_data = test_results->tester->user_data;\\\\\\\\n\\\\\\\\n    aws_byte_buf_append_dynamic(test_user_data->body_buffer, body);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_range_requests, s_test_s3_range_requests)\\\\\\\\nstatic int s_test_s3_range_requests(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor object_names[] = {\\\\\\\\n        g_pre_existing_object_1MB,\\\\\\\\n        g_pre_existing_object_kms_10MB,\\\\\\\\n        g_pre_existing_object_aes256_10MB,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    enum aws_s3_tester_sse_type object_sse_types[] = {\\\\\\\\n        AWS_S3_TESTER_SSE_NONE,\\\\\\\\n        AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        AWS_S3_TESTER_SSE_AES256,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor ranges[] = {\\\\\\\\n        // No range at all.\\\\\\\\n        {0, NULL},\\\\\\\\n\\\\\\\\n        // Single byte range.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=8-8\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Single byte range (first byte).\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-0\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // First 8K.  8K < client\\'s 16K part size.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-8191\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // First 0.5 MB.  0.5 MB < 1 MB test file.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-524287\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // 0.5 MB - 2 MB range.  This overlaps and goes beyond the 1 MB test file size.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=524288-2097151\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Get everything after the first 0.5 MB\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=524288-\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Last 0.5 MB\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=-524288\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Everything after first 8K\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=8192-\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Last 8K\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=-8192\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* List of headers that should have matching values between the auto_ranged_get and default (which sends the HTTP\\\\\\\\n     * request as-is to S3) meta request.*/\\\\\\\\n    const struct aws_byte_cursor headers_that_should_match[] = {\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"ETag\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Accept-Ranges\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Range\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Type\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Length\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Server\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"x-amz-server-side-encryption\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"x-amz-server-side-encryption-aws-kms-key\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* List of headers that are okay to be in the auto_ranged_get response and not in the default response, or vice\\\\\\\\n     * versa.*/\\\\\\\\n    const struct aws_byte_cursor headers_to_ignore[] = {\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Connection\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    const size_t num_object_names = AWS_ARRAY_SIZE(object_names);\\\\\\\\n    const size_t num_ranges = AWS_ARRAY_SIZE(ranges);\\\\\\\\n\\\\\\\\n    for (size_t object_name_index = 0; object_name_index < num_object_names; ++object_name_index) {\\\\\\\\n        for (size_t range_index = 0; range_index < num_ranges; ++range_index) {\\\\\\\\n\\\\\\\\n            AWS_LOGF_INFO(\\\\\\\\n                AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Testing object name %d and range %d\\\\\\\\\\\\\", (int)object_name_index, (int)range_index);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf range_get_buffer;\\\\\\\\n            aws_byte_buf_init(&range_get_buffer, allocator, 256);\\\\\\\\n            struct aws_http_headers *range_get_headers = aws_http_headers_new(allocator);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf verify_range_get_buffer;\\\\\\\\n            aws_byte_buf_init(&verify_range_get_buffer, allocator, 256);\\\\\\\\n            struct aws_http_headers *verify_range_get_headers = aws_http_headers_new(allocator);\\\\\\\\n\\\\\\\\n            struct aws_s3_tester_meta_request_options options = {\\\\\\\\n                .allocator = allocator,\\\\\\\\n                .client = client,\\\\\\\\n                .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n                .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n                .headers_callback = s_range_requests_headers_callback,\\\\\\\\n                .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n                .get_options =\\\\\\\\n                    {\\\\\\\\n                        .object_path = object_names[object_name_index],\\\\\\\\n                        .object_range = ranges[range_index],\\\\\\\\n                    },\\\\\\\\n                .sse_type = object_sse_types[object_name_index],\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            {\\\\\\\\n                struct range_requests_test_user_data test_user_data = {\\\\\\\\n                    .headers = range_get_headers,\\\\\\\\n                    .body_buffer = &range_get_buffer,\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                tester.user_data = &test_user_data;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            /* Send a default meta request (which just pushes the request directly to S3) with the same options to\\\\\\\\n             * verify the format of each request. */\\\\\\\\n            struct aws_s3_tester_meta_request_options verify_options = {\\\\\\\\n                .allocator = allocator,\\\\\\\\n                .client = client,\\\\\\\\n                .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n                .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n                .headers_callback = s_range_requests_headers_callback,\\\\\\\\n                .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n                .default_type_options =\\\\\\\\n                    {\\\\\\\\n                        .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                        .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n                    },\\\\\\\\n                .get_options =\\\\\\\\n                    {\\\\\\\\n                        .object_path = object_names[object_name_index],\\\\\\\\n                        .object_range = ranges[range_index],\\\\\\\\n                    },\\\\\\\\n                .sse_type = object_sse_types[object_name_index],\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            {\\\\\\\\n                struct range_requests_test_user_data test_user_data = {\\\\\\\\n                    .headers = verify_range_get_headers,\\\\\\\\n                    .body_buffer = &verify_range_get_buffer,\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                tester.user_data = &test_user_data;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &verify_options, NULL));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            /* Compare headers. */\\\\\\\\n            for (size_t i = 0; i < aws_http_headers_count(verify_range_get_headers); ++i) {\\\\\\\\n                struct aws_http_header verify_header;\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get_index(verify_range_get_headers, i, &verify_header));\\\\\\\\n\\\\\\\\n                bool ignore_header = false;\\\\\\\\n\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_to_ignore); ++j) {\\\\\\\\n                    if (aws_byte_cursor_eq_ignore_case(&headers_to_ignore[j], &verify_header.name)) {\\\\\\\\n                        ignore_header = true;\\\\\\\\n                        break;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                if (ignore_header) {\\\\\\\\n                    aws_http_headers_erase(range_get_headers, verify_header.name);\\\\\\\\n                    continue;\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                AWS_LOGF_INFO(\\\\\\\\n                    AWS_LS_S3_GENERAL,\\\\\\\\n                    \\\\\\\\\\\\\"%d,%d Checking for header \\\\\\\\\\\\\" PRInSTR,\\\\\\\\n                    (int)object_name_index,\\\\\\\\n                    (int)range_index,\\\\\\\\n                    AWS_BYTE_CURSOR_PRI(verify_header.name));\\\\\\\\n\\\\\\\\n                struct aws_byte_cursor header_value;\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get(range_get_headers, verify_header.name, &header_value));\\\\\\\\n\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_that_should_match); ++j) {\\\\\\\\n                    if (!aws_byte_cursor_eq_ignore_case(&headers_that_should_match[j], &verify_header.name)) {\\\\\\\\n                        continue;\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    AWS_LOGF_INFO(\\\\\\\\n                        AWS_LS_S3_GENERAL,\\\\\\\\n                        \\\\\\\\\\\\\"%d,%d Header Contents \\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\" vs \\\\\\\\\\\\\" PRInSTR,\\\\\\\\n                        (int)object_name_index,\\\\\\\\n                        (int)range_index,\\\\\\\\n                        AWS_BYTE_CURSOR_PRI(verify_header.value),\\\\\\\\n                        AWS_BYTE_CURSOR_PRI(header_value));\\\\\\\\n\\\\\\\\n                    ASSERT_TRUE(aws_byte_cursor_eq(&verify_header.value, &header_value));\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_erase(range_get_headers, verify_header.name));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            for (size_t i = 0; i < aws_http_headers_count(range_get_headers); ++i) {\\\\\\\\n                struct aws_http_header header;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get_index(range_get_headers, i, &header));\\\\\\\\n                bool ignore_header = false;\\\\\\\\n\\\\\\\\n                /* If the ignore header doesn\\'t exist in the verify_range_get_headers, ignore it here. */\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_to_ignore); ++j) {\\\\\\\\n                    if (aws_byte_cursor_eq_ignore_case(&headers_to_ignore[j], &header.name)) {\\\\\\\\n                        ignore_header = true;\\\\\\\\n                        break;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                if (ignore_header) {\\\\\\\\n                    ASSERT_SUCCESS(aws_http_headers_erase(range_get_headers, header.name));\\\\\\\\n                    continue;\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                AWS_LOGF_INFO(AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Left over header: \\\\\\\\\\\\\" PRInSTR, AWS_BYTE_CURSOR_PRI(header.name));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(aws_http_headers_count(range_get_headers) == 0);\\\\\\\\n\\\\\\\\n            /* Compare Body Contents */\\\\\\\\n            ASSERT_TRUE(aws_byte_buf_eq(&range_get_buffer, &verify_range_get_buffer));\\\\\\\\n\\\\\\\\n            aws_http_headers_release(range_get_headers);\\\\\\\\n            aws_byte_buf_clean_up(&range_get_buffer);\\\\\\\\n\\\\\\\\n            aws_http_headers_release(verify_range_get_headers);\\\\\\\\n            aws_byte_buf_clean_up(&verify_range_get_buffer);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_not_satisfiable_range, s_test_s3_not_satisfiable_range)\\\\\\\\nstatic int s_test_s3_not_satisfiable_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .headers_callback = s_range_requests_headers_callback,\\\\\\\\n        .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=2097151-\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_416_REQUESTED_RANGE_NOT_SATISFIABLE, results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_invalid_start_range_greator_than_end_range, s_test_s3_invalid_start_range_greator_than_end_range)\\\\\\\\nstatic int s_test_s3_invalid_start_range_greator_than_end_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=20-10\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n    ASSERT_INT_EQUALS(results.finished_error_code, AWS_ERROR_S3_INVALID_RANGE_HEADER);\\\\\\\\n    ASSERT_INT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_invalid_empty_file_with_range, s_test_s3_invalid_empty_file_with_range)\\\\\\\\nstatic int s_test_s3_invalid_empty_file_with_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_empty_object,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-0\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_416_REQUESTED_RANGE_NOT_SATISFIABLE, results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_copy_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor source_key,\\\\\\\\n    struct aws_byte_cursor destination_key,\\\\\\\\n    int expected_error_code,\\\\\\\\n    int expected_response_status,\\\\\\\\n    uint64_t expected_size) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    struct aws_byte_buf encoded_path;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n    AWS_ZERO_STRUCT(encoded_path);\\\\\\\\n\\\\\\\\n    aws_byte_buf_init(&encoded_path, allocator, source_key.len);\\\\\\\\n    aws_byte_buf_append_encoding_uri_path(&encoded_path, &source_key);\\\\\\\\n\\\\\\\\n    /* without copy_source_uri */\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    /* with path style copy_source_uri */\\\\\\\\n    char source_url[1024];\\\\\\\\n    snprintf(\\\\\\\\n        source_url,\\\\\\\\n        sizeof(source_url),\\\\\\\\n        \\\\\\\\\\\\\"https://s3.%s.amazonaws.com/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"\\\\\\\\\\\\\",\\\\\\\\n        g_test_s3_region.ptr,\\\\\\\\n        AWS_BYTE_CURSOR_PRI(source_bucket),\\\\\\\\n        AWS_BYTE_BUF_PRI(encoded_path));\\\\\\\\n    copy_source_uri = aws_byte_cursor_from_c_str(source_url);\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    /* with virtual style copy_source_uri */\\\\\\\\n    snprintf(\\\\\\\\n        source_url,\\\\\\\\n        sizeof(source_url),\\\\\\\\n        \\\\\\\\\\\\\"https://\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\".s3.%s.amazonaws.com/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(source_bucket),\\\\\\\\n        g_test_s3_region.ptr,\\\\\\\\n        AWS_BYTE_BUF_PRI(encoded_path));\\\\\\\\n    copy_source_uri = aws_byte_cursor_from_c_str(source_url);\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_byte_buf_clean_up(&encoded_path);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_small_object, s_test_s3_copy_small_object)\\\\\\\\nstatic int s_test_s3_copy_small_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, MB_TO_BYTES(1));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_small_object_special_char, s_test_s3_copy_small_object_special_char)\\\\\\\\nstatic int s_test_s3_copy_small_object_special_char(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB-@\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB_@\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, MB_TO_BYTES(1));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_copy_large_object_special_char, s_test_s3_multipart_copy_large_object_special_char)\\\\\\\\nstatic int s_test_s3_multipart_copy_large_object_special_char(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-2GB-@\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_2GB-@\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, GB_TO_BYTES(2));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_copy_large_object, s_test_s3_multipart_copy_large_object)\\\\\\\\nstatic int s_test_s3_multipart_copy_large_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-2GB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_2GB\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, GB_TO_BYTES(2));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_object_invalid_source_key, s_test_s3_copy_object_invalid_source_key)\\\\\\\\nstatic int s_test_s3_copy_object_invalid_source_key(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"__INVALID__\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/__INVALID__\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        source_key,\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_S3_INVALID_RESPONSE_STATUS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_404_NOT_FOUND,\\\\\\\\n        0 /* expected_size is ignored */);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test a bypass Copy Object meta request using a slash prefix in the x_amz_copy_source header.\\\\\\\\n * S3 supports both bucket/key and /bucket/key\\\\\\\\n * This test validates the fix for the bug described in https://sim.amazon.com/issues/AWSCRT-730\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_copy_source_prefixed_by_slash, s_test_s3_copy_source_prefixed_by_slash)\\\\\\\\nstatic int s_test_s3_copy_source_prefixed_by_slash(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK,\\\\\\\\n        MB_TO_BYTES(1),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_invalid_source_uri, s_test_s3_copy_invalid_source_uri)\\\\\\\\nstatic int s_test_s3_copy_invalid_source_uri(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"http://invalid-uri.com:80:80/path\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_MALFORMED_INPUT_STRING,\\\\\\\\n        0,\\\\\\\\n        MB_TO_BYTES(1),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test multipart Copy Object meta request using a slash prefix in the x_amz_copy_source header.\\\\\\\\n * S3 supports both bucket/key and /bucket/key\\\\\\\\n * This test validates the fix for the bug described in https://sim.amazon.com/issues/AWSCRT-730\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_copy_source_prefixed_by_slash_multipart, s_test_s3_copy_source_prefixed_by_slash_multipart)\\\\\\\\nstatic int s_test_s3_copy_source_prefixed_by_slash_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-256MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_256MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK,\\\\\\\\n        MB_TO_BYTES(256),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_get_object_mrap_helper(struct aws_allocator *allocator, bool multipart) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_signing_config_aws signing_config = tester.default_signing_config;\\\\\\\\n    /* Use Sigv4A for signing */\\\\\\\\n    signing_config.algorithm = AWS_SIGNING_ALGORITHM_V4_ASYMMETRIC;\\\\\\\\n    /* Use * for region to sign */\\\\\\\\n    signing_config.region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = multipart ? 64 * 1024 : 20 * 1024 * 1024,\\\\\\\\n        .region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\"),\\\\\\\\n        .signing_config = &signing_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0 /*flag*/));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .mrap_test = true,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test single-part get object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_less_than_part_size_mrap, s_test_s3_get_object_less_than_part_size_mrap)\\\\\\\\nstatic int s_test_s3_get_object_less_than_part_size_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_get_object_mrap_helper(allocator, false /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test multi-part get object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multipart_mrap, s_test_s3_get_object_multipart_mrap)\\\\\\\\nstatic int s_test_s3_get_object_multipart_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_get_object_mrap_helper(allocator, true /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_put_object_mrap_helper(struct aws_allocator *allocator, bool multipart) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_signing_config_aws signing_config = tester.default_signing_config;\\\\\\\\n    /* Use Sigv4A for signing */\\\\\\\\n    signing_config.algorithm = AWS_SIGNING_ALGORITHM_V4_ASYMMETRIC;\\\\\\\\n    /* Use * for region to sign */\\\\\\\\n    signing_config.region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n        .region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\"),\\\\\\\\n        .signing_config = &signing_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0 /*flag*/));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .mrap_test = true,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = multipart ? 10 : 1,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test single-part put object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_less_than_part_size_mrap, s_test_s3_put_object_less_than_part_size_mrap)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_put_object_mrap_helper(allocator, false /*multipart*/);\\\\\\\\n}\\\\\\\\n/* Test multi-part put object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multipart_mrap, s_test_s3_put_object_multipart_mrap)\\\\\\\\nstatic int s_test_s3_put_object_multipart_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_put_object_mrap_helper(allocator, true /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_http_message *s_put_object_request_new(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor key,\\\\\\\\n    struct aws_byte_cursor endpoint,\\\\\\\\n    struct aws_input_stream *body_stream,\\\\\\\\n    uint64_t content_length) {\\\\\\\\n\\\\\\\\n    AWS_PRECONDITION(allocator);\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n\\\\\\\\n    if (message == NULL) {\\\\\\\\n        return NULL;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if (aws_http_message_set_request_path(message, key)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_http_header host_header = {\\\\\\\\n        .name = g_host_header_name,\\\\\\\\n        .value = endpoint,\\\\\\\\n    };\\\\\\\\n    if (aws_http_message_add_header(message, host_header)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    char content_length_c_str[1024];\\\\\\\\n    snprintf(content_length_c_str, sizeof(content_length_c_str), \\\\\\\\\\\\\"%\\\\\\\\\\\\\" PRIu64, content_length);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_length_header = {\\\\\\\\n        .name = g_content_length_header_name,\\\\\\\\n        .value = aws_byte_cursor_from_c_str(content_length_c_str),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    if (aws_http_message_add_header(message, content_length_header)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if (aws_http_message_set_request_method(message, aws_http_method_put)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_set_body_stream(message, body_stream);\\\\\\\\n\\\\\\\\n    return message;\\\\\\\\n\\\\\\\\nerror_clean_up_message:\\\\\\\\n\\\\\\\\n    if (message != NULL) {\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n        message = NULL;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return NULL;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct put_object_pause_resume_test_data {\\\\\\\\n    struct aws_mutex mutex;\\\\\\\\n    struct aws_condition_variable c_var;\\\\\\\\n\\\\\\\\n    /* execution of the test meta request completed */\\\\\\\\n    bool execution_completed;\\\\\\\\n\\\\\\\\n    /* accumulator of amount of bytes uploaded */\\\\\\\\n    struct aws_atomic_var total_bytes_uploaded;\\\\\\\\n\\\\\\\\n    /* the offset where upload should be paused */\\\\\\\\n    struct aws_atomic_var request_pause_offset;\\\\\\\\n\\\\\\\\n    struct aws_atomic_var pause_requested;\\\\\\\\n\\\\\\\\n    struct aws_atomic_var pause_result;\\\\\\\\n\\\\\\\\n    /* the persistable state of the paused request */\\\\\\\\n    struct aws_atomic_var persistable_state_ptr;\\\\\\\\n\\\\\\\\n    int meta_request_error_code;\\\\\\\\n    int response_status_code;\\\\\\\\n\\\\\\\\n    /* (Optional) content_length to send. If not set, use the length of the input stream. */\\\\\\\\n    uint64_t content_length;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic void s_put_pause_resume_meta_request_finish(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *meta_request_result,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    struct aws_s3_tester *tester = user_data;\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = tester->user_data;\\\\\\\\n\\\\\\\\n    /* if error response body is available, dump it to test result to help investigation of failed tests */\\\\\\\\n    if (meta_request_result->error_response_body != NULL && meta_request_result->error_response_body->len > 0) {\\\\\\\\n        AWS_LOGF_ERROR(\\\\\\\\n            AWS_LS_S3_GENERAL,\\\\\\\\n            \\\\\\\\\\\\\"Response error body: %.*s\\\\\\\\\\\\\",\\\\\\\\n            (int)meta_request_result->error_response_body->len,\\\\\\\\n            meta_request_result->error_response_body->buffer);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_mutex_lock(&test_data->mutex);\\\\\\\\n    test_data->meta_request_error_code = meta_request_result->error_code;\\\\\\\\n    test_data->response_status_code = meta_request_result->response_status;\\\\\\\\n    test_data->execution_completed = true;\\\\\\\\n    aws_mutex_unlock(&test_data->mutex);\\\\\\\\n    aws_condition_variable_notify_one(&test_data->c_var);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic bool s_put_pause_resume_test_completion_predicate(void *arg) {\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = arg;\\\\\\\\n    return test_data->execution_completed;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Patched version of aws_s3_meta_request_vtable->finished_request() for pause/resume tests.\\\\\\\\n * It can pause the meta-request immediately after a part completes.\\\\\\\\n * We use a patched vtable, instead of the progress_callback, because\\\\\\\\n * the progress_callback fires on another thread, which might be too late to\\\\\\\\n * prevent more parts from being sent. */\\\\\\\\nstatic void s_meta_request_finished_request_patched_for_pause_resume_tests(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    struct aws_s3_tester *tester = meta_request->user_data;\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = tester->user_data;\\\\\\\\n    AWS_ASSERT(test_data);\\\\\\\\n\\\\\\\\n    if ((error_code == AWS_ERROR_SUCCESS) && (meta_request->type == AWS_S3_META_REQUEST_TYPE_PUT_OBJECT) &&\\\\\\\\n        (request->request_tag == AWS_S3_AUTO_RANGED_PUT_REQUEST_TAG_PART)) {\\\\\\\\n\\\\\\\\n        if (!request->is_noop) {\\\\\\\\n            /* If the request is noop, we are not really uploading the part */\\\\\\\\n            aws_atomic_fetch_add(&test_data->total_bytes_uploaded, request->request_body.len);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        size_t total_bytes_uploaded = aws_atomic_load_int(&test_data->total_bytes_uploaded);\\\\\\\\n        uint64_t offset_to_pause = aws_atomic_load_int(&test_data->request_pause_offset);\\\\\\\\n\\\\\\\\n        if (total_bytes_uploaded >= offset_to_pause) {\\\\\\\\n            /* offset of the upload at which we should pause was reached. let\\'s pause the upload */\\\\\\\\n            /* if the meta request has already been paused previously, do nothing. */\\\\\\\\n            size_t expected = false;\\\\\\\\n            bool request_pause = aws_atomic_compare_exchange_int(&test_data->pause_requested, &expected, true);\\\\\\\\n            if (request_pause) {\\\\\\\\n                struct aws_s3_meta_request_resume_token *resume_token = NULL;\\\\\\\\n                int pause_result = aws_s3_meta_request_pause(meta_request, &resume_token);\\\\\\\\n                struct aws_byte_cursor upload_id = aws_s3_meta_request_resume_token_upload_id(resume_token);\\\\\\\\n                /* Make Sure we have upload ID */\\\\\\\\n                AWS_FATAL_ASSERT(aws_byte_cursor_eq_c_str(&upload_id, \\\\\\\\\\\\\"\\\\\\\\\\\\\") == false);\\\\\\\\n                aws_atomic_store_int(&test_data->pause_result, pause_result);\\\\\\\\n                aws_atomic_store_ptr(&test_data->persistable_state_ptr, resume_token);\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Continue with original vtable function... */\\\\\\\\n    struct aws_s3_meta_request_vtable *original_meta_request_vtable =\\\\\\\\n        aws_s3_tester_get_meta_request_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    original_meta_request_vtable->finished_request(meta_request, request, error_code);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_s3_meta_request *s_meta_request_factory_patch_for_pause_resume_tests(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    const struct aws_s3_meta_request_options *options) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(client != NULL);\\\\\\\\n    struct aws_s3_tester *tester = client->shutdown_callback_user_data;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *original_client_vtable =\\\\\\\\n        aws_s3_tester_get_client_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = original_client_vtable->meta_request_factory(client, options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *patched_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(tester, meta_request, NULL);\\\\\\\\n    patched_meta_request_vtable->finished_request = s_meta_request_finished_request_patched_for_pause_resume_tests;\\\\\\\\n\\\\\\\\n    return meta_request;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* total length of the object to simulate for upload */\\\\\\\\nstatic const size_t s_pause_resume_object_length_128MB = 128 * 1024 * 1024;\\\\\\\\n\\\\\\\\n/* this runs when a RESUMED upload is about to successfully complete */\\\\\\\\nstatic int s_pause_resume_upload_review_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_upload_review *review,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)user_data;\\\\\\\\n    struct aws_allocator *allocator = meta_request->allocator;\\\\\\\\n\\\\\\\\n    /* A bit hacky, but stream the same data that the test always uploads, and ensure the checksums match */\\\\\\\\n\\\\\\\\n    struct aws_input_stream *reread_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    for (size_t part_index = 0; part_index < review->part_count; ++part_index) {\\\\\\\\n        const struct aws_s3_upload_part_review *part_review = &review->part_array[part_index];\\\\\\\\n        struct aws_byte_buf reread_part_buf;\\\\\\\\n        ASSERT_TRUE(part_review->size <= SIZE_MAX);\\\\\\\\n        aws_byte_buf_init(&reread_part_buf, allocator, (size_t)part_review->size);\\\\\\\\n        ASSERT_SUCCESS(aws_input_stream_read(reread_stream, &reread_part_buf));\\\\\\\\n\\\\\\\\n        /* part sizes should match */\\\\\\\\n        ASSERT_UINT_EQUALS(part_review->size, reread_part_buf.len);\\\\\\\\n\\\\\\\\n        if (review->checksum_algorithm != AWS_SCA_NONE) {\\\\\\\\n            struct aws_byte_cursor reread_part_cursor = aws_byte_cursor_from_buf(&reread_part_buf);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf checksum_buf;\\\\\\\\n            aws_byte_buf_init(&checksum_buf, allocator, 128);\\\\\\\\n            ASSERT_SUCCESS(\\\\\\\\n                aws_checksum_compute(allocator, review->checksum_algorithm, &reread_part_cursor, &checksum_buf));\\\\\\\\n            struct aws_byte_cursor checksum_cursor = aws_byte_cursor_from_buf(&checksum_buf);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf encoded_checksum_buf;\\\\\\\\n            aws_byte_buf_init(&encoded_checksum_buf, allocator, 128);\\\\\\\\n\\\\\\\\n            ASSERT_SUCCESS(aws_base64_encode(&checksum_cursor, &encoded_checksum_buf));\\\\\\\\n\\\\\\\\n            /* part checksums should match */\\\\\\\\n            ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n                encoded_checksum_buf.buffer,\\\\\\\\n                encoded_checksum_buf.len,\\\\\\\\n                part_review->checksum.ptr,\\\\\\\\n                part_review->checksum.len);\\\\\\\\n\\\\\\\\n            aws_byte_buf_clean_up(&checksum_buf);\\\\\\\\n            aws_byte_buf_clean_up(&encoded_checksum_buf);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_byte_buf_clean_up(&reread_part_buf);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_input_stream_release(reread_stream);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_pause_resume_receive_body_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)range_start;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    // TODO: this is a bit hacky, as it will try to compare every partial get result we receive to the input stream.\\\\\\\\n    // Something better?\\\\\\\\n\\\\\\\\n    struct aws_input_stream *input_stream =\\\\\\\\n        aws_s3_test_input_stream_new(meta_request->allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf buf;\\\\\\\\n    aws_byte_buf_init(&buf, meta_request->allocator, (size_t)range_start);\\\\\\\\n    aws_input_stream_read(input_stream, &buf);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&buf);\\\\\\\\n    aws_byte_buf_init(&buf, meta_request->allocator, body->len);\\\\\\\\n    aws_input_stream_read(input_stream, &buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor input_cur = aws_byte_cursor_from_buf(&buf);\\\\\\\\n\\\\\\\\n    bool body_matches_expected = aws_byte_cursor_eq(&input_cur, body);\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(input_stream);\\\\\\\\n    aws_byte_buf_clean_up(&buf);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_matches_expected);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_pause_resume_helper(\\\\\\\\n    struct aws_s3_tester *tester,\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    struct put_object_pause_resume_test_data *test_data,\\\\\\\\n    struct aws_byte_cursor destination_key,\\\\\\\\n    struct aws_input_stream *upload_body_stream,\\\\\\\\n    struct aws_s3_meta_request_resume_token *resume_state,\\\\\\\\n    enum aws_s3_checksum_algorithm checksum_algorithm,\\\\\\\\n    int expected_error_code,\\\\\\\\n    int expected_response_status) {\\\\\\\\n\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    if (resume_state == NULL) {\\\\\\\\n        /* If we\\'re going to cancel this operation, limit the client to 1 HTTP connection.\\\\\\\\n         * That way, we don\\'t end up \\\\\\\\\\\\\"cancelling\\\\\\\\\\\\\" but all the parts actually\\\\\\\\n         * succeed anyway on other connections */\\\\\\\\n        client_config.max_active_connections_override = 1;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(tester, client, NULL);\\\\\\\\n    patched_client_vtable->meta_request_factory = s_meta_request_factory_patch_for_pause_resume_tests;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    /* creates a PutObject request */\\\\\\\\n    int64_t content_length = test_data->content_length;\\\\\\\\n    if (content_length == 0) {\\\\\\\\n        /* If not set, use the length of the input stream */\\\\\\\\n        aws_input_stream_get_length(upload_body_stream, &content_length);\\\\\\\\n    }\\\\\\\\n    struct aws_http_message *message = s_put_object_request_new(\\\\\\\\n        allocator, destination_key, aws_byte_cursor_from_c_str(endpoint), upload_body_stream, content_length);\\\\\\\\n\\\\\\\\n    test_data->c_var = (struct aws_condition_variable)AWS_CONDITION_VARIABLE_INIT;\\\\\\\\n    aws_mutex_init(&test_data->mutex);\\\\\\\\n    test_data->execution_completed = false;\\\\\\\\n\\\\\\\\n    tester->user_data = test_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_checksum_config checksum_config = {\\\\\\\\n        .checksum_algorithm = checksum_algorithm,\\\\\\\\n        .location = checksum_algorithm == AWS_SCA_NONE ? AWS_SCL_NONE : AWS_SCL_TRAILER,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options meta_request_options = {\\\\\\\\n        .user_data = tester,\\\\\\\\n        .body_callback = NULL,\\\\\\\\n        .signing_config = client_config.signing_config,\\\\\\\\n        .finish_callback = s_put_pause_resume_meta_request_finish,\\\\\\\\n        .headers_callback = NULL,\\\\\\\\n        .upload_review_callback = s_pause_resume_upload_review_callback,\\\\\\\\n        .message = message,\\\\\\\\n        .shutdown_callback = NULL,\\\\\\\\n        .resume_token = NULL,\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_config = &checksum_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    if (resume_state) {\\\\\\\\n        meta_request_options.resume_token = resume_state;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &meta_request_options);\\\\\\\\n    ASSERT_NOT_NULL(meta_request);\\\\\\\\n\\\\\\\\n    /* wait completion of the meta request */\\\\\\\\n    aws_mutex_lock(&test_data->mutex);\\\\\\\\n    aws_condition_variable_wait_pred(\\\\\\\\n        &test_data->c_var, &test_data->mutex, s_put_pause_resume_test_completion_predicate, test_data);\\\\\\\\n    aws_mutex_unlock(&test_data->mutex);\\\\\\\\n\\\\\\\\n    /* assert error_code and response_status_code */\\\\\\\\n    ASSERT_INT_EQUALS(expected_error_code, test_data->meta_request_error_code);\\\\\\\\n    ASSERT_INT_EQUALS(expected_response_status, test_data->response_status_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_mutex_clean_up(&test_data->mutex);\\\\\\\\n    aws_http_message_destroy(message);\\\\\\\\n\\\\\\\\n    /* release this client with its crazy patched vtables */\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_wait_for_client_shutdown(tester);\\\\\\\\n    tester->bound_to_client = false;\\\\\\\\n\\\\\\\\n    if (expected_error_code == AWS_ERROR_SUCCESS) {\\\\\\\\n        /* get the file and verify it matches what we uploaded */\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .body_callback = s_pause_resume_receive_body_callback,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = destination_key,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_test_results results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(tester, &options, &results));\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_happy_path, s_test_s3_put_pause_resume_happy_path)\\\\\\\\nstatic int s_test_s3_put_pause_resume_happy_path(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded < s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_all_parts_done, s_test_s3_put_pause_resume_all_parts_done)\\\\\\\\nstatic int s_test_s3_put_pause_resume_all_parts_done(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_all_parts_done.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 128 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_NONE,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    AWS_LOGF_INFO(AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Persistable state %p\\\\\\\\\\\\\", persistable_state);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_NONE,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_INT_EQUALS(0, bytes_uploaded);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_resume_data, s_test_s3_put_pause_resume_invalid_resume_data)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_resume_data(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_resume_data.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_s3_test_input_stream_new_with_value_type(\\\\\\\\n        allocator, s_pause_resume_object_length_128MB, TEST_STREAM_VALUE_2);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_RESUMED_PART_CHECKSUM_MISMATCH,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded < s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_resume_stream, s_test_s3_put_pause_resume_invalid_resume_stream)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_resume_stream(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_bad_resume_stream.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_release(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* a bad input stream to resume from */\\\\\\\\n    struct aws_input_stream_tester_options stream_options = {\\\\\\\\n        .autogen_length = s_pause_resume_object_length_128MB,\\\\\\\\n        .fail_on_nth_read = 1,\\\\\\\\n        .fail_with_error_code = AWS_IO_STREAM_READ_FAILED,\\\\\\\\n    };\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_input_stream_new_tester(allocator, &stream_options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    /* Each failed resume will delete the MPU */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_IO_STREAM_READ_FAILED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* resume didn\\'t read any bytes because the bad input stream failed to read. */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded == 0);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_release(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_content_length, s_test_s3_put_pause_resume_invalid_content_length)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_bad_resume_stream.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n    test_data.content_length = s_pause_resume_object_length_128MB;\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_release(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* a small input stream to resume with */\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_s3_test_input_stream_new(allocator, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    /* Each failed resume will delete the MPU */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_INCORRECT_CONTENT_LENGTH,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* resume didn\\'t read any bytes because the bad input stream failed to read. */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded == 0);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_release(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Most basic test of the upload_review_callback */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review, s_test_s3_upload_review)\\\\\\\\nstatic int s_test_s3_upload_review(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_CRC32.txt\\\\\\\\\\\\\"),\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(2, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(8), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(10) - MB_TO_BYTES(8), test_results.upload_review.part_sizes_array[1]);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_SCA_CRC32, test_results.upload_review.checksum_algorithm);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"9J8ZNA==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"BNjxzQ==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[1]));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test upload_review_callback when Content-Length is not declared */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_no_content_length, s_test_s3_upload_review_no_content_length)\\\\\\\\nstatic int s_test_s3_upload_review_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_1MB_CRC32.txt\\\\\\\\\\\\\"),\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"4hP4ig==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_upload_review_raise_canceled_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_upload_review *review,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)review;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    return aws_raise_error(AWS_ERROR_S3_CANCELED);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that if upload_review_callback raises an error, then the upload is canceled. */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_rejection, s_test_s3_upload_review_rejection)\\\\\\\\nstatic int s_test_s3_upload_review_rejection(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_rejection.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    /* Send meta-request that will raise an error from the review_upload_callback */\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .upload_review_callback = s_upload_review_raise_canceled_error,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* Check that meta-request failed with the error raised by the upload_review_callback */\\\\\\\\n    ASSERT_INT_EQUALS(AWS_ERROR_S3_CANCELED, test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    /*\\\\\\\\n     * Now check that the upload did not complete on the server either\\\\\\\\n     * (server should have received AbortMultipartUpload).\\\\\\\\n     * Check by attempting to GET the object, which should fail with 404 NOT FOUND.\\\\\\\\n     */\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &test_results));\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_404_NOT_FOUND, test_results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(test_results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(test_results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(test_results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that an MPU can be done with checksum location = NONE as long as an upload review callback\\\\\\\\n * is used, and the resulting object doesn\\'t have checksums uploaded. */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_checksum_location_none, s_test_s3_upload_review_checksum_location_none)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(2, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(5), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(5), test_results.upload_review.part_sizes_array[1]);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_SCA_CRC32, test_results.upload_review.checksum_algorithm);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"7/xUXw==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"PCOjcw==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[1]));\\\\\\\\n\\\\\\\\n    /* S3 will store the crc64 checksum for the whole object, and we can still have validate the checksum, but the algo\\\\\\\\n     * be validated will be crc64, instead of the crc32 we get from the client. */\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC64NVME,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_checksum_location_none_async, s_test_s3_upload_review_checksum_location_none_async)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none_async(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Trying to reach the noop case of async read */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_upload_review_checksum_location_none_async_noop_part,\\\\\\\\n    s_test_s3_upload_review_checksum_location_none_async_noop_part)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none_async_noop_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n                .eof_requires_extra_read = true, /* don\\'t report EOF until it tries to read 2nd part */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_http_stream *s_http_connection_make_request_patch(\\\\\\\\n    struct aws_http_connection *client_connection,\\\\\\\\n    const struct aws_http_make_request_options *options) {\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = options->request;\\\\\\\\n    struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n    struct aws_byte_cursor out_value;\\\\\\\\n    int e = aws_http_headers_get(headers, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"Content-Length\\\\\\\\\\\\\"), &out_value);\\\\\\\\n    AWS_FATAL_ASSERT(e == AWS_OP_ERR); // Assert that the header is not present\\\\\\\\n    AWS_FATAL_ASSERT(aws_last_error() == AWS_ERROR_HTTP_HEADER_NOT_FOUND);\\\\\\\\n\\\\\\\\n    return aws_http_connection_make_request(client_connection, options);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_get_without_content_length, s_test_s3_default_get_without_content_length)\\\\\\\\nstatic int s_test_s3_default_get_without_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    /* Send default type */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.message = message;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct aws_string *test_helper(struct aws_allocator *allocator) {\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n    return host_name;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_get, aws_test_s3_default_get)\\\\\\\\nstatic int aws_test_s3_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_string *hsot_name = test_helper(allocator);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(hsot_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    /* Send default type */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.message = message;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\",\\\\n  \\\\\"encoding\\\\\": \\\\\"base64\\\\\",\\\\n  \\\\\"_links\\\\\": {\\\\n    \\\\\"self\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests/s3_data_plane_tests.c?ref=dummy-delete-me\\\\\",\\\\n    \\\\\"git\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/git/blobs/dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n    \\\\\"html\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\"\\\\n  }\\\\n}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Let me also check the style/guidelines for making comments based on the provided file:\"},{\"type\":\"tool_use\",\"name\":\"filesystem-read_file\",\"input\":{\"path\":\"/Users/dengket/project/hackthon/fast-agent/crt_c_reviewer/summarization/comments_styles.md\"},\"id\":\"toolu_bdrk_018DzUdiHAH8pa4rNEPKDWZT\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_018DzUdiHAH8pa4rNEPKDWZT\",\"content\":[{\"type\":\"text\",\"text\":\"# Effective Code Review Comment Guidelines\\\\n\\\\nBased on an analysis of multiple GitHub Pull Request reviews, this document summarizes key patterns and best practices for writing effective code review comments.\\\\n\\\\n## General Principles\\\\n\\\\n### 1. Comment Classification\\\\n\\\\n* **Use clear prefixes to indicate severity:**\\\\n  + `trivial:` - Minor issues that should be fixed but don\\'t block approval\\\\n  + `debatable:` or `extremely debatable:` - Suggestions open to discussion\\\\n  + `nit:` - Extremely minor stylistic preferences\\\\n  + `important:` - Issues that should be addressed before merging\\\\n  + `blocking:` - Critical issues that must be resolved\\\\n\\\\n* **Be explicit about expectations:**\\\\n  + Distinguish between mandatory changes and optional suggestions\\\\n  + Indicate when comments are informational rather than requesting changes\\\\n\\\\n### 2. Comment Structure\\\\n\\\\n* **Be specific and actionable:**\\\\n  + Refer to specific lines or sections of code\\\\n  + Explain both what the issue is and why it matters\\\\n  + Provide concrete solutions when possible\\\\n\\\\n* **Use GitHub suggestion blocks for direct code changes:**\\\\n  \\\\n\\\\n```\\\\n  ```suggestion\\\\n  actual code change goes here\\\\n  ```\\\\n\\\\n  \\\\n\\\\n```\\\\n\\\\n- **Group related issues together:**\\\\n  - Number multiple points for clarity\\\\n  - Address similar issues in a single comment when possible\\\\n\\\\n- **Provide context:**\\\\n  - Link to relevant documentation, PRs, or issues\\\\n  - Reference cross-repository standards when applicable\\\\n  - Explain reasoning behind suggestions, not just what to change\\\\n\\\\n### 3. Comment Scope\\\\n\\\\n- **Focus on the right level of detail:**\\\\n  - For simple PRs: Brief approvals may be sufficient\\\\n  - For complex PRs: Detailed, organized feedback is necessary\\\\n\\\\n- **Consider multiple aspects of code quality:**\\\\n  - Functional correctness\\\\n  - Error handling and edge cases\\\\n  - Performance implications\\\\n  - Security considerations\\\\n  - Consistency with existing patterns\\\\n  - Documentation and readability\\\\n  - Cross-platform compatibility\\\\n  - API design and usability\\\\n\\\\n## Technical Focus Areas\\\\n\\\\n### 1. Code Architecture and Design\\\\n\\\\n- **API Usability:**\\\\n  - Consider the developer experience of using the API\\\\n  - Question potentially confusing or redundant API requirements\\\\n  - Think about cross-language compatibility\\\\n\\\\n- **Error Handling:**\\\\n  - Verify proper cleanup in error cases\\\\n  - Ensure appropriate error propagation\\\\n  - Check for consistent error handling patterns\\\\n  - In C code, prefer unified error paths with consolidated cleanup\\\\n\\\\n- **Consistency:**\\\\n  - Flag inconsistent naming conventions\\\\n  - Highlight deviations from established patterns\\\\n  - Ensure consistency across related repositories\\\\n\\\\n### 2. Code Style and Readability\\\\n\\\\n- **Prioritize clear organization:**\\\\n  - Suggest clearer code structure when logic is hard to follow\\\\n  - Flag complex conditionals that could be simplified\\\\n  - Recommend extracting complex logic into well-named helper functions\\\\n\\\\n- **Comment on documentation:**\\\\n  - Ensure comments accurately describe behavior\\\\n  - Request documentation for parameters with specific usage requirements\\\\n  - Verify public API documentation clarity\\\\n\\\\n- **Focus on maintainability:**\\\\n  - Consider how code might evolve in the future\\\\n  - Identify fragile patterns that could break with future changes\\\\n  - Suggest explicit guards against potential future bugs\\\\n\\\\n### 3. Cross-Team and Ecosystem Considerations\\\\n\\\\n- **Coordinate across teams:**\\\\n  - Flag changes that might affect other teams or services\\\\n  - Recommend cross-team communication when necessary\\\\n\\\\n- **Verify ecosystem consistency:**\\\\n  - Check if behavior matches related SDKs or libraries\\\\n  - Confirm conformance to broader project standards\\\\n\\\\n## Review Process\\\\n\\\\n### 1. Reviewing Approach\\\\n\\\\n- **Progressive reviews:**\\\\n  - Start with critical issues and architectural concerns\\\\n  - Follow up on remaining issues after major concerns are addressed\\\\n  - Provide final approval once all necessary changes are made\\\\n\\\\n- **Approval comments:**\\\\n  - Use \\\\\"fix & ship\\\\\" for PRs with only minor issues\\\\n  - Include verification steps if needed before merging\\\\n  - Acknowledge when previous feedback has been addressed\\\\n\\\\n### 2. Review Tone\\\\n\\\\n- **Be direct but constructive:**\\\\n  - Focus on the code, not the person\\\\n  - Frame feedback as improvements rather than criticisms\\\\n  - Use a professional, collaborative tone\\\\n\\\\n- **Acknowledge good work:**\\\\n  - Provide positive feedback on well-implemented features\\\\n  - Recognize when authors have addressed previous feedback well\\\\n  - Use phrases like \\\\\"nice job\\\\\" or \\\\\"this looks good\\\\\" where appropriate\\\\n\\\\n- **Balance criticism with encouragement:**\\\\n  - Point out both strengths and areas for improvement\\\\n  - Recognize the effort that went into the implementation\\\\n\\\\n## Comment Examples by Category\\\\n\\\\n### Effective Trivial Comments\\\\n\\\\n```\\\\n\\\\ntrivial: undoing needless changes to whitespace\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\ntrivial: it\\'s weird to use the `_10MB` and then upload 5MB\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\ntrivial: I found this if-statement confusing, and the helper function that did different things depending on how it\\'s called...\\\\n\\\\n```\\\\n\\\\n### Effective Technical Suggestions\\\\n\\\\n```\\\\n\\\\nif there\\'s an error, we need to cleanup out_checksum\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nSo, if users already added a checksum header, they ALSO need to set this enum?\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nInstead of the `on_error:` label sharing 90% the same cleanup code as `s_s3_client_finish_destroy_default()` , have them share code\\\\n\\\\n```\\\\n\\\\n### Effective Process Comments\\\\n\\\\n```\\\\n\\\\nI\\'d advise checking this branch from aws-crt-cpp, and making sure it all works nicely, before merging\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nChecked the C++ SDK and Java SDK and they also retry on TLS errors.\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nneed to coordinate with python teams on this...\\\\n```\\\\n\\\\n### Silent Approvals (When Appropriate)\\\\n\\\\nSilent approvals (no comments, just approval) are appropriate for:\\\\n* Simple, straightforward changes\\\\n* Well-understood code\\\\n* Follow-up to previous discussions\\\\n* Self-explanatory code\\\\n* Trivial fixes\\\\n* When there\\'s an established trust relationship between reviewer and author\\\\n\\\\n## Special Cases\\\\n\\\\n### 1. Automated/Routine Changes\\\\n\\\\n* **Minimize comments for routine updates:**\\\\n  + For automated changes or version bumps, simple approvals may be sufficient\\\\n  + Focus comments on any unexpected deviations from expected patterns\\\\n\\\\n### 2. Cross-Repository Changes\\\\n\\\\n* **Consider broader impacts:**\\\\n  + For changes affecting multiple repositories, test across all affected codebases\\\\n  + Verify consistency with related repositories\\' standards\\\\n\\\\n### 3. Documentation Changes\\\\n\\\\n* **Focus on accuracy and clarity:**\\\\n  + Ensure documentation correctly describes behavior\\\\n  + Verify examples work as described\\\\n  + Check for consistent formatting and terminology\\\\n\\\\n## Conclusion\\\\n\\\\nEffective code review comments are specific, actionable, appropriately categorized, and delivered in a constructive tone. They focus on technical accuracy while maintaining readability and consistency with project standards. The level of detail should match the complexity of the change, ranging from brief approvals for simple changes to detailed, structured feedback for complex modifications.\\\\n\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now, let me query the knowledge base to learn about the aws-c-s3 library and understand the PR\\'s context better:\"},{\"type\":\"tool_use\",\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"input\":{\"query\":\"Tell me about the s3_data_plane_tests.c file in aws-c-s3. What is it for? How does it typically test functionality in aws-c-s3?\",\"knowledge_base_id\":\"8BRIG4RFWU\"},\"id\":\"toolu_bdrk_01VRr8YFCoDiHnWQsHEUufSM\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01VRr8YFCoDiHnWQsHEUufSM\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3express_credentials_provider_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3express_credentials_provider.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/atomics.h> #include <aws/common/clock.h> #include <aws/common/encoding.h> #include <aws/common/lru_cache.h> #include <aws/io/stream.h> #include <aws/io/uri.h> #include <aws/testing/aws_test_harness.h> #include <inttypes.h>  #define TEST_CASE(NAME)                                                                                                \\\\\\\\\\\\\\\\     AWS_TEST_CASE(NAME, s_test_##NAME);                                                                                \\\\\\\\\\\\\\\\     static int s_test_##NAME(struct aws_allocator *allocator, void *ctx)  #define DEFINE_HEADER(NAME, VALUE)                                                                                     \\\\\\\\\\\\\\\\     {                                                                                                                  \\\\\\\\\\\\\\\\         .name = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(NAME),                                                           \\\\\\\\\\\\\\\\         .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(VALUE),                                                         \\\\\\\\\\\\\\\\     }  struct aws_s3express_client_tester {     struct aws_allocator *allocator;     struct aws_hash_table saver_cache;     struct aws_atomic_var provider_requests_made; };  static struct aws_s3express_client_tester\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_s3express_client_test.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.54995424}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_checksums.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/byte_buf.h> #include <aws/common/clock.h> #include <aws/common/common.h> #include <aws/common/encoding.h> #include <aws/common/environment.h> #include <aws/common/ref_count.h> #include <aws/http/request_response.h> #include <aws/http/status_code.h> #include <aws/io/channel_bootstrap.h> #include <aws/io/event_loop.h> #include <aws/io/host_resolver.h> #include <aws/io/stream.h> #include <aws/io/tls_channel_handler.h> #include <aws/io/uri.h> #include <aws/testing/aws_test_harness.h> #include <aws/testing/stream_tester.h> #include <inttypes.h>  AWS_TEST_CASE(test_s3_client_create_destroy, s_test_s3_client_create_destroy) static int s_test_s3_client_create_destroy(struct aws_allocator *allocator, void *ctx) {     (\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_data_plane_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5420971}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"#ifndef AWS_S3_TESTER_H #define AWS_S3_TESTER_H  /**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_request_messages.h\\\\\\\\\\\\\" #include <aws/s3/private/s3_auto_ranged_put.h> #include <aws/s3/private/s3_client_impl.h> #include <aws/s3/private/s3_meta_request_impl.h> #include <aws/s3/s3.h> #include <aws/s3/s3_client.h> #include <aws/s3/s3express_credentials_provider.h>  #include <aws/common/common.h> #include <aws/common/condition_variable.h> #include <aws/common/file.h> #include <aws/common/logging.h> #include <aws/common/mutex.h> #include <aws/common/string.h> #include <aws/testing/async_stream_tester.h>  struct aws_client_bootstrap; struct aws_credentials_provider; struct aws_event_loop_group; struct aws_host_resolver; struct aws_input_stream;  enum AWS_S3_TESTER_BIND_CLIENT_FLAGS {     AWS_S3_TESTER_BIND_CLIENT_REGION = 0x00000001,     AWS_S3_TESTER_BIND_CLIENT_SIGNING = 0x00000002, };  enum AWS_S3_TESTER_SEND_META_REQUEST_FLAGS {     AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS =\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_tester.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5420685}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"# Helper script to setup your S3 structure to run the tests for aws-c-s3 To use this script, you must have AWS credentials with permission to create and delete buckets. To create the S3 buckets and objects that tests will use: ```sh pip3 install boto3 export CRT_S3_TEST_BUCKET_NAME=<bucket_name> python3 test_helper.py init # change directory to the build/tests cd aws-c-s3/build/tests && ctest ``` To clean up the S3 buckets created ```sh export CRT_S3_TEST_BUCKET_NAME=<bucket_name> python3 test_helper.py clean ``` ## Actions ### `init` action * Create `<BUCKET_NAME>` in us-west-2. + Add the lifecycle to automatic clean up the `upload/` and clean up incomplete multipart uploads after one day. + Upload files: - `pre-existing-10MB-aes256-c` [SSE-C](https://docs.aws.amazon.com/AmazonS3/latest/userguide/ServerSideEncryptionCustomerKeys.html#sse-c-highlights) encrypted fille - `pre-existing-10MB-aes256` [SSE-S3](https://docs.aws.amazon.com/AmazonS3/latest/userguide/specifying-s3-encryption.html) encrypted fille - `pre-existing-10MB-kms` [SSE-KMS](https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html) encrypted fille - `pre-existing-10MB` -\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/test_helper/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5398099}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/byte_buf.h> #include <aws/common/clock.h> #include <aws/common/common.h> #include <aws/common/environment.h> #include <aws/common/ref_count.h> #include <aws/http/request_response.h> #include <aws/io/channel_bootstrap.h> #include <aws/io/event_loop.h> #include <aws/io/host_resolver.h> #include <aws/io/stream.h> #include <aws/io/tls_channel_handler.h> #include <aws/testing/aws_test_harness.h> #include <inttypes.h> #include <stdio.h>  /* Ensure the library can go through the init/cleanup cycle multiple times */ AWS_TEST_CASE(test_s3_library_init_cleanup_init_cleanup, s_test_s3_library_init_cleanup_init_cleanup) static int s_test_s3_library_init_cleanup_init_cleanup(struct aws_allocator *allocator, void *ctx) {     (void)ctx;      aws_s3_library_init(allocator);     aws_s3_library_clean_up();      aws_s3_library_init(allocator);\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_util_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5374173}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */ #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\"  #include <aws/checksums/crc.h> #include <aws/common/byte_order.h> #include <aws/common/clock.h> #include <aws/common/device_random.h> #include <aws/common/encoding.h> #include <aws/s3/private/s3_util.h> #include <aws/testing/aws_test_harness.h>  #define TIMEOUT_NANOS ((uint64_t)AWS_TIMESTAMP_NANOS * 10) /* 10secs */ #define PART_SIZE MB_TO_BYTES(5)  struct asyncwrite_tester {     struct aws_allocator *allocator;     struct aws_s3_tester s3_tester;     struct aws_s3_client *client;     struct aws_s3_meta_request *meta_request;     struct aws_s3_meta_request_test_results test_results;     struct aws_byte_buf source_buf; };  static int s_asyncwrite_tester_init(     struct asyncwrite_tester *tester,     struct aws_allocator *allocator,     size_t object_size) {      AWS_ZERO_STRUCT(*tester);     tester->allocator = allocator;      ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester->s3_tester));      /* Create S3 client */     struct aws_s3_client_config client_config\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_asyncwrite_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.537362}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"#### Running S3 sample After installing all the dependencies, and building aws-c-s3, you can run the sample directly from the s3 build directory. To download: ``` aws-c-s3/build/samples/s3/s3 cp s3://<bucket-name>/<object-name> <download-path> --region <region> ``` To upload: ``` aws-c-s3/build/samples/s3/s3 cp <upload-path> s3://<bucket-name>/<object-name> --region <region> ``` To list objects: ``` aws-c-s3/build/samples/s3/s3 ls s3://<bucket-name> --region <region> ``` ## Testing The unit tests require an AWS account with S3 buckets set up in a particular way. Use the [test_helper script](./tests/test_helper/) to set this up.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.51725256}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"};  struct aws_s3_client_vtable_patch {     struct aws_s3_client_vtable *original_vtable;     struct aws_s3_client_vtable patched_vtable; };  struct aws_s3_meta_request_vtable_patch {     struct aws_s3_meta_request_vtable *original_vtable;     struct aws_s3_meta_request_vtable patched_vtable; };  /* Utility for setting up commonly needed resources for tests. */ struct aws_s3_tester {     struct aws_allocator *allocator;     struct aws_event_loop_group *el_group;     struct aws_host_resolver *host_resolver;     struct aws_client_bootstrap *client_bootstrap;     struct aws_credentials_provider *credentials_provider;     struct aws_signing_config_aws default_signing_config;     struct aws_credentials *anonymous_creds;     struct aws_signing_config_aws anonymous_signing_config;      struct aws_condition_variable signal;     bool bound_to_client;      struct aws_array_list client_vtable_patches;     struct aws_array_list meta_request_vtable_patches;     void *user_data;      struct aws_string *bucket_name;     struct aws_string *public_bucket_name;     struct aws_string *s3express_bucket_usw2_az1_endpoint;     struct aws_string *s3express_bucket_use1_az4_endpoint;      struct {         struct aws_mutex lock;          size_t desired_meta_request_finish_count;         size_t meta_request_finish_count;          size_t desired_meta_request_shutdown_count;\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_tester.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5146051}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3express_credentials_provider_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3express_credentials_provider.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/clock.h> #include <aws/common/lru_cache.h> #include <aws/io/stream.h> #include <aws/io/uri.h> #include <aws/testing/aws_test_harness.h> #include <inttypes.h>  #define TEST_CASE(NAME)                                                                                                \\\\\\\\\\\\\\\\     AWS_TEST_CASE(NAME, s_test_##NAME);                                                                                \\\\\\\\\\\\\\\\     static int s_test_##NAME(struct aws_allocator *allocator, void *ctx)  #define DEFINE_HEADER(NAME, VALUE)                                                                                     \\\\\\\\\\\\\\\\     {                                                                                                                  \\\\\\\\\\\\\\\\         .name = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(NAME),                                                           \\\\\\\\\\\\\\\\         .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(VALUE),                                                         \\\\\\\\\\\\\\\\     }  static uint64_t s_bg_refresh_secs_override = 60;  struct aws_s3express_provider_tester {     struct aws_allocator *allocator;      struct aws_mutex lock;     struct aws_condition_variable signal;      size_t credentials_callbacks_received;     bool has_received_shutdown_callback;      /* Last received credentials */\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_mock_server_s3express_provider_test.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5144225}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_parallel_input_stream.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/clock.h> #include <aws/common/file.h> #include <aws/common/string.h> #include <aws/io/event_loop.h> #include <aws/io/future.h> #include <aws/io/stream.h> #include <aws/io/uri.h> #include <aws/testing/aws_test_harness.h> #include <inttypes.h>  #include <sys/stat.h>  #define TEST_CASE(NAME)                                                                                                \\\\\\\\\\\\\\\\     AWS_TEST_CASE(NAME, s_test_##NAME);                                                                                \\\\\\\\\\\\\\\\     static int s_test_##NAME(struct aws_allocator *allocator, void *ctx)  #define DEFINE_HEADER(NAME, VALUE)                                                                                     \\\\\\\\\\\\\\\\     {                                                                                                                  \\\\\\\\\\\\\\\\         .name = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(NAME),                                                           \\\\\\\\\\\\\\\\         .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(VALUE),                                                         \\\\\\\\\\\\\\\\     }  #define ONE_SEC_IN_NS ((uint64_t)AWS_TIMESTAMP_NANOS) #define MAX_TIMEOUT_NS (600 * ONE_SEC_IN_NS)  AWS_STATIC_STRING_FROM_LITERAL(s_parallel_stream_test, \\\\\\\\\\\\\"SimpleParallelStreamTest\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_parallel_read_stream_test.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.51262265}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"tool_use\",\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"input\":{\"query\":\"what is the purpose of `test_s3_default_get` in aws-c-s3? How is it used?\",\"knowledge_base_id\":\"8BRIG4RFWU\"},\"id\":\"toolu_bdrk_0171AxPPnTSkfZjkYA85mCaf\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_0171AxPPnTSkfZjkYA85mCaf\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"object_path,             },     };      ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));      aws_byte_buf_clean_up(&path_buf);     aws_s3_client_release(client);     aws_s3_tester_clean_up(&tester);      return 0; }  AWS_TEST_CASE(test_s3_round_trip_default_get, s_test_s3_round_trip_default_get) static int s_test_s3_round_trip_default_get(struct aws_allocator *allocator, void *ctx) {     (void)ctx;      struct aws_s3_tester tester;     ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));      struct aws_s3_tester_client_options client_options = {         .part_size = 16 * 1024,     };      struct aws_s3_client *client = NULL;     ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));      struct aws_byte_buf path_buf;     AWS_ZERO_STRUCT(path_buf);      ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(         allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_default.txt\\\\\\\\\\\\\")));      struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);      struct aws_s3_tester_meta_request_options put_options = {         .allocator = allocator,         .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_data_plane_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5354118}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3express_credentials_provider_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3express_credentials_provider.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/clock.h> #include <aws/common/lru_cache.h> #include <aws/io/stream.h> #include <aws/io/uri.h> #include <aws/testing/aws_test_harness.h> #include <inttypes.h>  #define TEST_CASE(NAME)                                                                                                \\\\\\\\\\\\\\\\     AWS_TEST_CASE(NAME, s_test_##NAME);                                                                                \\\\\\\\\\\\\\\\     static int s_test_##NAME(struct aws_allocator *allocator, void *ctx)  #define DEFINE_HEADER(NAME, VALUE)                                                                                     \\\\\\\\\\\\\\\\     {                                                                                                                  \\\\\\\\\\\\\\\\         .name = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(NAME),                                                           \\\\\\\\\\\\\\\\         .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(VALUE),                                                         \\\\\\\\\\\\\\\\     }  static uint64_t s_bg_refresh_secs_override = 60;  struct aws_s3express_provider_tester {     struct aws_allocator *allocator;      struct aws_mutex lock;     struct aws_condition_variable signal;      size_t credentials_callbacks_received;     bool has_received_shutdown_callback;      /* Last received credentials */\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_mock_server_s3express_provider_test.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.52828497}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3express_credentials_provider_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3express_credentials_provider.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/atomics.h> #include <aws/common/clock.h> #include <aws/common/encoding.h> #include <aws/common/lru_cache.h> #include <aws/io/stream.h> #include <aws/io/uri.h> #include <aws/testing/aws_test_harness.h> #include <inttypes.h>  #define TEST_CASE(NAME)                                                                                                \\\\\\\\\\\\\\\\     AWS_TEST_CASE(NAME, s_test_##NAME);                                                                                \\\\\\\\\\\\\\\\     static int s_test_##NAME(struct aws_allocator *allocator, void *ctx)  #define DEFINE_HEADER(NAME, VALUE)                                                                                     \\\\\\\\\\\\\\\\     {                                                                                                                  \\\\\\\\\\\\\\\\         .name = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(NAME),                                                           \\\\\\\\\\\\\\\\         .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(VALUE),                                                         \\\\\\\\\\\\\\\\     }  struct aws_s3express_client_tester {     struct aws_allocator *allocator;     struct aws_hash_table saver_cache;     struct aws_atomic_var provider_requests_made; };  static struct aws_s3express_client_tester\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_s3express_client_test.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.52228075}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */ #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\"  #include <aws/checksums/crc.h> #include <aws/common/byte_order.h> #include <aws/common/clock.h> #include <aws/common/device_random.h> #include <aws/common/encoding.h> #include <aws/s3/private/s3_util.h> #include <aws/testing/aws_test_harness.h>  #define TIMEOUT_NANOS ((uint64_t)AWS_TIMESTAMP_NANOS * 10) /* 10secs */ #define PART_SIZE MB_TO_BYTES(5)  struct asyncwrite_tester {     struct aws_allocator *allocator;     struct aws_s3_tester s3_tester;     struct aws_s3_client *client;     struct aws_s3_meta_request *meta_request;     struct aws_s3_meta_request_test_results test_results;     struct aws_byte_buf source_buf; };  static int s_asyncwrite_tester_init(     struct asyncwrite_tester *tester,     struct aws_allocator *allocator,     size_t object_size) {      AWS_ZERO_STRUCT(*tester);     tester->allocator = allocator;      ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester->s3_tester));      /* Create S3 client */     struct aws_s3_client_config client_config\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_asyncwrite_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5154754}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"cppdbg\\\\\\\\\\\\\",             \\\\\\\\\\\\\"request\\\\\\\\\\\\\": \\\\\\\\\\\\\"launch\\\\\\\\\\\\\",             \\\\\\\\\\\\\"program\\\\\\\\\\\\\": \\\\\\\\\\\\\"/Users/dengket/project/aws-c/aws-c-s3/build/tests/aws-c-s3-tests\\\\\\\\\\\\\",             \\\\\\\\\\\\\"args\\\\\\\\\\\\\": [                 \\\\\\\\\\\\\"test_s3_default_get_without_content_length\\\\\\\\\\\\\"             ],             \\\\\\\\\\\\\"stopAtEntry\\\\\\\\\\\\\": false,             \\\\\\\\\\\\\"cwd\\\\\\\\\\\\\": \\\\\\\\\\\\\"/Users/dengket/project/aws-c/aws-c-s3/build/tests/\\\\\\\\\\\\\",             \\\\\\\\\\\\\"environment\\\\\\\\\\\\\": [                 {                     // add the directory where our target was built to the PATHs                     // it gets resolved by CMake Tools:                     \\\\\\\\\\\\\"name\\\\\\\\\\\\\": \\\\\\\\\\\\\"PATH\\\\\\\\\\\\\",                     \\\\\\\\\\\\\"value\\\\\\\\\\\\\": \\\\\\\\\\\\\"${workspaceFolder}/build/tests/\\\\\\\\\\\\\"                 },                 {                     \\\\\\\\\\\\\"name\\\\\\\\\\\\\": \\\\\\\\\\\\\"AWS_PROFILE\\\\\\\\\\\\\",                     \\\\\\\\\\\\\"value\\\\\\\\\\\\\": \\\\\\\\\\\\\"team\\\\\\\\\\\\\"                 },                 // {                 //     \\\\\\\\\\\\\"name\\\\\\\\\\\\\": \\\\\\\\\\\\\"CRT_S3_TEST_BUCKET_NAME\\\\\\\\\\\\\",                 //     \\\\\\\\\\\\\"value\\\\\\\\\\\\\": \\\\\\\\\\\\\"public-test-bucket-dengket-2\\\\\\\\\\\\\"                 // }             ],             \\\\\\\\\\\\\"externalConsole\\\\\\\\\\\\\": true,             \\\\\\\\\\\\\"MIMode\\\\\\\\\\\\\": \\\\\\\\\\\\\"lldb\\\\\\\\\\\\\"         }     ] }\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/.vscode/launch.json\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5146748}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"to be less copy/paste */ static int s_test_s3_round_trip_default_get_fc_helper(     struct aws_allocator *allocator,     void *ctx,     bool via_header,     uint32_t object_size_mb,     enum aws_s3_tester_full_object_checksum full_object_checksum) {     (void)ctx;      struct aws_s3_tester tester;     ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));     struct aws_s3_tester_client_options client_options = {         .part_size = MB_TO_BYTES(5),     };      struct aws_s3_client *client = NULL;     ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));      struct aws_byte_buf path_buf;     AWS_ZERO_STRUCT(path_buf);      for (size_t i = 0; i < AWS_ARRAY_SIZE(s_checksum_algo_priority_list); i++) {         enum aws_s3_checksum_algorithm algorithm = s_checksum_algo_priority_list[i];         char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";         snprintf(             object_path_sprintf_buffer,             sizeof(object_path_sprintf_buffer),             \\\\\\\\\\\\\"/prefix/round_trip/test_default_fc_%d_%d.txt\\\\\\\\\\\\\",             algorithm,             object_size_mb);          ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(             allocator, &path_buf, aws_byte_cursor_from_c_str(object_path_sprintf_buffer)));         struct aws_byte_cursor object_path =\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_data_plane_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5136721}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"#ifndef AWS_S3_TESTER_H #define AWS_S3_TESTER_H  /**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_request_messages.h\\\\\\\\\\\\\" #include <aws/s3/private/s3_auto_ranged_put.h> #include <aws/s3/private/s3_client_impl.h> #include <aws/s3/private/s3_meta_request_impl.h> #include <aws/s3/s3.h> #include <aws/s3/s3_client.h> #include <aws/s3/s3express_credentials_provider.h>  #include <aws/common/common.h> #include <aws/common/condition_variable.h> #include <aws/common/file.h> #include <aws/common/logging.h> #include <aws/common/mutex.h> #include <aws/common/string.h> #include <aws/testing/async_stream_tester.h>  struct aws_client_bootstrap; struct aws_credentials_provider; struct aws_event_loop_group; struct aws_host_resolver; struct aws_input_stream;  enum AWS_S3_TESTER_BIND_CLIENT_FLAGS {     AWS_S3_TESTER_BIND_CLIENT_REGION = 0x00000001,     AWS_S3_TESTER_BIND_CLIENT_SIGNING = 0x00000002, };  enum AWS_S3_TESTER_SEND_META_REQUEST_FLAGS {     AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS =\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_tester.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.51341766}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"unchunked_put_options, NULL));      aws_byte_buf_clean_up(&path_buf);     aws_s3_client_release(client);     aws_s3_tester_clean_up(&tester);      return 0; }  AWS_TEST_CASE(test_s3_meta_request_default, s_test_s3_meta_request_default) static int s_test_s3_meta_request_default(struct aws_allocator *allocator, void *ctx) {     (void)ctx;      struct aws_s3_tester tester;     AWS_ZERO_STRUCT(tester);     ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));      struct aws_s3_client_config client_config;     AWS_ZERO_STRUCT(client_config);      ASSERT_SUCCESS(aws_s3_tester_bind_client(         &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));      struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);      struct aws_string *host_name =         aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);      /* Put together a simple S3 Get Object request. */     struct aws_http_message *message = aws_s3_test_get_object_request_new(         allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);      struct aws_s3_meta_request_options options;     AWS_ZERO_STRUCT(options);      /* Pass the\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_data_plane_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5124251}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/io/channel_bootstrap.h> #include <aws/testing/aws_test_harness.h>  AWS_TEST_CASE(test_s3_different_endpoints, s_test_s3_different_endpoints) static int s_test_s3_different_endpoints(struct aws_allocator *allocator, void *ctx) {     (void)ctx;      struct aws_s3_tester tester;     ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));      struct aws_s3_client *client = NULL;     struct aws_s3_tester_client_options client_options;     AWS_ZERO_STRUCT(client_options);      ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));      {         struct aws_s3_meta_request_test_results meta_request_test_results;         aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);          struct aws_s3_tester_meta_request_options options = {             .allocator = allocator,             .client = client,             .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,             .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,             .get_options =                 {                     .object_path =\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_endpoint_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5119686}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_checksums.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/byte_buf.h> #include <aws/common/clock.h> #include <aws/common/common.h> #include <aws/common/encoding.h> #include <aws/common/environment.h> #include <aws/common/ref_count.h> #include <aws/http/request_response.h> #include <aws/http/status_code.h> #include <aws/io/channel_bootstrap.h> #include <aws/io/event_loop.h> #include <aws/io/host_resolver.h> #include <aws/io/stream.h> #include <aws/io/tls_channel_handler.h> #include <aws/io/uri.h> #include <aws/testing/aws_test_harness.h> #include <aws/testing/stream_tester.h> #include <inttypes.h>  AWS_TEST_CASE(test_s3_client_create_destroy, s_test_s3_client_create_destroy) static int s_test_s3_client_create_destroy(struct aws_allocator *allocator, void *ctx) {     (\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_data_plane_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.51043427}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"tool_use\",\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"input\":{\"query\":\"What is the purpose of test_s3_default_get function in aws-c-s3?\",\"knowledge_base_id\":\"8BRIG4RFWU\"},\"id\":\"toolu_bdrk_01Af595gWxHaCLu5GiMo3MsR\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01Af595gWxHaCLu5GiMo3MsR\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"object_path,             },     };      ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));      aws_byte_buf_clean_up(&path_buf);     aws_s3_client_release(client);     aws_s3_tester_clean_up(&tester);      return 0; }  AWS_TEST_CASE(test_s3_round_trip_default_get, s_test_s3_round_trip_default_get) static int s_test_s3_round_trip_default_get(struct aws_allocator *allocator, void *ctx) {     (void)ctx;      struct aws_s3_tester tester;     ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));      struct aws_s3_tester_client_options client_options = {         .part_size = 16 * 1024,     };      struct aws_s3_client *client = NULL;     ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));      struct aws_byte_buf path_buf;     AWS_ZERO_STRUCT(path_buf);      ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(         allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_default.txt\\\\\\\\\\\\\")));      struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);      struct aws_s3_tester_meta_request_options put_options = {         .allocator = allocator,         .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_data_plane_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.53618234}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3express_credentials_provider_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3express_credentials_provider.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/clock.h> #include <aws/common/lru_cache.h> #include <aws/io/stream.h> #include <aws/io/uri.h> #include <aws/testing/aws_test_harness.h> #include <inttypes.h>  #define TEST_CASE(NAME)                                                                                                \\\\\\\\\\\\\\\\     AWS_TEST_CASE(NAME, s_test_##NAME);                                                                                \\\\\\\\\\\\\\\\     static int s_test_##NAME(struct aws_allocator *allocator, void *ctx)  #define DEFINE_HEADER(NAME, VALUE)                                                                                     \\\\\\\\\\\\\\\\     {                                                                                                                  \\\\\\\\\\\\\\\\         .name = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(NAME),                                                           \\\\\\\\\\\\\\\\         .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(VALUE),                                                         \\\\\\\\\\\\\\\\     }  static uint64_t s_bg_refresh_secs_override = 60;  struct aws_s3express_provider_tester {     struct aws_allocator *allocator;      struct aws_mutex lock;     struct aws_condition_variable signal;      size_t credentials_callbacks_received;     bool has_received_shutdown_callback;      /* Last received credentials */\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_mock_server_s3express_provider_test.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.53324246}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3express_credentials_provider_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3express_credentials_provider.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/atomics.h> #include <aws/common/clock.h> #include <aws/common/encoding.h> #include <aws/common/lru_cache.h> #include <aws/io/stream.h> #include <aws/io/uri.h> #include <aws/testing/aws_test_harness.h> #include <inttypes.h>  #define TEST_CASE(NAME)                                                                                                \\\\\\\\\\\\\\\\     AWS_TEST_CASE(NAME, s_test_##NAME);                                                                                \\\\\\\\\\\\\\\\     static int s_test_##NAME(struct aws_allocator *allocator, void *ctx)  #define DEFINE_HEADER(NAME, VALUE)                                                                                     \\\\\\\\\\\\\\\\     {                                                                                                                  \\\\\\\\\\\\\\\\         .name = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(NAME),                                                           \\\\\\\\\\\\\\\\         .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(VALUE),                                                         \\\\\\\\\\\\\\\\     }  struct aws_s3express_client_tester {     struct aws_allocator *allocator;     struct aws_hash_table saver_cache;     struct aws_atomic_var provider_requests_made; };  static struct aws_s3express_client_tester\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_s3express_client_test.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5293267}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_checksums.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/byte_buf.h> #include <aws/common/clock.h> #include <aws/common/common.h> #include <aws/common/encoding.h> #include <aws/common/environment.h> #include <aws/common/ref_count.h> #include <aws/http/request_response.h> #include <aws/http/status_code.h> #include <aws/io/channel_bootstrap.h> #include <aws/io/event_loop.h> #include <aws/io/host_resolver.h> #include <aws/io/stream.h> #include <aws/io/tls_channel_handler.h> #include <aws/io/uri.h> #include <aws/testing/aws_test_harness.h> #include <aws/testing/stream_tester.h> #include <inttypes.h>  AWS_TEST_CASE(test_s3_client_create_destroy, s_test_s3_client_create_destroy) static int s_test_s3_client_create_destroy(struct aws_allocator *allocator, void *ctx) {     (\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_data_plane_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5224085}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */ #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\"  #include <aws/checksums/crc.h> #include <aws/common/byte_order.h> #include <aws/common/clock.h> #include <aws/common/device_random.h> #include <aws/common/encoding.h> #include <aws/s3/private/s3_util.h> #include <aws/testing/aws_test_harness.h>  #define TIMEOUT_NANOS ((uint64_t)AWS_TIMESTAMP_NANOS * 10) /* 10secs */ #define PART_SIZE MB_TO_BYTES(5)  struct asyncwrite_tester {     struct aws_allocator *allocator;     struct aws_s3_tester s3_tester;     struct aws_s3_client *client;     struct aws_s3_meta_request *meta_request;     struct aws_s3_meta_request_test_results test_results;     struct aws_byte_buf source_buf; };  static int s_asyncwrite_tester_init(     struct asyncwrite_tester *tester,     struct aws_allocator *allocator,     size_t object_size) {      AWS_ZERO_STRUCT(*tester);     tester->allocator = allocator;      ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester->s3_tester));      /* Create S3 client */     struct aws_s3_client_config client_config\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_asyncwrite_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5192202}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/io/channel_bootstrap.h> #include <aws/testing/aws_test_harness.h>  AWS_TEST_CASE(test_s3_different_endpoints, s_test_s3_different_endpoints) static int s_test_s3_different_endpoints(struct aws_allocator *allocator, void *ctx) {     (void)ctx;      struct aws_s3_tester tester;     ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));      struct aws_s3_client *client = NULL;     struct aws_s3_tester_client_options client_options;     AWS_ZERO_STRUCT(client_options);      ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));      {         struct aws_s3_meta_request_test_results meta_request_test_results;         aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);          struct aws_s3_tester_meta_request_options options = {             .allocator = allocator,             .client = client,             .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,             .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,             .get_options =                 {                     .object_path =\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_endpoint_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.51859057}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"cppdbg\\\\\\\\\\\\\",             \\\\\\\\\\\\\"request\\\\\\\\\\\\\": \\\\\\\\\\\\\"launch\\\\\\\\\\\\\",             \\\\\\\\\\\\\"program\\\\\\\\\\\\\": \\\\\\\\\\\\\"/Users/dengket/project/aws-c/aws-c-s3/build/tests/aws-c-s3-tests\\\\\\\\\\\\\",             \\\\\\\\\\\\\"args\\\\\\\\\\\\\": [                 \\\\\\\\\\\\\"test_s3_default_get_without_content_length\\\\\\\\\\\\\"             ],             \\\\\\\\\\\\\"stopAtEntry\\\\\\\\\\\\\": false,             \\\\\\\\\\\\\"cwd\\\\\\\\\\\\\": \\\\\\\\\\\\\"/Users/dengket/project/aws-c/aws-c-s3/build/tests/\\\\\\\\\\\\\",             \\\\\\\\\\\\\"environment\\\\\\\\\\\\\": [                 {                     // add the directory where our target was built to the PATHs                     // it gets resolved by CMake Tools:                     \\\\\\\\\\\\\"name\\\\\\\\\\\\\": \\\\\\\\\\\\\"PATH\\\\\\\\\\\\\",                     \\\\\\\\\\\\\"value\\\\\\\\\\\\\": \\\\\\\\\\\\\"${workspaceFolder}/build/tests/\\\\\\\\\\\\\"                 },                 {                     \\\\\\\\\\\\\"name\\\\\\\\\\\\\": \\\\\\\\\\\\\"AWS_PROFILE\\\\\\\\\\\\\",                     \\\\\\\\\\\\\"value\\\\\\\\\\\\\": \\\\\\\\\\\\\"team\\\\\\\\\\\\\"                 },                 // {                 //     \\\\\\\\\\\\\"name\\\\\\\\\\\\\": \\\\\\\\\\\\\"CRT_S3_TEST_BUCKET_NAME\\\\\\\\\\\\\",                 //     \\\\\\\\\\\\\"value\\\\\\\\\\\\\": \\\\\\\\\\\\\"public-test-bucket-dengket-2\\\\\\\\\\\\\"                 // }             ],             \\\\\\\\\\\\\"externalConsole\\\\\\\\\\\\\": true,             \\\\\\\\\\\\\"MIMode\\\\\\\\\\\\\": \\\\\\\\\\\\\"lldb\\\\\\\\\\\\\"         }     ] }\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/.vscode/launch.json\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.51815027}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"unchunked_put_options, NULL));      aws_byte_buf_clean_up(&path_buf);     aws_s3_client_release(client);     aws_s3_tester_clean_up(&tester);      return 0; }  AWS_TEST_CASE(test_s3_meta_request_default, s_test_s3_meta_request_default) static int s_test_s3_meta_request_default(struct aws_allocator *allocator, void *ctx) {     (void)ctx;      struct aws_s3_tester tester;     AWS_ZERO_STRUCT(tester);     ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));      struct aws_s3_client_config client_config;     AWS_ZERO_STRUCT(client_config);      ASSERT_SUCCESS(aws_s3_tester_bind_client(         &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));      struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);      struct aws_string *host_name =         aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);      /* Put together a simple S3 Get Object request. */     struct aws_http_message *message = aws_s3_test_get_object_request_new(         allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);      struct aws_s3_meta_request_options options;     AWS_ZERO_STRUCT(options);      /* Pass the\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_data_plane_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5173152}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"to be less copy/paste */ static int s_test_s3_round_trip_default_get_fc_helper(     struct aws_allocator *allocator,     void *ctx,     bool via_header,     uint32_t object_size_mb,     enum aws_s3_tester_full_object_checksum full_object_checksum) {     (void)ctx;      struct aws_s3_tester tester;     ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));     struct aws_s3_tester_client_options client_options = {         .part_size = MB_TO_BYTES(5),     };      struct aws_s3_client *client = NULL;     ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));      struct aws_byte_buf path_buf;     AWS_ZERO_STRUCT(path_buf);      for (size_t i = 0; i < AWS_ARRAY_SIZE(s_checksum_algo_priority_list); i++) {         enum aws_s3_checksum_algorithm algorithm = s_checksum_algo_priority_list[i];         char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";         snprintf(             object_path_sprintf_buffer,             sizeof(object_path_sprintf_buffer),             \\\\\\\\\\\\\"/prefix/round_trip/test_default_fc_%d_%d.txt\\\\\\\\\\\\\",             algorithm,             object_size_mb);          ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(             allocator, &path_buf, aws_byte_cursor_from_c_str(object_path_sprintf_buffer)));         struct aws_byte_cursor object_path =\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_data_plane_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.51720566}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"#ifndef AWS_S3_TESTER_H #define AWS_S3_TESTER_H  /**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_request_messages.h\\\\\\\\\\\\\" #include <aws/s3/private/s3_auto_ranged_put.h> #include <aws/s3/private/s3_client_impl.h> #include <aws/s3/private/s3_meta_request_impl.h> #include <aws/s3/s3.h> #include <aws/s3/s3_client.h> #include <aws/s3/s3express_credentials_provider.h>  #include <aws/common/common.h> #include <aws/common/condition_variable.h> #include <aws/common/file.h> #include <aws/common/logging.h> #include <aws/common/mutex.h> #include <aws/common/string.h> #include <aws/testing/async_stream_tester.h>  struct aws_client_bootstrap; struct aws_credentials_provider; struct aws_event_loop_group; struct aws_host_resolver; struct aws_input_stream;  enum AWS_S3_TESTER_BIND_CLIENT_FLAGS {     AWS_S3_TESTER_BIND_CLIENT_REGION = 0x00000001,     AWS_S3_TESTER_BIND_CLIENT_SIGNING = 0x00000002, };  enum AWS_S3_TESTER_SEND_META_REQUEST_FLAGS {     AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS =\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_tester.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5156089}\"}],\"is_error\":false}]}],\"stop_sequences\":null,\"system\":\"Given a github pull request.         The code in the pull request is very related to the knowledge base, fetch the details of the code base you want to learn about the code from the knowledge base.             Use 8BRIG4RFWU as Knowledge Base ID and aws profile as bedrock, region us-east-1                But if the code is just added by the pull request, then the knowledge base will not help         and follow the guidance in /Users/dengket/project/hackthon/fast-agent/crt_c_reviewer/summarization/comments_styles.md to be how you will make comments then make your comments             as details as you can for each specific lines about the usage of API on the pull request,                 save your comments about the specific line or lines with the number of the lines to a folder naming followed by ./new_comments_s3_PR<the PR number> with name related to the Pull request like PR454_Comments_Impl.md.                     And then, generates the comments only if needed and keep the positive comments out for the specific line or lines as the input for create_pull_request_review,                         save it to a file to the same folder with naming like `input_PR454_comments_API_usage.json`, but don\\'t really submit the comments\",\"tools\":[{\"name\":\"github-create_or_update_file\",\"description\":\"Create or update a single file in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"path\":{\"type\":\"string\",\"description\":\"Path where to create/update the file\"},\"content\":{\"type\":\"string\",\"description\":\"Content of the file\"},\"message\":{\"type\":\"string\",\"description\":\"Commit message\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to create/update the file in\"},\"sha\":{\"type\":\"string\",\"description\":\"SHA of the file being replaced (required when updating existing files)\"}},\"required\":[\"owner\",\"repo\",\"path\",\"content\",\"message\",\"branch\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_repositories\",\"description\":\"Search for GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"query\":{\"type\":\"string\",\"description\":\"Search query (see GitHub search syntax)\"},\"page\":{\"type\":\"number\",\"description\":\"Page number for pagination (default: 1)\"},\"perPage\":{\"type\":\"number\",\"description\":\"Number of results per page (default: 30, max: 100)\"}},\"required\":[\"query\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_repository\",\"description\":\"Create a new GitHub repository in your account\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\",\"description\":\"Repository name\"},\"description\":{\"type\":\"string\",\"description\":\"Repository description\"},\"private\":{\"type\":\"boolean\",\"description\":\"Whether the repository should be private\"},\"autoInit\":{\"type\":\"boolean\",\"description\":\"Initialize with README.md\"}},\"required\":[\"name\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_file_contents\",\"description\":\"Get the contents of a file or directory from a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"path\":{\"type\":\"string\",\"description\":\"Path to the file or directory\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to get contents from\"}},\"required\":[\"owner\",\"repo\",\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-push_files\",\"description\":\"Push multiple files to a GitHub repository in a single commit\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to push to (e.g., \\'main\\' or \\'master\\')\"},\"files\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"content\":{\"type\":\"string\"}},\"required\":[\"path\",\"content\"],\"additionalProperties\":false},\"description\":\"Array of files to push\"},\"message\":{\"type\":\"string\",\"description\":\"Commit message\"}},\"required\":[\"owner\",\"repo\",\"branch\",\"files\",\"message\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_issue\",\"description\":\"Create a new issue in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"body\":{\"type\":\"string\"},\"assignees\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"milestone\":{\"type\":\"number\"},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"owner\",\"repo\",\"title\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_pull_request\",\"description\":\"Create a new pull request in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"title\":{\"type\":\"string\",\"description\":\"Pull request title\"},\"body\":{\"type\":\"string\",\"description\":\"Pull request body/description\"},\"head\":{\"type\":\"string\",\"description\":\"The name of the branch where your changes are implemented\"},\"base\":{\"type\":\"string\",\"description\":\"The name of the branch you want the changes pulled into\"},\"draft\":{\"type\":\"boolean\",\"description\":\"Whether to create the pull request as a draft\"},\"maintainer_can_modify\":{\"type\":\"boolean\",\"description\":\"Whether maintainers can modify the pull request\"}},\"required\":[\"owner\",\"repo\",\"title\",\"head\",\"base\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-fork_repository\",\"description\":\"Fork a GitHub repository to your account or specified organization\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"organization\":{\"type\":\"string\",\"description\":\"Optional: organization to fork to (defaults to your personal account)\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_branch\",\"description\":\"Create a new branch in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"branch\":{\"type\":\"string\",\"description\":\"Name for the new branch\"},\"from_branch\":{\"type\":\"string\",\"description\":\"Optional: source branch to create from (defaults to the repository\\'s default branch)\"}},\"required\":[\"owner\",\"repo\",\"branch\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_commits\",\"description\":\"Get list of commits of a branch in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"sha\":{\"type\":\"string\"},\"page\":{\"type\":\"number\"},\"perPage\":{\"type\":\"number\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_issues\",\"description\":\"List issues in a GitHub repository with filtering options\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"direction\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"page\":{\"type\":\"number\"},\"per_page\":{\"type\":\"number\"},\"since\":{\"type\":\"string\"},\"sort\":{\"type\":\"string\",\"enum\":[\"created\",\"updated\",\"comments\"]},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\",\"all\"]}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-update_issue\",\"description\":\"Update an existing issue in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"},\"title\":{\"type\":\"string\"},\"body\":{\"type\":\"string\"},\"assignees\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"milestone\":{\"type\":\"number\"},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\"]}},\"required\":[\"owner\",\"repo\",\"issue_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-add_issue_comment\",\"description\":\"Add a comment to an existing issue\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"},\"body\":{\"type\":\"string\"}},\"required\":[\"owner\",\"repo\",\"issue_number\",\"body\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_code\",\"description\":\"Search for code across GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_issues\",\"description\":\"Search for issues and pull requests across GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100},\"sort\":{\"type\":\"string\",\"enum\":[\"comments\",\"reactions\",\"reactions-+1\",\"reactions--1\",\"reactions-smile\",\"reactions-thinking_face\",\"reactions-heart\",\"reactions-tada\",\"interactions\",\"created\",\"updated\"]}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_users\",\"description\":\"Search for users on GitHub\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100},\"sort\":{\"type\":\"string\",\"enum\":[\"followers\",\"repositories\",\"joined\"]}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_issue\",\"description\":\"Get details of a specific issue in a GitHub repository.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"}},\"required\":[\"owner\",\"repo\",\"issue_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request\",\"description\":\"Get details of a specific pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_pull_requests\",\"description\":\"List and filter repository pull requests\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\",\"all\"],\"description\":\"State of the pull requests to return\"},\"head\":{\"type\":\"string\",\"description\":\"Filter by head user or head organization and branch name\"},\"base\":{\"type\":\"string\",\"description\":\"Filter by base branch name\"},\"sort\":{\"type\":\"string\",\"enum\":[\"created\",\"updated\",\"popularity\",\"long-running\"],\"description\":\"What to sort results by\"},\"direction\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"],\"description\":\"The direction of the sort\"},\"per_page\":{\"type\":\"number\",\"description\":\"Results per page (max 100)\"},\"page\":{\"type\":\"number\",\"description\":\"Page number of the results\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_pull_request_review\",\"description\":\"Create a review on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"commit_id\":{\"type\":\"string\",\"description\":\"The SHA of the commit that needs a review\"},\"body\":{\"type\":\"string\",\"description\":\"The body text of the review\"},\"event\":{\"type\":\"string\",\"enum\":[\"APPROVE\",\"REQUEST_CHANGES\",\"COMMENT\"],\"description\":\"The review action to perform\"},\"comments\":{\"type\":\"array\",\"items\":{\"anyOf\":[{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\",\"description\":\"The relative path to the file being commented on\"},\"position\":{\"type\":\"number\",\"description\":\"The position in the diff where you want to add a review comment\"},\"body\":{\"type\":\"string\",\"description\":\"Text of the review comment\"}},\"required\":[\"path\",\"position\",\"body\"],\"additionalProperties\":false},{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\",\"description\":\"The relative path to the file being commented on\"},\"line\":{\"type\":\"number\",\"description\":\"The line number in the file where you want to add a review comment\"},\"body\":{\"type\":\"string\",\"description\":\"Text of the review comment\"}},\"required\":[\"path\",\"line\",\"body\"],\"additionalProperties\":false}]},\"description\":\"Comments to post as part of the review (specify either position or line, not both)\"}},\"required\":[\"owner\",\"repo\",\"pull_number\",\"body\",\"event\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-merge_pull_request\",\"description\":\"Merge a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"commit_title\":{\"type\":\"string\",\"description\":\"Title for the automatic commit message\"},\"commit_message\":{\"type\":\"string\",\"description\":\"Extra detail to append to automatic commit message\"},\"merge_method\":{\"type\":\"string\",\"enum\":[\"merge\",\"squash\",\"rebase\"],\"description\":\"Merge method to use\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_files\",\"description\":\"Get the list of files changed in a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_status\",\"description\":\"Get the combined status of all status checks for a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-update_pull_request_branch\",\"description\":\"Update a pull request branch with the latest changes from the base branch\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"expected_head_sha\":{\"type\":\"string\",\"description\":\"The expected SHA of the pull request\\'s HEAD ref\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_comments\",\"description\":\"Get the review comments on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_reviews\",\"description\":\"Get the reviews on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-read_file\",\"description\":\"Read the complete contents of a file from the file system. Handles various text encodings and provides detailed error messages if the file cannot be read. Use this tool when you need to examine the contents of a single file. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-read_multiple_files\",\"description\":\"Read the contents of multiple files simultaneously. This is more efficient than reading files one by one when you need to analyze or compare multiple files. Each file\\'s content is returned with its path as a reference. Failed reads for individual files won\\'t stop the entire operation. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"paths\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"paths\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-write_file\",\"description\":\"Create a new file or completely overwrite an existing file with new content. Use with caution as it will overwrite existing files without warning. Handles text content with proper encoding. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"content\":{\"type\":\"string\"}},\"required\":[\"path\",\"content\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-edit_file\",\"description\":\"Make line-based edits to a text file. Each edit replaces exact line sequences with new content. Returns a git-style diff showing the changes made. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"edits\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"oldText\":{\"type\":\"string\",\"description\":\"Text to search for - must match exactly\"},\"newText\":{\"type\":\"string\",\"description\":\"Text to replace with\"}},\"required\":[\"oldText\",\"newText\"],\"additionalProperties\":false}},\"dryRun\":{\"type\":\"boolean\",\"default\":false,\"description\":\"Preview changes using git-style diff format\"}},\"required\":[\"path\",\"edits\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-create_directory\",\"description\":\"Create a new directory or ensure a directory exists. Can create multiple nested directories in one operation. If the directory already exists, this operation will succeed silently. Perfect for setting up directory structures for projects or ensuring required paths exist. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-list_directory\",\"description\":\"Get a detailed listing of all files and directories in a specified path. Results clearly distinguish between files and directories with [FILE] and [DIR] prefixes. This tool is essential for understanding directory structure and finding specific files within a directory. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-directory_tree\",\"description\":\"Get a recursive tree view of files and directories as a JSON structure. Each entry includes \\'name\\', \\'type\\' (file/directory), and \\'children\\' for directories. Files have no children array, while directories always have a children array (which may be empty). The output is formatted with 2-space indentation for readability. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-move_file\",\"description\":\"Move or rename files and directories. Can move files between directories and rename them in a single operation. If the destination exists, the operation will fail. Works across different directories and can be used for simple renaming within the same directory. Both source and destination must be within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"source\":{\"type\":\"string\"},\"destination\":{\"type\":\"string\"}},\"required\":[\"source\",\"destination\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-search_files\",\"description\":\"Recursively search for files and directories matching a pattern. Searches through all subdirectories from the starting path. The search is case-insensitive and matches partial names. Returns full paths to all matching items. Great for finding files when you don\\'t know their exact location. Only searches within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"pattern\":{\"type\":\"string\"},\"excludePatterns\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"default\":[]}},\"required\":[\"path\",\"pattern\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-get_file_info\",\"description\":\"Retrieve detailed metadata about a file or directory. Returns comprehensive information including size, creation time, last modified time, permissions, and type. This tool is perfect for understanding file characteristics without reading the actual content. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-list_allowed_directories\",\"description\":\"Returns the list of directories that this server is allowed to access. Use this to understand which directories are available before trying to access files.\",\"input_schema\":{\"type\":\"object\",\"properties\":{},\"required\":[]}},{\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"description\":\"Query an Amazon Bedrock Knowledge Base using natural language.\\\\n\\\\n    ## Usage Requirements\\\\n    - You MUST first use the `resource://knowledgebases` resource to get valid knowledge base IDs\\\\n    - You can query different knowledge bases or make multiple queries to the same knowledge base\\\\n\\\\n    ## Query Tips\\\\n    - Use clear, specific natural language queries for best results\\\\n    - You can use this tool MULTIPLE TIMES with different queries to gather comprehensive information\\\\n    - Break complex questions into multiple focused queries\\\\n    - Consider querying for factual information and explanations separately\\\\n\\\\n    ## Tool output format\\\\n    The response contains multiple JSON objects (one per line), each representing a retrieved document with:\\\\n    - content: The text content of the document\\\\n    - location: The source location of the document\\\\n    - score: The relevance score of the document\\\\n\\\\n\\\\n    ## Interpretation Best Practices\\\\n    1. Extract and combine key information from multiple results\\\\n    2. Consider the source and relevance score when evaluating information\\\\n    3. Use follow-up queries to clarify ambiguous or incomplete information\\\\n    4. If the response is not relevant, try a different query, knowledge base, and/or data source\\\\n    5. After a few attempts, ask the user for clarification or a different query.\\\\n    \",\"input_schema\":{\"properties\":{\"query\":{\"description\":\"A natural language query to search the knowledge base with\",\"title\":\"Query\",\"type\":\"string\"},\"knowledge_base_id\":{\"description\":\"The knowledge base ID to query. It must be a valid ID from the resource://knowledgebases MCP resource\",\"title\":\"Knowledge Base Id\",\"type\":\"string\"},\"number_of_results\":{\"default\":10,\"description\":\"The number of results to return. Use smaller values for focused results and larger values for broader coverage.\",\"title\":\"Number Of Results\",\"type\":\"integer\"},\"reranking\":{\"default\":false,\"description\":\"Whether to rerank the results. Useful for improving relevance and sorting. Can be globally configured with BEDROCK_KB_RERANKING_ENABLED environment variable.\",\"title\":\"Reranking\",\"type\":\"boolean\"},\"reranking_model_name\":{\"default\":\"AMAZON\",\"description\":\"The name of the reranking model to use. Options: \\'COHERE\\', \\'AMAZON\\'\",\"enum\":[\"COHERE\",\"AMAZON\"],\"title\":\"Reranking Model Name\",\"type\":\"string\"},\"data_source_ids\":{\"anyOf\":[{\"items\":{\"type\":\"string\"},\"type\":\"array\"},{\"type\":\"null\"}],\"default\":null,\"description\":\"The data source IDs to filter the knowledge base by. It must be a list of valid data source IDs from the resource://knowledgebases MCP resource\",\"title\":\"Data Source Ids\"}},\"required\":[\"query\",\"knowledge_base_id\"],\"title\":\"query_knowledge_bases_toolArguments\",\"type\":\"object\"}}],\"anthropic_version\":\"bedrock-2023-05-31\"}'"},"message":"Error code: 429 - {'message': 'Too many tokens, please wait before trying again.'}","body":{"message":"Too many tokens, please wait before trying again."},"response":"<httpx.Response [429] https://bedrock-runtime.us-west-2.amazonaws.com/model/us.anthropic.claude-3-7-sonnet-20250219-v1:0/invoke>","status_code":429,"request_id":null}]}}
{"level":"ERROR","timestamp":"2025-05-15T11:01:52.667462","namespace":"mcp_agent.llm.augmented_llm","message":"Error: Error code: 429 - {'message': 'Too many tokens, please wait before trying again.'}","data":{"data":[{"request":{"method":"POST","url":{"_uri_reference":["https","","bedrock-runtime.us-west-2.amazonaws.com",null,"/model/us.anthropic.claude-3-7-sonnet-20250219-v1:0/invoke",null,null]},"headers":["connection","host","accept-encoding","x-stainless-timeout","accept","content-type","user-agent","x-stainless-lang","x-stainless-package-version","x-stainless-os","x-stainless-arch","x-stainless-runtime","x-stainless-runtime-version","x-stainless-retry-count","x-stainless-read-timeout","content-length","x-amz-date","x-amz-security-token","authorization"],"extensions":{"timeout":{"connect":5.0,"read":600,"write":"600","pool":"600"}},"stream":[{"capitalize":"<callable: capitalize>","center":"<callable: center>","count":"<callable: count>","decode":"<callable: decode>","endswith":"<callable: endswith>","expandtabs":"<callable: expandtabs>","find":"<callable: find>","fromhex":"<callable: fromhex>","hex":"<callable: hex>","index":"<callable: index>","isalnum":"<callable: isalnum>","isalpha":"<callable: isalpha>","isascii":"<callable: isascii>","isdigit":"<callable: isdigit>","islower":"<callable: islower>","isspace":"<callable: isspace>","istitle":"<callable: istitle>","isupper":"<callable: isupper>","join":"<callable: join>","ljust":"<callable: ljust>","lower":"<callable: lower>","lstrip":"<callable: lstrip>","maketrans":"<callable: maketrans>","partition":"<callable: partition>","removeprefix":"<callable: removeprefix>","removesuffix":"<callable: removesuffix>","replace":"<callable: replace>","rfind":"<callable: rfind>","rindex":"<callable: rindex>","rjust":"<callable: rjust>","rpartition":"<callable: rpartition>","rsplit":"<callable: rsplit>","rstrip":"<callable: rstrip>","split":"<callable: split>","splitlines":"<callable: splitlines>","startswith":"<callable: startswith>","strip":"<callable: strip>","swapcase":"<callable: swapcase>","title":"<callable: title>","translate":"<callable: translate>","upper":"<callable: upper>","zfill":"<callable: zfill>"}],"_content":"b'{\"max_tokens\":4096,\"messages\":[{\"role\":\"user\",\"content\":[{\"type\":\"text\",\"text\":\"please review https://github.com/awslabs/aws-c-s3/pull/519\"}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"I\\'ll review the pull request for potential code simplifications. Let\\'s start by examining the details of this pull request.\"},{\"type\":\"tool_use\",\"name\":\"github-get_pull_request\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"pull_number\":519},\"id\":\"toolu_bdrk_01FwvRSfACwCvLDq5ZXqfR3j\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01FwvRSfACwCvLDq5ZXqfR3j\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\n  \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/pulls/519\\\\\",\\\\n  \\\\\"id\\\\\": 2520395028,\\\\n  \\\\\"node_id\\\\\": \\\\\"PR_kwDOEJB4Sc6WOi0U\\\\\",\\\\n  \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519\\\\\",\\\\n  \\\\\"diff_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519.diff\\\\\",\\\\n  \\\\\"patch_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519.patch\\\\\",\\\\n  \\\\\"issue_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/issues/519\\\\\",\\\\n  \\\\\"number\\\\\": 519,\\\\n  \\\\\"state\\\\\": \\\\\"open\\\\\",\\\\n  \\\\\"locked\\\\\": false,\\\\n  \\\\\"title\\\\\": \\\\\"dummy test\\\\\",\\\\n  \\\\\"user\\\\\": {\\\\n    \\\\\"login\\\\\": \\\\\"TingDaoK\\\\\",\\\\n    \\\\\"id\\\\\": 26829806,\\\\n    \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/26829806?v=4\\\\\",\\\\n    \\\\\"url\\\\\": \\\\\"https://api.github.com/users/TingDaoK\\\\\",\\\\n    \\\\\"html_url\\\\\": \\\\\"https://github.com/TingDaoK\\\\\"\\\\n  },\\\\n  \\\\\"body\\\\\": \\\\\"*Issue #, if available:*\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n*Description of changes:*\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.\\\\\\\\r\\\\\\\\n\\\\\",\\\\n  \\\\\"created_at\\\\\": \\\\\"2025-05-14T21:35:46Z\\\\\",\\\\n  \\\\\"updated_at\\\\\": \\\\\"2025-05-14T23:38:00Z\\\\\",\\\\n  \\\\\"closed_at\\\\\": null,\\\\n  \\\\\"merged_at\\\\\": null,\\\\n  \\\\\"merge_commit_sha\\\\\": \\\\\"b8fc1c78ceeba7906b6ac56483199a3faaf5e9cd\\\\\",\\\\n  \\\\\"assignee\\\\\": null,\\\\n  \\\\\"assignees\\\\\": [],\\\\n  \\\\\"requested_reviewers\\\\\": [],\\\\n  \\\\\"labels\\\\\": [],\\\\n  \\\\\"head\\\\\": {\\\\n    \\\\\"label\\\\\": \\\\\"awslabs:dummy-delete-me\\\\\",\\\\n    \\\\\"ref\\\\\": \\\\\"dummy-delete-me\\\\\",\\\\n    \\\\\"sha\\\\\": \\\\\"e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6\\\\\",\\\\n    \\\\\"user\\\\\": {\\\\n      \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n      \\\\\"id\\\\\": 3299148,\\\\n      \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\"\\\\n    },\\\\n    \\\\\"repo\\\\\": {\\\\n      \\\\\"id\\\\\": 277903433,\\\\n      \\\\\"node_id\\\\\": \\\\\"MDEwOlJlcG9zaXRvcnkyNzc5MDM0MzM=\\\\\",\\\\n      \\\\\"name\\\\\": \\\\\"aws-c-s3\\\\\",\\\\n      \\\\\"full_name\\\\\": \\\\\"awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"private\\\\\": false,\\\\n      \\\\\"owner\\\\\": {\\\\n        \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n        \\\\\"id\\\\\": 3299148,\\\\n        \\\\\"node_id\\\\\": \\\\\"MDEyOk9yZ2FuaXphdGlvbjMyOTkxNDg=\\\\\",\\\\n        \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n        \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n        \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\",\\\\n        \\\\\"type\\\\\": \\\\\"Organization\\\\\"\\\\n      },\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"description\\\\\": \\\\\"C99 library implementation for communicating with the S3 service, designed for maximizing throughput on high bandwidth EC2 instances.\\\\\",\\\\n      \\\\\"fork\\\\\": false,\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"created_at\\\\\": \\\\\"2020-07-07T19:21:45Z\\\\\",\\\\n      \\\\\"updated_at\\\\\": \\\\\"2025-05-15T17:15:47Z\\\\\",\\\\n      \\\\\"pushed_at\\\\\": \\\\\"2025-05-15T17:16:08Z\\\\\",\\\\n      \\\\\"git_url\\\\\": \\\\\"git://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"ssh_url\\\\\": \\\\\"git@github.com:awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"clone_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"default_branch\\\\\": \\\\\"main\\\\\"\\\\n    }\\\\n  },\\\\n  \\\\\"base\\\\\": {\\\\n    \\\\\"label\\\\\": \\\\\"awslabs:main\\\\\",\\\\n    \\\\\"ref\\\\\": \\\\\"main\\\\\",\\\\n    \\\\\"sha\\\\\": \\\\\"7d2d4b3070109c882ff78e8719f60597c7ba0472\\\\\",\\\\n    \\\\\"user\\\\\": {\\\\n      \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n      \\\\\"id\\\\\": 3299148,\\\\n      \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\"\\\\n    },\\\\n    \\\\\"repo\\\\\": {\\\\n      \\\\\"id\\\\\": 277903433,\\\\n      \\\\\"node_id\\\\\": \\\\\"MDEwOlJlcG9zaXRvcnkyNzc5MDM0MzM=\\\\\",\\\\n      \\\\\"name\\\\\": \\\\\"aws-c-s3\\\\\",\\\\n      \\\\\"full_name\\\\\": \\\\\"awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"private\\\\\": false,\\\\n      \\\\\"owner\\\\\": {\\\\n        \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n        \\\\\"id\\\\\": 3299148,\\\\n        \\\\\"node_id\\\\\": \\\\\"MDEyOk9yZ2FuaXphdGlvbjMyOTkxNDg=\\\\\",\\\\n        \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n        \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n        \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\",\\\\n        \\\\\"type\\\\\": \\\\\"Organization\\\\\"\\\\n      },\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"description\\\\\": \\\\\"C99 library implementation for communicating with the S3 service, designed for maximizing throughput on high bandwidth EC2 instances.\\\\\",\\\\n      \\\\\"fork\\\\\": false,\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"created_at\\\\\": \\\\\"2020-07-07T19:21:45Z\\\\\",\\\\n      \\\\\"updated_at\\\\\": \\\\\"2025-05-15T17:15:47Z\\\\\",\\\\n      \\\\\"pushed_at\\\\\": \\\\\"2025-05-15T17:16:08Z\\\\\",\\\\n      \\\\\"git_url\\\\\": \\\\\"git://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"ssh_url\\\\\": \\\\\"git@github.com:awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"clone_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"default_branch\\\\\": \\\\\"main\\\\\"\\\\n    }\\\\n  }\\\\n}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Let\\'s examine the files that were changed in this pull request to understand the modifications:\"},{\"type\":\"tool_use\",\"name\":\"github-get_pull_request_files\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"pull_number\":519},\"id\":\"toolu_bdrk_016RmXx9ChH9APrjynA9UF5m\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_016RmXx9ChH9APrjynA9UF5m\",\"content\":[{\"type\":\"text\",\"text\":\"[\\\\n  {\\\\n    \\\\\"sha\\\\\": \\\\\"dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n    \\\\\"filename\\\\\": \\\\\"tests/s3_data_plane_tests.c\\\\\",\\\\n    \\\\\"status\\\\\": \\\\\"modified\\\\\",\\\\n    \\\\\"additions\\\\\": 49,\\\\n    \\\\\"deletions\\\\\": 0,\\\\n    \\\\\"changes\\\\\": 49,\\\\n    \\\\\"blob_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6/tests%2Fs3_data_plane_tests.c\\\\\",\\\\n    \\\\\"raw_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/raw/e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6/tests%2Fs3_data_plane_tests.c\\\\\",\\\\n    \\\\\"contents_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests%2Fs3_data_plane_tests.c?ref=e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6\\\\\",\\\\n    \\\\\"patch\\\\\": \\\\\"@@ -8114,3 +8114,52 @@ static int s_test_s3_default_get_without_content_length(struct aws_allocator *al\\\\\\\\n \\\\\\\\n     return AWS_OP_SUCCESS;\\\\\\\\n }\\\\\\\\n+\\\\\\\\n+struct aws_string *test_helper(struct aws_allocator *allocator) {\\\\\\\\n+    struct aws_string *host_name =\\\\\\\\n+        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n+    return host_name;\\\\\\\\n+}\\\\\\\\n+\\\\\\\\n+AWS_TEST_CASE(test_s3_default_get, aws_test_s3_default_get)\\\\\\\\n+static int aws_test_s3_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n+    (void)ctx;\\\\\\\\n+\\\\\\\\n+    struct aws_s3_tester tester;\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n+\\\\\\\\n+    struct aws_s3_client *client = NULL;\\\\\\\\n+    struct aws_s3_tester_client_options client_options;\\\\\\\\n+    AWS_ZERO_STRUCT(client_options);\\\\\\\\n+\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n+    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n+    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n+\\\\\\\\n+    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n+    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n+\\\\\\\\n+    struct aws_string *hsot_name = test_helper(allocator);\\\\\\\\n+\\\\\\\\n+    /* Put together a simple S3 Get Object request. */\\\\\\\\n+    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n+        allocator, aws_byte_cursor_from_string(hsot_name), g_pre_existing_object_1MB);\\\\\\\\n+\\\\\\\\n+    struct aws_s3_meta_request_options options;\\\\\\\\n+    AWS_ZERO_STRUCT(options);\\\\\\\\n+    /* Send default type */\\\\\\\\n+    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n+    options.message = message;\\\\\\\\n+    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n+\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n+        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n+\\\\\\\\n+    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n+    aws_http_message_release(message);\\\\\\\\n+    aws_s3_client_release(client);\\\\\\\\n+    aws_s3_tester_clean_up(&tester);\\\\\\\\n+\\\\\\\\n+    return AWS_OP_SUCCESS;\\\\\\\\n+}\\\\\"\\\\n  }\\\\n]\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now let\\'s get the content of the file to better understand the changes:\"},{\"type\":\"tool_use\",\"name\":\"github-get_file_contents\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"path\":\"tests/s3_data_plane_tests.c\",\"branch\":\"dummy-delete-me\"},\"id\":\"toolu_bdrk_01MB5Rkdd4L3U98WVwxmuFLY\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01MB5Rkdd4L3U98WVwxmuFLY\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\n  \\\\\"name\\\\\": \\\\\"s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"path\\\\\": \\\\\"tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"sha\\\\\": \\\\\"dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n  \\\\\"size\\\\\": 319574,\\\\n  \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests/s3_data_plane_tests.c?ref=dummy-delete-me\\\\\",\\\\n  \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"git_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/git/blobs/dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n  \\\\\"download_url\\\\\": \\\\\"https://raw.githubusercontent.com/awslabs/aws-c-s3/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"type\\\\\": \\\\\"file\\\\\",\\\\n  \\\\\"content\\\\\": \\\\\"/**\\\\\\\\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\\\\\\\\n * SPDX-License-Identifier: Apache-2.0.\\\\\\\\n */\\\\\\\\n\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_checksums.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\"\\\\\\\\n#include <aws/common/byte_buf.h>\\\\\\\\n#include <aws/common/clock.h>\\\\\\\\n#include <aws/common/common.h>\\\\\\\\n#include <aws/common/encoding.h>\\\\\\\\n#include <aws/common/environment.h>\\\\\\\\n#include <aws/common/ref_count.h>\\\\\\\\n#include <aws/http/request_response.h>\\\\\\\\n#include <aws/http/status_code.h>\\\\\\\\n#include <aws/io/channel_bootstrap.h>\\\\\\\\n#include <aws/io/event_loop.h>\\\\\\\\n#include <aws/io/host_resolver.h>\\\\\\\\n#include <aws/io/stream.h>\\\\\\\\n#include <aws/io/tls_channel_handler.h>\\\\\\\\n#include <aws/io/uri.h>\\\\\\\\n#include <aws/testing/aws_test_harness.h>\\\\\\\\n#include <aws/testing/stream_tester.h>\\\\\\\\n#include <inttypes.h>\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_create_destroy, s_test_s3_client_create_destroy)\\\\\\\\nstatic int s_test_s3_client_create_destroy(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_create_error, s_test_s3_client_create_error)\\\\\\\\nstatic int s_test_s3_client_create_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    struct aws_http_proxy_options proxy_options = {\\\\\\\\n        .connection_type = AWS_HPCT_HTTP_LEGACY,\\\\\\\\n        .host = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"localhost\\\\\\\\\\\\\"),\\\\\\\\n        .port = 8899,\\\\\\\\n    };\\\\\\\\n    client_config.proxy_options = &proxy_options;\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_client_create_error_with_invalid_memory_limit_config,\\\\\\\\n    s_test_s3_client_create_error_with_invalid_memory_limit_config)\\\\\\\\nstatic int s_test_s3_client_create_error_with_invalid_memory_limit_config(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    client_config.memory_limit_in_bytes = 100;\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n    client_config.memory_limit_in_bytes = GB_TO_BYTES(1);\\\\\\\\n    client_config.max_part_size = GB_TO_BYTES(2);\\\\\\\\n    client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_client_create_error_with_invalid_network_interface,\\\\\\\\n    s_test_s3_client_create_error_with_invalid_network_interface)\\\\\\\\nstatic int s_test_s3_client_create_error_with_invalid_network_interface(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor *interface_names_array = aws_mem_calloc(allocator, 1, sizeof(struct aws_byte_cursor));\\\\\\\\n    interface_names_array[0] = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"invalid-nic\\\\\\\\\\\\\");\\\\\\\\n    client_config.network_interface_names_array = interface_names_array;\\\\\\\\n    client_config.num_network_interface_names = 1;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_mem_release(allocator, interface_names_array);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_monitoring_options_override, s_test_s3_client_monitoring_options_override)\\\\\\\\nstatic int s_test_s3_client_monitoring_options_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_http_connection_monitoring_options monitoring_options = {.minimum_throughput_bytes_per_second = 3000};\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.monitoring_options = &monitoring_options};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        client->monitoring_options.minimum_throughput_bytes_per_second ==\\\\\\\\n        client_config.monitoring_options->minimum_throughput_bytes_per_second);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_proxy_ev_settings_override, s_test_s3_client_proxy_ev_settings_override)\\\\\\\\nstatic int s_test_s3_client_proxy_ev_settings_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_tls_connection_options tls_conn_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_conn_options);\\\\\\\\n\\\\\\\\n    struct proxy_env_var_settings proxy_ev_settings = {\\\\\\\\n        .env_var_type = AWS_HPEV_ENABLE,\\\\\\\\n        .tls_options = &tls_conn_options,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.proxy_ev_settings = &proxy_ev_settings};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->proxy_ev_settings->env_var_type == client_config.proxy_ev_settings->env_var_type);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_tcp_keep_alive_options_override, s_test_s3_client_tcp_keep_alive_options_override)\\\\\\\\nstatic int s_test_s3_client_tcp_keep_alive_options_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tcp_keep_alive_options keep_alive_options = {.keep_alive_interval_sec = 20};\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.tcp_keep_alive_options = &keep_alive_options};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        client->tcp_keep_alive_options->keep_alive_interval_sec ==\\\\\\\\n        client_config.tcp_keep_alive_options->keep_alive_interval_sec);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_max_active_connections_override, s_test_s3_client_max_active_connections_override)\\\\\\\\nstatic int s_test_s3_client_max_active_connections_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .max_active_connections_override = 10,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->max_active_connections_override == client_config.max_active_connections_override);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_byo_crypto_no_options, s_test_s3_client_byo_crypto_no_options)\\\\\\\\nstatic int s_test_s3_client_byo_crypto_no_options(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .tls_mode = AWS_MR_TLS_ENABLED,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_last_error() == AWS_ERROR_INVALID_ARGUMENT);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_byo_crypto_with_options, s_test_s3_client_byo_crypto_with_options)\\\\\\\\nstatic int s_test_s3_client_byo_crypto_with_options(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_conn_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_conn_options);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n    client_config.tls_connection_options = &tls_conn_options;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nsize_t s_test_max_active_connections_host_count = 0;\\\\\\\\n\\\\\\\\nsize_t s_test_get_max_active_connections_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    return s_test_max_active_connections_host_count;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_get_max_active_connections, s_test_s3_client_get_max_active_connections)\\\\\\\\nstatic int s_test_s3_client_get_max_active_connections(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)allocator;\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_client_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_client_bootstrap);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    *((uint32_t *)&mock_client->max_active_connections_override) = 0;\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = 100;\\\\\\\\n    mock_client->client_bootstrap = &mock_client_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_get_max_active_connections_host_address_count;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_requests[AWS_S3_META_REQUEST_TYPE_MAX];\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n        /* Setup test data. */\\\\\\\\n        mock_meta_requests[i] = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n        mock_meta_requests[i]->type = i;\\\\\\\\n        mock_meta_requests[i]->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    s_test_max_active_connections_host_count = 2;\\\\\\\\n\\\\\\\\n    /* Behavior should not be affected by max_active_connections_override since it is 0, and should just be in relation\\\\\\\\n     * to ideal-connection-count. */\\\\\\\\n    {\\\\\\\\n        ASSERT_TRUE(aws_s3_client_get_max_active_connections(mock_client, NULL) == mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->ideal_connection_count);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Max active connections override should now cap the calculated amount of active connections. */\\\\\\\\n    {\\\\\\\\n        *((uint32_t *)&mock_client->max_active_connections_override) = 3;\\\\\\\\n\\\\\\\\n        /* Assert that override is low enough to have effect */\\\\\\\\n        ASSERT_TRUE(mock_client->max_active_connections_override < mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(\\\\\\\\n            aws_s3_client_get_max_active_connections(mock_client, NULL) ==\\\\\\\\n            mock_client->max_active_connections_override);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(mock_client->max_active_connections_override < mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->max_active_connections_override);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Max active connections override should be ignored since the calculated amount of max connections is less. */\\\\\\\\n    {\\\\\\\\n        *((uint32_t *)&mock_client->max_active_connections_override) = 100000;\\\\\\\\n\\\\\\\\n        /* Assert that override is NOT low enough to have effect */\\\\\\\\n        ASSERT_TRUE(mock_client->max_active_connections_override > mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(aws_s3_client_get_max_active_connections(mock_client, NULL) == mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(mock_client->max_active_connections_override > mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->ideal_connection_count);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n        mock_meta_requests[i] = aws_s3_meta_request_release(mock_meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_request_create_destroy, s_test_s3_request_create_destroy)\\\\\\\\nstatic int s_test_s3_request_create_destroy(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const int request_tag = 1234;\\\\\\\\n    const enum aws_s3_request_type request_type = AWS_S3_REQUEST_TYPE_LIST_PARTS;\\\\\\\\n    const uint32_t part_number = 5678;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n    meta_request->client = aws_s3_client_acquire(client);\\\\\\\\n\\\\\\\\n    struct aws_http_message *request_message = aws_s3_tester_dummy_http_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(request_message != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n        meta_request, request_tag, request_type, part_number, AWS_S3_REQUEST_FLAG_RECORD_RESPONSE_HEADERS);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->meta_request == meta_request);\\\\\\\\n    ASSERT_TRUE(request->part_number == part_number);\\\\\\\\n    ASSERT_TRUE(request->request_tag == request_tag);\\\\\\\\n    ASSERT_TRUE(request->request_type == request_type);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"ListParts\\\\\\\\\\\\\", aws_string_c_str(request->operation_name));\\\\\\\\n    ASSERT_TRUE(request->record_response_headers == true);\\\\\\\\n\\\\\\\\n    aws_s3_request_setup_send_data(request, request_message);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->send_data.message != NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers == NULL);\\\\\\\\n\\\\\\\\n    request->send_data.response_headers = aws_http_headers_new(allocator);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers != NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.metrics != NULL);\\\\\\\\n    request->send_data.metrics = aws_s3_request_metrics_release(request->send_data.metrics);\\\\\\\\n\\\\\\\\n    aws_s3_request_clean_up_send_data(request);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->send_data.message == NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers == NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_status == 0);\\\\\\\\n\\\\\\\\n    aws_s3_request_release(request);\\\\\\\\n    aws_http_message_release(request_message);\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct s3_test_body_streaming_user_data {\\\\\\\\n    struct aws_s3_tester *tester;\\\\\\\\n    struct aws_allocator *allocator;\\\\\\\\n    uint64_t expected_range_start;\\\\\\\\n    uint64_t received_body_size;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic int s_s3_meta_request_test_body_streaming_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)body;\\\\\\\\n    (void)range_start;\\\\\\\\n\\\\\\\\n    struct s3_test_body_streaming_user_data *body_streaming_user_data = user_data;\\\\\\\\n\\\\\\\\n    body_streaming_user_data->received_body_size += body->len;\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_streaming_user_data->expected_range_start == range_start);\\\\\\\\n    body_streaming_user_data->expected_range_start += body->len;\\\\\\\\n\\\\\\\\n    aws_s3_tester_inc_counter1(body_streaming_user_data->tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test the meta request body streaming functionality. */\\\\\\\\nAWS_TEST_CASE(test_s3_meta_request_body_streaming, s_test_s3_meta_request_body_streaming)\\\\\\\\nstatic int s_test_s3_meta_request_body_streaming(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const uint32_t part_range0_start = 1;\\\\\\\\n    const uint32_t part_range0_end = part_range0_start + 4;\\\\\\\\n\\\\\\\\n    const uint32_t part_range1_start = part_range0_end + 1;\\\\\\\\n    const uint32_t part_range1_end = part_range1_start + 4;\\\\\\\\n\\\\\\\\n    const size_t request_response_body_size = 16;\\\\\\\\n\\\\\\\\n    const uint64_t total_object_size = (uint64_t)part_range1_end * request_response_body_size;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf response_body_source_buffer;\\\\\\\\n    aws_byte_buf_init(&response_body_source_buffer, allocator, request_response_body_size);\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor test_byte_cursor = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"0\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < request_response_body_size; ++i) {\\\\\\\\n        aws_byte_buf_append(&response_body_source_buffer, &test_byte_cursor);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct s3_test_body_streaming_user_data body_streaming_user_data = {\\\\\\\\n        .tester = &tester,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_event_loop_group *event_loop_group = aws_event_loop_group_new_default(allocator, 0, NULL);\\\\\\\\n    meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    meta_request->user_data = &body_streaming_user_data;\\\\\\\\n    *((size_t *)&meta_request->part_size) = request_response_body_size;\\\\\\\\n    meta_request->body_callback = s_s3_meta_request_test_body_streaming_callback;\\\\\\\\n    meta_request->io_event_loop = aws_event_loop_group_get_next_loop(event_loop_group);\\\\\\\\n\\\\\\\\n    /* Queue the first range of parts in order. Each part should be flushed one-by-one. */\\\\\\\\n    {\\\\\\\\n        for (uint32_t part_number = part_range0_start; part_number <= part_range0_end; ++part_number) {\\\\\\\\n            struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n                meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_number, 0 /*flags*/);\\\\\\\\n\\\\\\\\n            aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n                0ULL,\\\\\\\\n                total_object_size - 1,\\\\\\\\n                request_response_body_size /*part_size*/,\\\\\\\\n                (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n                part_number,\\\\\\\\n                &request->part_range_start,\\\\\\\\n                &request->part_range_end);\\\\\\\\n\\\\\\\\n            aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n            aws_s3_tester_set_counter1_desired(&tester, part_number);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n            ASSERT_TRUE(aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == 0);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_tester_wait_for_counters(&tester);\\\\\\\\n\\\\\\\\n            aws_s3_request_release(request);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_set_counter1_desired(&tester, part_range1_end);\\\\\\\\n\\\\\\\\n    /* Queue parts for second range, but skip over the first part.*/\\\\\\\\n    {\\\\\\\\n        uint32_t num_parts_queued = 0;\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(part_range1_start != part_range1_end);\\\\\\\\n\\\\\\\\n        for (uint32_t part_number = part_range1_start + 1; part_number <= part_range1_end; ++part_number) {\\\\\\\\n            struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n                meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_number, 0 /*flags*/);\\\\\\\\n\\\\\\\\n            aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n                0ULL,\\\\\\\\n                total_object_size - 1,\\\\\\\\n                request_response_body_size /*part_size*/,\\\\\\\\n                (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n                part_number,\\\\\\\\n                &request->part_range_start,\\\\\\\\n                &request->part_range_end);\\\\\\\\n\\\\\\\\n            aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n            aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n            aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_request_release(request);\\\\\\\\n            ++num_parts_queued;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        ASSERT_TRUE(\\\\\\\\n            aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == num_parts_queued);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Stream the last part of the body, which should flush the priority queue. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n            meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_range1_start, 0 /*flags*/);\\\\\\\\n\\\\\\\\n        aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n            0ULL,\\\\\\\\n            total_object_size - 1,\\\\\\\\n            request_response_body_size /*part_size*/,\\\\\\\\n            (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n            part_range1_start,\\\\\\\\n            &request->part_range_start,\\\\\\\\n            &request->part_range_end);\\\\\\\\n\\\\\\\\n        aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        ASSERT_TRUE(aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == 0);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n        aws_s3_request_release(request);\\\\\\\\n\\\\\\\\n        aws_s3_tester_wait_for_counters(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_streaming_user_data.received_body_size == (request_response_body_size * part_range1_end));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_event_loop_group_release(event_loop_group);\\\\\\\\n    aws_byte_buf_clean_up(&response_body_source_buffer);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test aws_s3_client_queue_requests_threaded and aws_s3_client_dequeue_request_threaded */\\\\\\\\nAWS_TEST_CASE(test_s3_client_queue_requests, s_test_s3_client_queue_requests)\\\\\\\\nstatic int s_test_s3_client_queue_requests(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *pivot_request = aws_s3_request_new(mock_meta_request, 0, 0, 0, 0);\\\\\\\\n\\\\\\\\n    struct aws_linked_list pivot_request_list;\\\\\\\\n    aws_linked_list_init(&pivot_request_list);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *requests[] = {\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    const uint32_t num_requests = AWS_ARRAY_SIZE(requests);\\\\\\\\n\\\\\\\\n    struct aws_linked_list request_list;\\\\\\\\n    aws_linked_list_init(&request_list);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        aws_linked_list_push_back(&pivot_request_list, &pivot_request->node);\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &pivot_request_list, false);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 1);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n            aws_linked_list_push_back(&request_list, &requests[i]->node);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Move the requests to the back of the queue. */\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &request_list, false);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&request_list));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests + 1));\\\\\\\\n    ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        /* The first request should be the pivot request since the other requests were pushed to the back. */\\\\\\\\n        struct aws_s3_request *first_request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n        ASSERT_TRUE(first_request == pivot_request);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == num_requests);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        struct aws_s3_request *request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(request == requests[i]);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests - (i + 1)));\\\\\\\\n\\\\\\\\n        if (i < num_requests - 1) {\\\\\\\\n            ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        aws_linked_list_push_back(&pivot_request_list, &pivot_request->node);\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &pivot_request_list, false);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 1);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n            aws_linked_list_push_back(&request_list, &requests[i]->node);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Move the requests to the front of the queue. */\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &request_list, true);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&request_list));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests + 1));\\\\\\\\n    ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        struct aws_s3_request *request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(request == requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        /* The last request should be the pivot request since the other requests were pushed to the front. */\\\\\\\\n        struct aws_s3_request *last_request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n        ASSERT_TRUE(last_request == pivot_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        aws_s3_request_release(requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_request_release(pivot_request);\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct test_work_meta_request_update_user_data {\\\\\\\\n    bool has_work_remaining;\\\\\\\\n    uint32_t num_prepares;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic bool s_s3_test_work_meta_request_update(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    uint32_t flags,\\\\\\\\n    struct aws_s3_request **out_request) {\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data *user_data = meta_request->user_data;\\\\\\\\n\\\\\\\\n    if (out_request) {\\\\\\\\n        if (user_data->has_work_remaining) {\\\\\\\\n            *out_request = aws_s3_request_new(meta_request, 0, 0, 0, 0);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return user_data->has_work_remaining;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_work_meta_request_schedule_prepare_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    aws_s3_meta_request_prepare_request_callback_fn *callback,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)request;\\\\\\\\n    (void)callback;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data *test_user_data = meta_request->user_data;\\\\\\\\n    ++test_user_data->num_prepares;\\\\\\\\n\\\\\\\\n    aws_s3_request_release(request);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic size_t s_test_s3_update_meta_request_trigger_prepare_host_address_count = 0;\\\\\\\\n\\\\\\\\nstatic size_t s_test_s3_update_meta_request_trigger_prepare_get_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n    return s_test_s3_update_meta_request_trigger_prepare_host_address_count;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_validate_prepared_requests(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    size_t expected_num_being_prepared,\\\\\\\\n    struct aws_s3_meta_request *meta_request_with_work,\\\\\\\\n    struct aws_s3_meta_request *meta_request_without_work) {\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->threaded_data.request_queue_size == 0);\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&client->threaded_data.request_queue));\\\\\\\\n    ASSERT_TRUE(client->threaded_data.num_requests_being_prepared == expected_num_being_prepared);\\\\\\\\n    ASSERT_TRUE(aws_atomic_load_int(&client->stats.num_requests_in_flight) == expected_num_being_prepared);\\\\\\\\n\\\\\\\\n    uint32_t num_meta_requests_in_list = 0;\\\\\\\\n    bool meta_request_with_work_found = false;\\\\\\\\n\\\\\\\\n    for (struct aws_linked_list_node *node = aws_linked_list_begin(&client->threaded_data.meta_requests);\\\\\\\\n         node != aws_linked_list_end(&client->threaded_data.meta_requests);\\\\\\\\n         node = aws_linked_list_next(node)) {\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request *meta_request =\\\\\\\\n            AWS_CONTAINER_OF(node, struct aws_s3_meta_request, client_process_work_threaded_data);\\\\\\\\n\\\\\\\\n        if (meta_request == meta_request_with_work) {\\\\\\\\n            meta_request_with_work_found = true;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_request != meta_request_without_work);\\\\\\\\n\\\\\\\\n        ++num_meta_requests_in_list;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_with_work_found);\\\\\\\\n    ASSERT_TRUE(num_meta_requests_in_list == 1);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the client will prepare requests correctly. */\\\\\\\\nAWS_TEST_CASE(test_s3_update_meta_requests_trigger_prepare, s_test_s3_update_meta_requests_trigger_prepare)\\\\\\\\nstatic int s_test_s3_update_meta_requests_trigger_prepare(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_bootstrap);\\\\\\\\n\\\\\\\\n    const uint32_t ideal_connection_count = 100;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    mock_client->client_bootstrap = &mock_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_s3_update_meta_request_trigger_prepare_get_host_address_count;\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = ideal_connection_count;\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.meta_requests);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request_without_work = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request_without_work->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    mock_meta_request_without_work->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data mock_meta_request_without_work_data = {\\\\\\\\n        .has_work_remaining = false,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    mock_meta_request_without_work->user_data = &mock_meta_request_without_work_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *meta_request_without_work_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request_without_work, NULL);\\\\\\\\n    meta_request_without_work_vtable->update = s_s3_test_work_meta_request_update;\\\\\\\\n    meta_request_without_work_vtable->schedule_prepare_request = s_s3_test_work_meta_request_schedule_prepare_request;\\\\\\\\n\\\\\\\\n    /* Intentionally push this meta request first to test that it\\'s properly removed from the list. */\\\\\\\\n    aws_linked_list_push_back(\\\\\\\\n        &mock_client->threaded_data.meta_requests,\\\\\\\\n        &mock_meta_request_without_work->client_process_work_threaded_data.node);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_acquire(mock_meta_request_without_work);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request_with_work = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request_with_work->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    struct test_work_meta_request_update_user_data mock_meta_request_with_work_data = {\\\\\\\\n        .has_work_remaining = true,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    mock_meta_request_with_work->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n    mock_meta_request_with_work->user_data = &mock_meta_request_with_work_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *mock_meta_request_with_work_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request_with_work, NULL);\\\\\\\\n    mock_meta_request_with_work_vtable->update = s_s3_test_work_meta_request_update;\\\\\\\\n    mock_meta_request_with_work_vtable->schedule_prepare_request = s_s3_test_work_meta_request_schedule_prepare_request;\\\\\\\\n\\\\\\\\n    aws_linked_list_push_back(\\\\\\\\n        &mock_client->threaded_data.meta_requests,\\\\\\\\n        &mock_meta_request_with_work->client_process_work_threaded_data.node);\\\\\\\\n    aws_s3_meta_request_acquire(mock_meta_request_with_work);\\\\\\\\n\\\\\\\\n    /* With no known addresses, the amount of requests that can be prepared should be lower. */\\\\\\\\n    {\\\\\\\\n        s_test_s3_update_meta_request_trigger_prepare_host_address_count = 0;\\\\\\\\n        aws_s3_client_update_meta_requests_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(s_validate_prepared_requests(\\\\\\\\n            mock_client, g_min_num_connections, mock_meta_request_with_work, mock_meta_request_without_work));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* When the number of known addresses is 1+, the max number of requests should be reached. */\\\\\\\\n    {\\\\\\\\n        const uint32_t max_requests_prepare = aws_s3_client_get_max_requests_prepare(mock_client);\\\\\\\\n\\\\\\\\n        s_test_s3_update_meta_request_trigger_prepare_host_address_count = 1;\\\\\\\\n        aws_s3_client_update_meta_requests_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(s_validate_prepared_requests(\\\\\\\\n            mock_client, max_requests_prepare, mock_meta_request_with_work, mock_meta_request_without_work));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    while (!aws_linked_list_empty(&mock_client->threaded_data.meta_requests)) {\\\\\\\\n        struct aws_linked_list_node *meta_request_node =\\\\\\\\n            aws_linked_list_pop_front(&mock_client->threaded_data.meta_requests);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request *meta_request =\\\\\\\\n            AWS_CONTAINER_OF(meta_request_node, struct aws_s3_meta_request, client_process_work_threaded_data);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_release(meta_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request_without_work);\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request_with_work);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct s3_test_update_connections_finish_result_user_data {\\\\\\\\n    struct aws_s3_request *finished_request;\\\\\\\\n    struct aws_s3_request *create_connection_request;\\\\\\\\n\\\\\\\\n    uint32_t finished_request_call_counter;\\\\\\\\n    uint32_t create_connection_request_call_counter;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic void s_s3_test_meta_request_has_finish_result_finished_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    AWS_ASSERT(request);\\\\\\\\n    (void)error_code;\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data *user_data = meta_request->user_data;\\\\\\\\n    user_data->finished_request = request;\\\\\\\\n    ++user_data->finished_request_call_counter;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_meta_request_has_finish_result_client_create_connection_for_request(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    struct aws_s3_request *request) {\\\\\\\\n    (void)client;\\\\\\\\n    (void)request;\\\\\\\\n    AWS_ASSERT(client);\\\\\\\\n    AWS_ASSERT(request);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = request->meta_request;\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data *user_data = meta_request->user_data;\\\\\\\\n    user_data->create_connection_request = request;\\\\\\\\n    ++user_data->create_connection_request_call_counter;\\\\\\\\n}\\\\\\\\n\\\\\\\\nsize_t s_test_update_conns_finish_result_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    return 1;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the client will correctly discard requests for meta requests that are trying to finish. */\\\\\\\\nAWS_TEST_CASE(test_s3_client_update_connections_finish_result, s_test_s3_client_update_connections_finish_result)\\\\\\\\nstatic int s_test_s3_client_update_connections_finish_result(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_client_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_client_bootstrap);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    mock_client->client_bootstrap = &mock_client_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_update_conns_finish_result_host_address_count;\\\\\\\\n    mock_client->vtable->create_connection_for_request =\\\\\\\\n        s_s3_test_meta_request_has_finish_result_client_create_connection_for_request;\\\\\\\\n\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = 1;\\\\\\\\n\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data test_update_connections_finish_result_user_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_update_connections_finish_result_user_data);\\\\\\\\n\\\\\\\\n    /* Put together a mock meta request that is finished. */\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    mock_meta_request->synced_data.finish_result_set = true;\\\\\\\\n    mock_meta_request->user_data = &test_update_connections_finish_result_user_data;\\\\\\\\n    mock_meta_request->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *mock_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request, NULL);\\\\\\\\n    mock_meta_request_vtable->finished_request = s_s3_test_meta_request_has_finish_result_finished_request;\\\\\\\\n\\\\\\\\n    /* Verify that the request does not get sent because the meta request has finish-result. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request = aws_s3_request_new(mock_meta_request, 0, 0, 0, 0);\\\\\\\\n        aws_linked_list_push_back(&mock_client->threaded_data.request_queue, &request->node);\\\\\\\\n        ++mock_client->threaded_data.request_queue_size;\\\\\\\\n\\\\\\\\n        aws_s3_client_update_connections_threaded(mock_client);\\\\\\\\n\\\\\\\\n        /* Request should still have been dequeued, but immediately passed to the meta request finish function. */\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n        ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request == request);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request_call_counter == 1);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request == NULL);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request_call_counter == 0);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    AWS_ZERO_STRUCT(test_update_connections_finish_result_user_data);\\\\\\\\n\\\\\\\\n    /* Verify that a request with the \\'always send\\' flag still gets sent when the meta request has a finish-result. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request =\\\\\\\\n            aws_s3_request_new(mock_meta_request, 0, 0, 0, AWS_S3_REQUEST_FLAG_ALWAYS_SEND);\\\\\\\\n        aws_linked_list_push_back(&mock_client->threaded_data.request_queue, &request->node);\\\\\\\\n        ++mock_client->threaded_data.request_queue_size;\\\\\\\\n\\\\\\\\n        aws_s3_client_update_connections_threaded(mock_client);\\\\\\\\n\\\\\\\\n        /* Request should have been dequeued, and then sent on a connection. */\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n        ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request == NULL);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request_call_counter == 0);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request == request);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request_call_counter == 1);\\\\\\\\n\\\\\\\\n        aws_s3_request_release(request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_get_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    enum aws_s3_client_tls_usage tls_usage,\\\\\\\\n    uint32_t extra_meta_request_flag,\\\\\\\\n    struct aws_byte_cursor s3_path) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_connection_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_connection_options);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    struct aws_tls_ctx_options tls_context_options;\\\\\\\\n    aws_tls_ctx_options_init_default_client(&tls_context_options, allocator);\\\\\\\\n\\\\\\\\n    struct aws_tls_ctx *context = aws_tls_client_ctx_new(allocator, &tls_context_options);\\\\\\\\n    aws_tls_connection_options_init_from_ctx(&tls_connection_options, context);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    struct aws_string *endpoint =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n    struct aws_byte_cursor endpoint_cursor = aws_byte_cursor_from_string(endpoint);\\\\\\\\n\\\\\\\\n    tls_connection_options.server_name = aws_string_new_from_cursor(allocator, &endpoint_cursor);\\\\\\\\n\\\\\\\\n    switch (tls_usage) {\\\\\\\\n        case AWS_S3_TLS_ENABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n            client_config.tls_connection_options = &tls_connection_options;\\\\\\\\n            break;\\\\\\\\n        case AWS_S3_TLS_DISABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_DISABLED;\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS | extra_meta_request_flag;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_get_object_meta_request(&tester, client, s3_path, flags, NULL));\\\\\\\\n\\\\\\\\n    aws_string_destroy(endpoint);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    aws_tls_ctx_release(context);\\\\\\\\n    aws_tls_connection_options_clean_up(&tls_connection_options);\\\\\\\\n    aws_tls_ctx_options_clean_up(&tls_context_options);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_disabled, s_test_s3_get_object_tls_disabled)\\\\\\\\nstatic int s_test_s3_get_object_tls_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_DISABLED, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_enabled, s_test_s3_get_object_tls_enabled)\\\\\\\\nstatic int s_test_s3_get_object_tls_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_ENABLED, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_default, s_test_s3_get_object_tls_default)\\\\\\\\nstatic int s_test_s3_get_object_tls_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_DEFAULT, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_no_signing, s_test_s3_no_signing)\\\\\\\\nstatic int s_test_s3_no_signing(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_signing_override, s_test_s3_signing_override)\\\\\\\\nstatic int s_test_s3_signing_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    /* Getting without signing should fail since the client has no signing set up. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request.*/\\\\\\\\n        struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request(&tester, client, &options, &meta_request_test_results, 0));\\\\\\\\n        ASSERT_TRUE(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0) != AWS_OP_SUCCESS);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Getting with signing should succeed if we set up signing on the meta request. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n        options.signing_config = &tester.default_signing_config;\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request. */\\\\\\\\n        struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n            &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_less_than_part_size, s_test_s3_get_object_less_than_part_size)\\\\\\\\nstatic int s_test_s3_get_object_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_get_object_meta_request(\\\\\\\\n        &tester, client, g_pre_existing_object_1MB, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_with_part_remainder, s_test_s3_put_object_with_part_remainder)\\\\\\\\nstatic int s_test_s3_put_object_with_part_remainder(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Object size meant to be one megabyte larger than the part size of the client. */\\\\\\\\n                .object_size_mb = 6,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multiple, s_test_s3_get_object_multiple)\\\\\\\\nstatic int s_test_s3_get_object_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_requests[4];\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results[4];\\\\\\\\n    size_t num_meta_requests = AWS_ARRAY_SIZE(meta_requests);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(num_meta_requests == AWS_ARRAY_SIZE(meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        /* Put together a simple S3 Get Object request. */\\\\\\\\n        struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n            allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results[i], allocator);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results[i]));\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request. */\\\\\\\\n        meta_requests[i] = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_requests[i] != NULL);\\\\\\\\n\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        meta_requests[i] = aws_s3_meta_request_release(meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        aws_s3_tester_validate_get_object_results(&meta_request_test_results[i], 0);\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multiple_serial, s_test_s3_get_object_multiple_serial)\\\\\\\\nstatic int s_test_s3_get_object_multiple_serial(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-10MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < 4; ++i) {\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Sleep for some time to wait for the cleanup task to run */\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(7, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    /* BEGIN CRITICAL SECTION */\\\\\\\\n    aws_s3_client_lock_synced_data(client);\\\\\\\\n\\\\\\\\n    AWS_ASSERT(client->synced_data.num_endpoints_allocated == 0);\\\\\\\\n\\\\\\\\n    aws_s3_client_unlock_synced_data(client);\\\\\\\\n    /* END CRITICAL SECTION */\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path, s_test_s3_get_object_file_path)\\\\\\\\nstatic int s_test_s3_get_object_file_path(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_create_new, s_test_s3_get_object_file_path_create_new)\\\\\\\\nstatic int s_test_s3_get_object_file_path_create_new(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_CREATE_NEW,\\\\\\\\n                .pre_exist_file_length = 10,\\\\\\\\n                .recv_file_delete_on_failure = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_RECV_FILE_ALREADY_EXISTS, aws_last_error());\\\\\\\\n\\\\\\\\n    /* The request failed without invoking the finish callback. Reset the finish and shutdown count */\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_shutdown_count);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n    tester.synced_data.desired_meta_request_shutdown_count = 0;\\\\\\\\n    tester.synced_data.desired_meta_request_finish_count = 0;\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    get_options.validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS;\\\\\\\\n    get_options.get_options.pre_exist_file_length = 0;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_append, s_test_s3_get_object_file_path_append)\\\\\\\\nstatic int s_test_s3_get_object_file_path_append(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    uint64_t pre_exist_file_length = 10;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_CREATE_OR_APPEND,\\\\\\\\n                .pre_exist_file_length = pre_exist_file_length,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(pre_exist_file_length + MB_TO_BYTES(1), meta_request_test_results.received_file_size);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), meta_request_test_results.progress.total_bytes_transferred);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_to_position, s_test_s3_get_object_file_path_to_position)\\\\\\\\nstatic int s_test_s3_get_object_file_path_to_position(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    uint64_t pre_exist_file_length = 10;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_WRITE_TO_POSITION,\\\\\\\\n                .pre_exist_file_length = 0,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_RECV_FILE_NOT_FOUND, aws_last_error());\\\\\\\\n\\\\\\\\n    /* The request failed without invoking the finish callback. Reset the finish and shutdown count */\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_shutdown_count);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n    tester.synced_data.desired_meta_request_shutdown_count = 0;\\\\\\\\n    tester.synced_data.desired_meta_request_finish_count = 0;\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    get_options.validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS;\\\\\\\\n    get_options.get_options.pre_exist_file_length = pre_exist_file_length;\\\\\\\\n    get_options.get_options.recv_file_position = 20;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(\\\\\\\\n        get_options.get_options.recv_file_position + MB_TO_BYTES(1), meta_request_test_results.received_file_size);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), meta_request_test_results.progress.total_bytes_transferred);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_empty_object, s_test_s3_get_object_empty_default)\\\\\\\\nstatic int s_test_s3_get_object_empty_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    return (s_test_s3_get_object_helper(allocator, AWS_S3_TLS_ENABLED, 0, g_pre_existing_empty_object));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_sse_kms, s_test_s3_get_object_sse_kms)\\\\\\\\nstatic int s_test_s3_get_object_sse_kms(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Keep TLS enabled for SSE related download, or it will fail. */\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, AWS_S3_TESTER_SEND_META_REQUEST_SSE_KMS, g_pre_existing_object_kms_10MB);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_sse_aes256, s_test_s3_get_object_sse_aes256)\\\\\\\\nstatic int s_test_s3_get_object_sse_aes256(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Keep TLS enabled for SSE related download, or it will fail. */\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, AWS_S3_TESTER_SEND_META_REQUEST_SSE_AES256, g_pre_existing_object_aes256_10MB);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Assert that GetObject can download an object whose body is XML identical to an \\\\\\\\\\\\\"async error\\\\\\\\\\\\\" aka \\\\\\\\\\\\\"200 error\\\\\\\\\\\\\":\\\\\\\\n * <?xml version=\\\\\\\\\\\\\"1.0\\\\\\\\\\\\\" encoding=\\\\\\\\\\\\\"UTF-8\\\\\\\\\\\\\"?>\\\\\\\\\\\\\\\\n<Error><Code>InternalError</Code>... */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_looks_like_async_error_xml, s_test_s3_get_object_looks_like_async_error_xml)\\\\\\\\nstatic int s_test_s3_get_object_looks_like_async_error_xml(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, 0 /*extra_meta_request_flag*/, g_pre_existing_object_async_error_xml);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Same as above, but send the \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\" via AWS_S3_META_REQUEST_TYPE_DEFAULT\\\\\\\\n * (instead of the typical AWS_S3_META_REQUEST_TYPE_GET_OBJECT) */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_default_get_object_looks_like_async_error_xml,\\\\\\\\n    s_test_s3_default_get_object_looks_like_async_error_xml)\\\\\\\\nstatic int s_test_s3_default_get_object_looks_like_async_error_xml(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_async_error_xml,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test read-backpressure functionality by repeatedly:\\\\\\\\n * - letting the download stall\\\\\\\\n * - incrementing the read window\\\\\\\\n * - repeat...\\\\\\\\n */\\\\\\\\nstatic int s_apply_backpressure_until_meta_request_finish(\\\\\\\\n    struct aws_s3_tester *tester,\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results,\\\\\\\\n    size_t part_size,\\\\\\\\n    size_t window_initial_size,\\\\\\\\n    uint64_t window_increment_size) {\\\\\\\\n\\\\\\\\n    /* Remember the last time something happened (we received download data, or incremented read window) */\\\\\\\\n    uint64_t last_time_something_happened;\\\\\\\\n    ASSERT_SUCCESS(aws_sys_clock_get_ticks(&last_time_something_happened));\\\\\\\\n\\\\\\\\n    /* To ensure that backpressure is working, we wait a bit after download stalls\\\\\\\\n     * before incrementing the read window again.\\\\\\\\n     * This number also controls the max time we wait for bytes to start arriving\\\\\\\\n     * after incrementing the window.\\\\\\\\n     * If the magic number is too high the test will be slow,\\\\\\\\n     * if it\\'s too low the test will fail on slow networks */\\\\\\\\n    const uint64_t wait_duration_with_nothing_happening =\\\\\\\\n        aws_timestamp_convert(3, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL);\\\\\\\\n\\\\\\\\n    uint64_t accumulated_window_increments = window_initial_size;\\\\\\\\n    uint64_t accumulated_data_size = 0;\\\\\\\\n\\\\\\\\n    while (true) {\\\\\\\\n        /* Check if meta-request is done (don\\'t exit yet, we want to check some numbers first...) */\\\\\\\\n        aws_s3_tester_lock_synced_data(tester);\\\\\\\\n        bool done = tester->synced_data.meta_requests_finished != 0;\\\\\\\\n        aws_s3_tester_unlock_synced_data(tester);\\\\\\\\n\\\\\\\\n        /* Check how much data we\\'ve received */\\\\\\\\n        size_t received_body_size_delta = aws_atomic_exchange_int(&test_results->received_body_size_delta, 0);\\\\\\\\n        accumulated_data_size += (uint64_t)received_body_size_delta;\\\\\\\\n\\\\\\\\n        /* Check that we haven\\'t received more data than the window allows.\\\\\\\\n         * TODO: Stop allowing \\\\\\\\\\\\\"hacky wiggle room\\\\\\\\\\\\\". The current implementation\\\\\\\\n         *       may push more bytes to the user (up to 1 part) than they\\'ve asked for. */\\\\\\\\n        uint64_t hacky_wiggle_room = part_size;\\\\\\\\n        uint64_t max_data_allowed = accumulated_window_increments + hacky_wiggle_room;\\\\\\\\n        ASSERT_TRUE(accumulated_data_size <= max_data_allowed, \\\\\\\\\\\\\"Received more data than the read window allows\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        /* If we\\'re done, we\\'re done */\\\\\\\\n        if (done) {\\\\\\\\n            break;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Figure out how long it\\'s been since we last received data */\\\\\\\\n        uint64_t current_time;\\\\\\\\n        ASSERT_SUCCESS(aws_sys_clock_get_ticks(&current_time));\\\\\\\\n\\\\\\\\n        if (received_body_size_delta != 0) {\\\\\\\\n            last_time_something_happened = current_time;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        uint64_t duration_since_something_happened = current_time - last_time_something_happened;\\\\\\\\n\\\\\\\\n        /* If it seems like data has stopped flowing... */\\\\\\\\n        if (duration_since_something_happened >= wait_duration_with_nothing_happening) {\\\\\\\\n\\\\\\\\n            /* Assert that data stopped flowing because the window reached 0. */\\\\\\\\n            uint64_t current_window = aws_sub_u64_saturating(accumulated_window_increments, accumulated_data_size);\\\\\\\\n            ASSERT_INT_EQUALS(0, current_window, \\\\\\\\\\\\\"Data stopped flowing but read window isn\\'t 0 yet.\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n            /* Open the window a bit (this resets the \\\\\\\\\\\\\"something happened\\\\\\\\\\\\\" timer */\\\\\\\\n            accumulated_window_increments += window_increment_size;\\\\\\\\n            aws_s3_meta_request_increment_read_window(meta_request, window_increment_size);\\\\\\\\n\\\\\\\\n            last_time_something_happened = current_time;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Sleep a moment, and loop again... */\\\\\\\\n        aws_thread_current_sleep(aws_timestamp_convert(100, AWS_TIMESTAMP_MILLIS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_get_object_backpressure_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    size_t part_size,\\\\\\\\n    size_t window_initial_size,\\\\\\\\n    uint64_t window_increment_size,\\\\\\\\n    bool file_on_disk) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = part_size,\\\\\\\\n        .enable_read_backpressure = true,\\\\\\\\n        .initial_read_window = window_initial_size,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options = {\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .message = message,\\\\\\\\n    };\\\\\\\\n    struct aws_string *filepath_str = NULL;\\\\\\\\n    if (file_on_disk) {\\\\\\\\n        filepath_str = aws_s3_tester_create_file(allocator, g_pre_existing_object_1MB, NULL);\\\\\\\\n        options.recv_filepath = aws_byte_cursor_from_string(filepath_str);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Increment read window bit by bit until all data is downloaded */\\\\\\\\n    ASSERT_SUCCESS(s_apply_backpressure_until_meta_request_finish(\\\\\\\\n        &tester, meta_request, &meta_request_test_results, part_size, window_initial_size, window_increment_size));\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    /* Regression test:\\\\\\\\n     * Ensure that it\\'s safe to call increment-window even after the meta-request has finished */\\\\\\\\n    aws_s3_meta_request_increment_read_window(meta_request, 1024);\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    if (filepath_str) {\\\\\\\\n        aws_file_delete(filepath_str);\\\\\\\\n        aws_string_destroy(filepath_str);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_small_increments, s_test_s3_get_object_backpressure_small_increments)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_small_increments(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments smaller than part-size.\\\\\\\\n     * Only 1 part at a time should be in flight */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_big_increments, s_test_s3_get_object_backpressure_big_increments)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_big_increments(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments larger than part-size.\\\\\\\\n     * Multiple parts should be in flight at a time */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 8;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size * 3;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_initial_size_zero, s_test_s3_get_object_backpressure_initial_size_zero)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_initial_size_zero(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test with initial window size of zero */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 0;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_small_increments_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_small_increments_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_small_increments_recv_filepath(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    /* Test increments smaller than part-size.\\\\\\\\n     * Only 1 part at a time should be in flight */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_big_increments_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_big_increments_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_big_increments_recv_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments larger than part-size.\\\\\\\\n     * Multiple parts should be in flight at a time */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 8;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size * 3;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_initial_size_zero_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_initial_size_zero_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_initial_size_zero_recv_filepath(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    /* Test with initial window size of zero */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 0;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_part, s_test_s3_get_object_part)\\\\\\\\nstatic int s_test_s3_get_object_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/get_object_part_test\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /* GET FILE */\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_NO_VALIDATE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .part_number = 2,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_SUCCESS, meta_request_test_results.finished_error_code);\\\\\\\\n    /* Only one request was made to get the second part of the object */\\\\\\\\n    ASSERT_UINT_EQUALS(1, aws_array_list_length(&meta_request_test_results.synced_data.metrics));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    enum aws_s3_client_tls_usage tls_usage,\\\\\\\\n    uint32_t extra_meta_request_flag) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_connection_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_connection_options);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    struct aws_tls_ctx_options tls_context_options;\\\\\\\\n    aws_tls_ctx_options_init_default_client(&tls_context_options, allocator);\\\\\\\\n\\\\\\\\n    struct aws_tls_ctx *context = aws_tls_client_ctx_new(allocator, &tls_context_options);\\\\\\\\n    aws_tls_connection_options_init_from_ctx(&tls_connection_options, context);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    struct aws_string *endpoint =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n    struct aws_byte_cursor endpoint_cursor = aws_byte_cursor_from_string(endpoint);\\\\\\\\n\\\\\\\\n    tls_connection_options.server_name = aws_string_new_from_cursor(allocator, &endpoint_cursor);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    switch (tls_usage) {\\\\\\\\n        case AWS_S3_TLS_ENABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n            client_config.tls_connection_options = &tls_connection_options;\\\\\\\\n            break;\\\\\\\\n        case AWS_S3_TLS_DISABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_DISABLED;\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_put_object_meta_request(\\\\\\\\n        &tester, client, 10, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS | extra_meta_request_flag, NULL));\\\\\\\\n\\\\\\\\n    aws_string_destroy(endpoint);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    aws_tls_ctx_release(context);\\\\\\\\n    aws_tls_connection_options_clean_up(&tls_connection_options);\\\\\\\\n    aws_tls_ctx_options_clean_up(&tls_context_options);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_disabled, s_test_s3_put_object_tls_disabled)\\\\\\\\nstatic int s_test_s3_put_object_tls_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DISABLED, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_enabled, s_test_s3_put_object_tls_enabled)\\\\\\\\nstatic int s_test_s3_put_object_tls_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_ENABLED, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_default, s_test_s3_put_object_tls_default)\\\\\\\\nstatic int s_test_s3_put_object_tls_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DEFAULT, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_put_object_with_acl, s_test_s3_multipart_put_object_with_acl)\\\\\\\\nstatic int s_test_s3_multipart_put_object_with_acl(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DEFAULT, AWS_S3_TESTER_SEND_META_REQUEST_PUT_ACL));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_multiple_helper(struct aws_allocator *allocator, bool file_on_disk) {\\\\\\\\n\\\\\\\\n    enum s_numbers { NUM_REQUESTS = 5 };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_requests[NUM_REQUESTS];\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results[NUM_REQUESTS];\\\\\\\\n    struct aws_http_message *messages[NUM_REQUESTS];\\\\\\\\n    struct aws_input_stream *input_streams[NUM_REQUESTS];\\\\\\\\n    struct aws_byte_buf input_stream_buffers[NUM_REQUESTS];\\\\\\\\n    struct aws_string *filepath_str[NUM_REQUESTS];\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    size_t content_length = MB_TO_BYTES(10);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results[i], allocator);\\\\\\\\n        char object_path_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n        snprintf(\\\\\\\\n            object_path_buffer,\\\\\\\\n            sizeof(object_path_buffer),\\\\\\\\n            \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-10MB-%zu.txt\\\\\\\\\\\\\",\\\\\\\\n            AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n            i);\\\\\\\\n        AWS_ZERO_STRUCT(input_stream_buffers[i]);\\\\\\\\n        aws_s3_create_test_buffer(allocator, content_length, &input_stream_buffers[i]);\\\\\\\\n        struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&input_stream_buffers[i]);\\\\\\\\n        input_streams[i] = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n        struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(object_path_buffer);\\\\\\\\n        struct aws_byte_cursor host_cur = aws_byte_cursor_from_string(host_name);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT;\\\\\\\\n        if (file_on_disk) {\\\\\\\\n            filepath_str[i] = aws_s3_tester_create_file(allocator, test_object_path, input_streams[i]);\\\\\\\\n            messages[i] = aws_s3_test_put_object_request_new_without_body(\\\\\\\\n                allocator, &host_cur, g_test_body_content_type, test_object_path, content_length, 0 /*flags*/);\\\\\\\\n            options.send_filepath = aws_byte_cursor_from_string(filepath_str[i]);\\\\\\\\n        } else {\\\\\\\\n            filepath_str[i] = NULL;\\\\\\\\n            messages[i] = aws_s3_test_put_object_request_new(\\\\\\\\n                allocator, &host_cur, test_object_path, g_test_body_content_type, input_streams[i], 0);\\\\\\\\n        }\\\\\\\\n        options.message = messages[i];\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results[i]));\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Put Object request. */\\\\\\\\n        meta_requests[i] = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_requests[i] != NULL);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        meta_requests[i] = aws_s3_meta_request_release(meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_s3_tester_validate_get_object_results(&meta_request_test_results[i], 0);\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_http_message_release(messages[i]);\\\\\\\\n        aws_input_stream_release(input_streams[i]);\\\\\\\\n        aws_byte_buf_clean_up(&input_stream_buffers[i]);\\\\\\\\n        if (filepath_str[i]) {\\\\\\\\n            ASSERT_SUCCESS(aws_file_delete(filepath_str[i]));\\\\\\\\n            aws_string_destroy(filepath_str[i]);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multiple, s_test_s3_put_object_multiple)\\\\\\\\nstatic int s_test_s3_put_object_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_put_object_multiple_helper(allocator, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multiple_with_filepath, s_test_s3_put_object_multiple_with_filepath)\\\\\\\\nstatic int s_test_s3_put_object_multiple_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_put_object_multiple_helper(allocator, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_less_than_part_size, s_test_s3_put_object_less_than_part_size)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_buffer_pool_trim, s_test_s3_put_object_buffer_pool_trim)\\\\\\\\nstatic int s_test_s3_put_object_buffer_pool_trim(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 8 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 32,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    struct aws_s3_buffer_pool_usage_stats usage_before = aws_s3_buffer_pool_get_usage(client->buffer_pool);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(0 != usage_before.primary_num_blocks);\\\\\\\\n\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(6, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    struct aws_s3_buffer_pool_usage_stats usage_after = aws_s3_buffer_pool_get_usage(client->buffer_pool);\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(0, usage_after.primary_num_blocks);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_less_than_part_size_with_content_encoding,\\\\\\\\n    s_test_s3_put_object_less_than_part_size_with_content_encoding)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size_with_content_encoding(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor content_encoding_cursor = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"gzip\\\\\\\\\\\\\");\\\\\\\\n    uint32_t object_size_mb = 1;\\\\\\\\n    char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n    snprintf(\\\\\\\\n        object_path_sprintf_buffer,\\\\\\\\n        sizeof(object_path_sprintf_buffer),\\\\\\\\n        \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-content-encoding-%uMB.txt\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n        object_size_mb);\\\\\\\\n    struct aws_byte_cursor object_path_cursor = aws_byte_cursor_from_c_str(object_path_sprintf_buffer);\\\\\\\\n\\\\\\\\n    /*** put file with encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_SHA256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path_cursor,\\\\\\\\n                .content_encoding = content_encoding_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** get file and validate encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results get_object_result;\\\\\\\\n    aws_s3_meta_request_test_results_init(&get_object_result, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &get_object_result));\\\\\\\\n    struct aws_byte_cursor content_encoding_header_cursor;\\\\\\\\n    ASSERT_SUCCESS(aws_http_headers_get(\\\\\\\\n        get_object_result.response_headers, g_content_encoding_header_name, &content_encoding_header_cursor));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq(&content_encoding_cursor, &content_encoding_header_cursor));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&get_object_result);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_mpu_with_content_encoding, s_test_s3_put_object_mpu_with_content_encoding)\\\\\\\\nstatic int s_test_s3_put_object_mpu_with_content_encoding(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor content_encoding_cursor = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"gzip\\\\\\\\\\\\\");\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n    char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n    snprintf(\\\\\\\\n        object_path_sprintf_buffer,\\\\\\\\n        sizeof(object_path_sprintf_buffer),\\\\\\\\n        \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-content-encoding-%uMB.txt\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n        object_size_mb);\\\\\\\\n    struct aws_byte_cursor object_path_cursor = aws_byte_cursor_from_c_str(object_path_sprintf_buffer);\\\\\\\\n\\\\\\\\n    /*** put file with encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_SHA256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path_cursor,\\\\\\\\n                .content_encoding = content_encoding_cursor,\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** get file and validate encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results get_object_result;\\\\\\\\n    aws_s3_meta_request_test_results_init(&get_object_result, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &get_object_result));\\\\\\\\n    struct aws_byte_cursor content_encoding_header_cursor;\\\\\\\\n    ASSERT_SUCCESS(aws_http_headers_get(\\\\\\\\n        get_object_result.response_headers, g_content_encoding_header_name, &content_encoding_header_cursor));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq(&content_encoding_cursor, &content_encoding_header_cursor));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&get_object_result);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multipart_threshold, s_test_s3_put_object_multipart_threshold)\\\\\\\\nstatic int s_test_s3_put_object_multipart_threshold(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n        .multipart_upload_threshold = MB_TO_BYTES(15),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    /* First smaller than the part size */\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 5,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a single part upload, and have 0 as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(0, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    /* Second smaller than threshold and larger than part size */\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    put_options.put_options.object_size_mb = 10;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a single part upload, and have 0 as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(0, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    /* Third larger than threshold*/\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    put_options.put_options.object_size_mb = 20;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in multi-part upload, and have the real part size */\\\\\\\\n    ASSERT_UINT_EQUALS(client_config.part_size, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_threshold_less_than_part_size,\\\\\\\\n    s_test_s3_put_object_multipart_threshold_less_than_part_size)\\\\\\\\nstatic int s_test_s3_put_object_multipart_threshold_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n        .multipart_upload_threshold = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    /* First smaller than the part size */\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 6,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a one part of multipart upload, and have the content length as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(put_options.put_options.object_size_mb), meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_empty_object, s_test_s3_put_object_empty_object)\\\\\\\\nstatic int s_test_s3_put_object_empty_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 0,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s3_no_content_length_test_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    uint32_t object_size_in_mb,\\\\\\\\n    bool use_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = use_checksum ? AWS_SCA_CRC32 : AWS_SCA_NONE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_in_mb,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_no_content_length, s_test_s3_put_object_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 19, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_single_part_no_content_length, s_test_s3_put_object_single_part_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_single_part_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 5, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_zero_size_no_content_length, s_test_s3_put_object_zero_size_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_zero_size_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 0, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_large_object_no_content_length_with_checksum,\\\\\\\\n    s_test_s3_put_large_object_no_content_length_with_checksum)\\\\\\\\nstatic int s_test_s3_put_large_object_no_content_length_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 128, true));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Once upon a time, we have a bug that without content-length, we will schedule more requests to prepare than needed.\\\\\\\\n * And those extra request will be cleaned up, however, the client level count of `num_requests_being_prepared` will\\\\\\\\n * still keep record for those.\\\\\\\\n *\\\\\\\\n * To reproduce, we create bunch of requests with less than a part body. And then sleep for a while to let dns resolve\\\\\\\\n * purge all records. (Otherwise, we will always have one valid request to be available to send.) to trigger not going\\\\\\\\n * full speed code. And we will hang.\\\\\\\\n *\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_no_content_length_multiple, s_test_s3_put_object_no_content_length_multiple)\\\\\\\\nstatic int s_test_s3_put_object_no_content_length_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    aws_s3_set_dns_ttl(55);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    for (int i = 0; i < 6; i++) {\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    }\\\\\\\\n    /* Sleep more than the DNS ttl to purge all records. */\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(60, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    /* After sleep for a while, make another meta request */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream when we\\'re not doing multipart upload */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_singlepart, s_test_s3_put_object_async_singlepart)\\\\\\\\nstatic int s_test_s3_put_object_async_singlepart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 4,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream in multipart upload */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_multipart, s_test_s3_put_object_async_multipart)\\\\\\\\nstatic int s_test_s3_put_object_async_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 16,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, but the aws_async_input_stream_read() calls all complete synchronously */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_read_completes_synchronously,\\\\\\\\n    s_test_s3_put_object_async_read_completes_synchronously)\\\\\\\\nstatic int s_test_s3_put_object_async_read_completes_synchronously(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .async_read_strategy = AWS_ASYNC_READ_COMPLETES_IMMEDIATELY,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, where it takes multiple read() calls to fill each part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_small_reads, s_test_s3_put_object_async_small_reads)\\\\\\\\nstatic int s_test_s3_put_object_async_small_reads(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .max_bytes_per_read = KB_TO_BYTES(1001), /* something that doesn\\'t evenly divide into 8MB parts */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test synchronous input-stream, where it takes multiple read() calls to fill each part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_small_reads, s_test_s3_put_object_small_reads)\\\\\\\\nstatic int s_test_s3_put_object_small_reads(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .max_bytes_per_read = KB_TO_BYTES(1001), /* something that doesn\\'t evenly divide into 8MB parts */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that doesn\\'t end exactly on a part boundary */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_no_content_length_partial_part,\\\\\\\\n    s_test_s3_put_object_async_no_content_length_partial_part)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_partial_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 3,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that fills exactly 1 part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_no_content_length_1part, s_test_s3_put_object_async_no_content_length_1part)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_1part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 8,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that doesn\\'t realize\\\\\\\\n * it\\'s at EOF until it tries to read the 2nd part and gets 0 bytes */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_no_content_length_empty_part2,\\\\\\\\n    s_test_s3_put_object_async_no_content_length_empty_part2)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_empty_part2(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 8,             /* read 1 part\\'s worth of data */\\\\\\\\n                .eof_requires_extra_read = true, /* don\\'t report EOF until it tries to read 2nd part */\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that fills multiple parts */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_no_content_length_2parts, s_test_s3_put_object_async_no_content_length_2parts)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_2parts(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 16,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_fail_reading, s_test_s3_put_object_async_fail_reading)\\\\\\\\nstatic int s_test_s3_put_object_async_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(AWS_IO_STREAM_READ_FAILED, test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_validate_if_none_match_failure_response(struct aws_s3_meta_request_test_results *test_results) {\\\\\\\\n\\\\\\\\n    /**\\\\\\\\n     * response body should be like:\\\\\\\\n     * <Error>\\\\\\\\n     * <Code>PreconditionFailed</Code>\\\\\\\\n     * <Message>At least one of the pre-conditions you specified did not hold</Message>\\\\\\\\n     * <Condition>If-None-Match</Condition>\\\\\\\\n     * <RequestId></RequestId>\\\\\\\\n     * <HostId></HostId>\\\\\\\\n     * </Error>\\\\\\\\n     */\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor xml_doc = aws_byte_cursor_from_buf(&test_results->error_response_body);\\\\\\\\n    struct aws_byte_cursor error_code_string = {0};\\\\\\\\n    struct aws_byte_cursor condition_string = {0};\\\\\\\\n\\\\\\\\n    const char *error_code_path[] = {\\\\\\\\\\\\\"Error\\\\\\\\\\\\\", \\\\\\\\\\\\\"Code\\\\\\\\\\\\\", NULL};\\\\\\\\n    ASSERT_SUCCESS(aws_xml_get_body_at_path(test_results->allocator, xml_doc, error_code_path, &error_code_string));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq_c_str(&error_code_string, \\\\\\\\\\\\\"PreconditionFailed\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    const char *condition_path[] = {\\\\\\\\\\\\\"Error\\\\\\\\\\\\\", \\\\\\\\\\\\\"Condition\\\\\\\\\\\\\", NULL};\\\\\\\\n    ASSERT_SUCCESS(aws_xml_get_body_at_path(test_results->allocator, xml_doc, condition_path, &condition_string));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq_c_str(&condition_string, \\\\\\\\\\\\\"If-None-Match\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_if_none_match, s_test_s3_put_object_if_none_match)\\\\\\\\nstatic int s_test_s3_put_object_if_none_match(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n    struct aws_byte_cursor if_none_match_all = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Use pre_exist object so that the request should fail with the expected failure message. */\\\\\\\\n                .object_path_override = g_pre_existing_object_1MB,\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .if_none_match_header = if_none_match_all,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_HTTP_STATUS_CODE_412_PRECONDITION_FAILED, test_results.finished_response_status);\\\\\\\\n    ASSERT_SUCCESS(s_test_validate_if_none_match_failure_response(&test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_mpu_if_none_match, s_test_s3_put_object_mpu_if_none_match)\\\\\\\\nstatic int s_test_s3_put_object_mpu_if_none_match(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n    struct aws_byte_cursor if_none_match_all = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Use pre_exist object so that the request should fail with the expected failure message. */\\\\\\\\n                .object_path_override = g_pre_existing_object_10MB,\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .if_none_match_header = if_none_match_all,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /** Complete MPU can fail with 200 error */\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        AWS_HTTP_STATUS_CODE_412_PRECONDITION_FAILED == test_results.finished_response_status ||\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK == test_results.finished_response_status);\\\\\\\\n    ASSERT_SUCCESS(s_test_validate_if_none_match_failure_response(&test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_kms, s_test_s3_put_object_sse_kms)\\\\\\\\nstatic int s_test_s3_put_object_sse_kms(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_kms_multipart, s_test_s3_put_object_sse_kms_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_kms_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_aes256, s_test_s3_put_object_sse_aes256)\\\\\\\\nstatic int s_test_s3_put_object_sse_aes256(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_aes256_multipart, s_test_s3_put_object_sse_aes256_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_aes256_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_c_aes256_multipart, s_test_s3_put_object_sse_c_aes256_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_c_aes256_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    (void)allocator;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        tester.allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_sse_c.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_C_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_sse_c_aes256_multipart_with_checksum,\\\\\\\\n    s_test_s3_put_object_sse_c_aes256_multipart_with_checksum)\\\\\\\\nstatic int s_test_s3_put_object_sse_c_aes256_multipart_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        tester.allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_sse_c_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_C_AES256,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_content_md5_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    bool multipart_upload,\\\\\\\\n    uint32_t flags,\\\\\\\\n    enum aws_s3_meta_request_compute_content_md5 compute_content_md5) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    size_t part_size = 5 * 1024 * 1024;\\\\\\\\n    if (!multipart_upload) {\\\\\\\\n        /* content_length < part_size */\\\\\\\\n        part_size = 15 * 1024 * 1024;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = part_size,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    client_config.compute_content_md5 = compute_content_md5;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_put_object_meta_request(&tester, client, 10, flags, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_no_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_no_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_no_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_no_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_no_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_no_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_correct_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_correct_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_correct_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_correct_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_correct_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_correct_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_incorrect_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_incorrect_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_incorrect_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_incorrect_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_incorrect_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_incorrect_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_no_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_no_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_no_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_no_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_no_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_no_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_correct_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_correct_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_correct_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_correct_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_correct_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_correct_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_incorrect_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_incorrect_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_incorrect_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_incorrect_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_incorrect_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_incorrect_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_upload_part_message_helper(struct aws_allocator *allocator, bool should_compute_content_md5) {\\\\\\\\n\\\\\\\\n    aws_s3_library_init(allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n    /* base64 encoded md5 of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */\\\\\\\\n    struct aws_byte_cursor expected_content_md5 = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"+y3U+EY5uFXhVVmRoiJWyA==\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    uint32_t part_number = 1;\\\\\\\\n    struct aws_string *upload_id = aws_string_new_from_c_str(allocator, \\\\\\\\\\\\\"dummy_upload_id\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message = aws_s3_upload_part_message_new(\\\\\\\\n        allocator, base_message, &test_buffer, part_number, upload_id, should_compute_content_md5, NULL, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    if (should_compute_content_md5) {\\\\\\\\n        ASSERT_TRUE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n        struct aws_byte_cursor content_md5;\\\\\\\\n        aws_http_headers_get(new_headers, g_content_md5_header_name, &content_md5);\\\\\\\\n        ASSERT_BIN_ARRAYS_EQUALS(expected_content_md5.ptr, expected_content_md5.len, content_md5.ptr, content_md5.len);\\\\\\\\n    } else {\\\\\\\\n        ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(upload_id);\\\\\\\\n    upload_id = NULL;\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    aws_s3_library_clean_up();\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_part_message_with_content_md5, s_test_s3_upload_part_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_upload_part_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_upload_part_message_helper(allocator, true));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_part_message_without_content_md5, s_test_s3_upload_part_message_without_content_md5)\\\\\\\\nstatic int s_test_s3_upload_part_message_without_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_upload_part_message_helper(allocator, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_create_multipart_upload_message_with_content_md5,\\\\\\\\n    s_test_s3_create_multipart_upload_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_create_multipart_upload_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_md5_header = {\\\\\\\\n        .name = g_content_md5_header_name,\\\\\\\\n        .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_content_md5\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_http_message_add_header(base_message, content_md5_header));\\\\\\\\n\\\\\\\\n    struct aws_http_headers *base_headers = aws_http_message_get_headers(base_message);\\\\\\\\n    ASSERT_TRUE(aws_http_headers_has(base_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message = aws_s3_create_multipart_upload_message_new(allocator, base_message, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_complete_multipart_message_with_content_md5,\\\\\\\\n    s_test_s3_complete_multipart_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_complete_multipart_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_md5_header = {\\\\\\\\n        .name = g_content_md5_header_name,\\\\\\\\n        .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_content_md5\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_http_message_add_header(base_message, content_md5_header));\\\\\\\\n\\\\\\\\n    struct aws_http_headers *base_headers = aws_http_message_get_headers(base_message);\\\\\\\\n    ASSERT_TRUE(aws_http_headers_has(base_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf body_buffer;\\\\\\\\n    aws_byte_buf_init(&body_buffer, allocator, 512);\\\\\\\\n\\\\\\\\n    struct aws_string *upload_id = aws_string_new_from_c_str(allocator, \\\\\\\\\\\\\"dummy_upload_id\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_array_list parts;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_init_dynamic(&parts, allocator, 0, sizeof(struct aws_s3_mpu_part_info *)));\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message =\\\\\\\\n        aws_s3_complete_multipart_message_new(allocator, base_message, &body_buffer, upload_id, &parts, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_array_list_clean_up(&parts);\\\\\\\\n\\\\\\\\n    aws_string_destroy(upload_id);\\\\\\\\n    upload_id = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&body_buffer);\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_double_slashes, s_test_s3_put_object_double_slashes)\\\\\\\\nstatic int s_test_s3_put_object_double_slashes(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix//test.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip, s_test_s3_round_trip)\\\\\\\\nstatic int s_test_s3_round_trip(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get, s_test_s3_round_trip_default_get)\\\\\\\\nstatic int s_test_s3_round_trip_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_default.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_validate_headers_checksum_set(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)headers;\\\\\\\\n    struct aws_s3_meta_request_test_results *meta_request_test_results =\\\\\\\\n        (struct aws_s3_meta_request_test_results *)user_data;\\\\\\\\n    ASSERT_NOT_NULL(meta_request->meta_request_level_running_response_sum);\\\\\\\\n    ASSERT_INT_EQUALS(\\\\\\\\n        meta_request->meta_request_level_running_response_sum->algorithm, meta_request_test_results->algorithm);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_validate_headers_checksum_unset(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)user_data;\\\\\\\\n    ASSERT_NULL(meta_request->meta_request_level_running_response_sum);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nvoid s_s3_test_validate_checksum(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *result,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    struct aws_s3_meta_request_test_results *meta_request_test_results =\\\\\\\\n        (struct aws_s3_meta_request_test_results *)user_data;\\\\\\\\n    AWS_FATAL_ASSERT(result->did_validate);\\\\\\\\n    AWS_FATAL_ASSERT(result->validation_algorithm == meta_request_test_results->algorithm);\\\\\\\\n    AWS_FATAL_ASSERT(result->error_code == AWS_OP_SUCCESS);\\\\\\\\n}\\\\\\\\nvoid s_s3_test_no_validate_checksum(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *result,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)user_data;\\\\\\\\n    AWS_FATAL_ASSERT(!result->did_validate);\\\\\\\\n    AWS_FATAL_ASSERT(result->error_code == AWS_OP_SUCCESS);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* TODO: maybe refactor the fc -> flexible checksum tests to be less copy/paste */\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header,\\\\\\\\n    uint32_t object_size_mb,\\\\\\\\n    enum aws_s3_tester_full_object_checksum full_object_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_ARRAY_SIZE(s_checksum_algo_priority_list); i++) {\\\\\\\\n        enum aws_s3_checksum_algorithm algorithm = s_checksum_algo_priority_list[i];\\\\\\\\n        char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n        snprintf(\\\\\\\\n            object_path_sprintf_buffer,\\\\\\\\n            sizeof(object_path_sprintf_buffer),\\\\\\\\n            \\\\\\\\\\\\\"/prefix/round_trip/test_default_fc_%d_%d.txt\\\\\\\\\\\\\",\\\\\\\\n            algorithm,\\\\\\\\n            object_size_mb);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n            allocator, &path_buf, aws_byte_cursor_from_c_str(object_path_sprintf_buffer)));\\\\\\\\n        struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n        /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n        struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n            .client = client,\\\\\\\\n            .checksum_algorithm = algorithm,\\\\\\\\n            .validate_get_response_checksum = false,\\\\\\\\n            .checksum_via_header = via_header,\\\\\\\\n            .put_options =\\\\\\\\n                {\\\\\\\\n                    .object_size_mb = object_size_mb,\\\\\\\\n                    .object_path_override = object_path,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n        if (algorithm != AWS_SCA_SHA1 && algorithm != AWS_SCA_SHA256) {\\\\\\\\n            /* Full object checksums doesn\\'t support SHA. */\\\\\\\\n            put_options.put_options.full_object_checksum = full_object_checksum;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n        /*** GET FILE ***/\\\\\\\\n\\\\\\\\n        struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .client = client,\\\\\\\\n            .expected_validate_checksum_alg = algorithm,\\\\\\\\n            .validate_get_response_checksum = true,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = object_path,\\\\\\\\n                },\\\\\\\\n            .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n            .headers_callback = s_s3_validate_headers_checksum_set,\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n        aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get_fc, s_test_s3_round_trip_default_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 1 /*object_size_mb*/, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_empty_fc, s_test_s3_round_trip_empty_fc)\\\\\\\\nstatic int s_test_s3_round_trip_empty_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 0, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get_fc_header, s_test_s3_round_trip_default_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, true, 1, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_default_get_full_object_checksum_fc,\\\\\\\\n    s_test_s3_round_trip_default_get_full_object_checksum_fc)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_full_object_checksum_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 1, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc_helper(struct aws_allocator *allocator, void *ctx, bool via_header) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC64NVME,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC64NVME,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .headers_callback = s_s3_validate_headers_checksum_set,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_multipart_get_fc, s_test_s3_round_trip_multipart_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_multipart_get_fc_helper(allocator, ctx, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_multipart_get_fc_header, s_test_s3_round_trip_multipart_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_multipart_get_fc_helper(allocator, ctx, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test the multipart uploaded object was downloaded with same part size, which will download the object matches all the\\\\\\\\n * parts and validate the parts checksum. */\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header,\\\\\\\\n    enum aws_s3_tester_full_object_checksum full_object_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n    struct aws_byte_cursor object_name;\\\\\\\\n    /* Use different name to avoid collision when tests run concurrently. */\\\\\\\\n    switch (full_object_checksum) {\\\\\\\\n        case AWS_TEST_FOC_CALLBACK:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc_full_object_via_callback.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n        case AWS_TEST_FOC_HEADER:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc_full_object_via_header.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(allocator, &path_buf, object_name));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .full_object_checksum = full_object_checksum,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_multipart_get_fc, s_test_s3_round_trip_mpu_multipart_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_multipart_get_fc_header, s_test_s3_round_trip_mpu_multipart_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, true, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, true, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_CALLBACK);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/empty-file-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 0,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE WITH GET_FIRST_PART ***/\\\\\\\\n    uint64_t small_object_size_hint = 1;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .object_size_hint =\\\\\\\\n            &small_object_size_hint /* pass a object_size_hint > 0 so that the request goes through the getPart flow */,\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE WITH HEAD_OBJECT ***/\\\\\\\\n    get_options.object_size_hint = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_empty_file_with_checksum, s_test_s3_download_empty_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_download_empty_file_with_checksum_helper(allocator, ctx, false);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(test_s3_download_empty_file_with_checksum_header, s_test_s3_download_empty_file_with_checksum_header)\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_download_empty_file_with_checksum_helper(allocator, ctx, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_single_part_file_with_checksum, s_test_s3_download_single_part_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_single_part_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(10),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/single-part-10Mb-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    uint64_t object_size_hint = MB_TO_BYTES(object_size_mb);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .object_size_hint = &object_size_hint,\\\\\\\\n    };\\\\\\\\n    uint64_t small_object_size_hint = MB_TO_BYTES(1);\\\\\\\\n\\\\\\\\n    /* will do headRequest */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(20);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n\\\\\\\\n    /* will do getPart */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /* will do getPart */\\\\\\\\n    /*** GET FILE with part_size = file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(10);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < file_size and wrong object_size_hint ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.object_size_hint = &small_object_size_hint;\\\\\\\\n    /* will do getPart first, cancel it and then rangedGet */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_multipart_file_with_checksum, s_test_s3_download_multipart_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_multipart_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/multipart-10Mb-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    uint64_t object_size_hint = MB_TO_BYTES(object_size_mb);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .object_size_hint = &object_size_hint,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* will do HeadRequest first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(7);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    /* will do HeadObject first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size = first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(5);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    /* will do HeadObject First */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    uint64_t small_object_size_hint = 1;\\\\\\\\n\\\\\\\\n    /*** GET FILE with with wrong object_size_hint ***/\\\\\\\\n    get_options.object_size_hint = &small_object_size_hint;\\\\\\\\n    get_options.finish_callback = NULL;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < first_part_size***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n\\\\\\\\n    /* will do GetPart, cancel the request and then do ranged Gets. */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(7);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n\\\\\\\\n    /* will do GetPart first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size = first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(5);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    /* will do GetPart first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > fileSize ***/\\\\\\\\n    /* TODO: Enable this test once the checksum issue is resolved. Currently, when the S3 GetObject API is called with\\\\\\\\n     * the range 0-contentLength, it returns a checksum of checksums without the -numParts portion. This leads to a\\\\\\\\n     * checksum mismatch error, as it is incorrectly validated as a part checksum. */\\\\\\\\n    /*\\\\\\\\n    client_options.part_size = MB_TO_BYTES(20);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n    */\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_array_list response_checksum_list;\\\\\\\\n    /* Check for all algorithm but the CRC32 */\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_array_list_init_dynamic(&response_checksum_list, allocator, 4, sizeof(enum aws_s3_checksum_algorithm)));\\\\\\\\n    enum aws_s3_checksum_algorithm alg = AWS_SCA_CRC32C;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    alg = AWS_SCA_SHA1;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    alg = AWS_SCA_SHA256;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .validate_checksum_algorithms = &response_checksum_list,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_no_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    /* Push all the algorithms to the list for validation, now we should have the checksum validated. */\\\\\\\\n    alg = AWS_SCA_CRC32;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_array_list_clean_up(&response_checksum_list);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_default_get_fc, s_test_s3_round_trip_mpu_default_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_default_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_default_get_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_no_validate_checksum,\\\\\\\\n        .headers_callback = s_s3_validate_headers_checksum_unset,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor key,\\\\\\\\n    int object_size_mb,\\\\\\\\n    bool unknown_content_length) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(allocator, &path_buf, key));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .skip_content_length = unknown_content_length,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(\\\\\\\\n        MB_TO_BYTES(put_options.put_options.object_size_mb), test_results.progress.total_bytes_transferred);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_with_filepath, s_test_s3_round_trip_with_filepath)\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath\\\\\\\\\\\\\"), 1, false /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_with_filepath, s_test_s3_round_trip_mpu_with_filepath)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_mpu\\\\\\\\\\\\\"),\\\\\\\\n        50,\\\\\\\\n        false /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_with_filepath_no_content_length, s_test_s3_round_trip_with_filepath_no_content_length)\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_no_content_length\\\\\\\\\\\\\"),\\\\\\\\n        1,\\\\\\\\n        true /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_with_filepath_no_content_length,\\\\\\\\n    s_test_s3_round_trip_mpu_with_filepath_no_content_length)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_with_filepath_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_mpu_no_content_length\\\\\\\\\\\\\"),\\\\\\\\n        50,\\\\\\\\n        true /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_chunked_then_unchunked, s_test_s3_chunked_then_unchunked)\\\\\\\\nstatic int s_test_s3_chunked_then_unchunked(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Test to see if signed_body_value modified when signing chunked request */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/chunked_unchunked/test_chunked.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor chunked_object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options chunked_put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = chunked_object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &chunked_put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/chunked_unchunked/test_unchunked.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor unchunked_object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options unchunked_put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_NONE,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = unchunked_object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &unchunked_put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_meta_request_default, s_test_s3_meta_request_default)\\\\\\\\nstatic int s_test_s3_meta_request_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n\\\\\\\\n    /* Pass the request through as a default request so that it goes through as-is. */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    /* Check the size of the metrics should be the same as the number of\\\\\\\\n    requests, which should be 1 */\\\\\\\\n    ASSERT_UINT_EQUALS(1, aws_array_list_length(&meta_request_test_results.synced_data.metrics));\\\\\\\\n    struct aws_s3_request_metrics *metrics = NULL;\\\\\\\\n    aws_array_list_back(&meta_request_test_results.synced_data.metrics, (void **)&metrics);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_error_missing_file, s_test_s3_error_missing_file)\\\\\\\\nstatic int s_test_s3_error_missing_file(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor test_object_path =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/non-existing-file12345.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message =\\\\\\\\n        aws_s3_test_get_object_request_new(allocator, aws_byte_cursor_from_string(host_name), test_object_path);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_response_status == 404);\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.error_response_headers != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_NOT_NULL(meta_request_test_results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(meta_request_test_results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(meta_request_test_results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_test_s3_existing_host_entry_address_resolved_callback(\\\\\\\\n    struct aws_host_resolver *resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    int err_code,\\\\\\\\n    const struct aws_array_list *host_addresses,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)err_code;\\\\\\\\n    (void)host_addresses;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = user_data;\\\\\\\\n    AWS_ASSERT(tester);\\\\\\\\n    aws_s3_tester_notify_signal(tester);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_existing_host_entry, s_test_s3_existing_host_entry)\\\\\\\\nstatic int s_test_s3_existing_host_entry(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_host_resolution_config host_resolver_config;\\\\\\\\n        AWS_ZERO_STRUCT(host_resolver_config);\\\\\\\\n        host_resolver_config.impl = aws_default_dns_resolve;\\\\\\\\n        host_resolver_config.max_ttl = 30;\\\\\\\\n        host_resolver_config.impl_data = NULL;\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_host_resolver_resolve_host(\\\\\\\\n            client_config.client_bootstrap->host_resolver,\\\\\\\\n            host_name,\\\\\\\\n            s_test_s3_existing_host_entry_address_resolved_callback,\\\\\\\\n            &host_resolver_config,\\\\\\\\n            &tester));\\\\\\\\n\\\\\\\\n        aws_s3_tester_wait_for_signal(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_bad_endpoint, s_test_s3_bad_endpoint)\\\\\\\\nstatic int s_test_s3_bad_endpoint(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"test_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    AWS_STATIC_STRING_FROM_LITERAL(invalid_host_name, \\\\\\\\\\\\\"invalid_host_name_totally_absolutely\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Construct a message that points to an invalid host name. Key can be anything. */\\\\\\\\n    struct aws_http_message *message =\\\\\\\\n        aws_s3_test_get_object_request_new(allocator, aws_byte_cursor_from_string(invalid_host_name), test_key);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(&tester, client, &options, &meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        meta_request_test_results.finished_error_code == AWS_IO_DNS_INVALID_NAME ||\\\\\\\\n        meta_request_test_results.finished_error_code == AWS_IO_DNS_QUERY_FAILED);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_raise_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_body_callback_raise_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)body;\\\\\\\\n    (void)range_start;\\\\\\\\n    (void)user_data;\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_fail_headers_callback, s_test_s3_put_object_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_put_object_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_fail_body_callback, s_test_s3_put_object_fail_body_callback)\\\\\\\\nstatic int s_test_s3_put_object_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n\\\\\\\\n        /* Put object currently never invokes the body callback, which means it should not fail. */\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, NULL));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_fail_headers_callback, s_test_s3_get_object_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_get_object_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_fail_body_callback, s_test_s3_get_object_fail_body_callback)\\\\\\\\nstatic int s_test_s3_get_object_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_headers_callback, s_test_s3_default_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_default_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_atomic_var s_test_headers_callback_invoked;\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_check_returns_success(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    /* increments counter to check if callback was invoked exactly once */\\\\\\\\n    aws_atomic_fetch_add(&s_test_headers_callback_invoked, 1);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_check_returns_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    /* increments counter to check if callback was invoked exactly once */\\\\\\\\n    aws_atomic_fetch_add(&s_test_headers_callback_invoked, 1);\\\\\\\\n\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_invoke_headers_callback_on_error, s_test_s3_default_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_default_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_default_invoke_headers_callback_cancels_on_error,\\\\\\\\n    s_test_s3_default_invoke_headers_callback_cancels_on_error)\\\\\\\\nstatic int s_test_s3_default_invoke_headers_callback_cancels_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_invoke_headers_callback_on_error,\\\\\\\\n    s_test_s3_get_object_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_get_object_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_invoke_headers_callback_on_error,\\\\\\\\n    s_test_s3_put_object_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_put_object_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .invalid_request = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INVALID_RESPONSE_STATUS, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation,\\\\\\\\n    s_test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation)\\\\\\\\nstatic int s_test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_UNKNOWN, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_body_callback, s_test_s3_default_fail_body_callback)\\\\\\\\nstatic int s_test_s3_default_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that if a DEFAULt meta-request sets the operation_name, and gets an error response,\\\\\\\\n * then aws_s3_meta_request_result.error_response_operation_name is set. */\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_operation_name, s_test_s3_default_fail_operation_name)\\\\\\\\nstatic int s_test_s3_default_fail_operation_name(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\", aws_string_c_str(meta_request_test_results.error_response_operation_name));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_invalid_request, s_test_s3_put_fail_object_invalid_request)\\\\\\\\nstatic int s_test_s3_put_fail_object_invalid_request(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .invalid_request = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INVALID_RESPONSE_STATUS, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    /* Since 1MB is under part_size, there will be a single PutObject request */\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"PutObject\\\\\\\\\\\\\", aws_string_c_str(meta_request_test_results.error_response_operation_name));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that we fail to create a metarequest when an invalid `send_filepath` is passed in */\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_invalid_send_filepath, s_test_s3_put_fail_object_invalid_send_filepath)\\\\\\\\nstatic int s_test_s3_put_fail_object_invalid_send_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor object_key = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = aws_s3_test_put_object_request_new_without_body(\\\\\\\\n        allocator, &host_name, g_test_body_content_type, object_key, 1024 /*content_length*/, 0 /*flags*/);\\\\\\\\n    ASSERT_NOT_NULL(message);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options meta_request_options = {\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .message = message,\\\\\\\\n        .send_filepath = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"obviously_invalid_file_path\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &meta_request_options);\\\\\\\\n    ASSERT_NULL(meta_request);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_ERROR_FILE_INVALID_PATH, aws_last_error());\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the parallel read stream failed to send read the second part. */\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_bad_parallel_read_stream, s_test_s3_put_fail_object_bad_parallel_read_stream)\\\\\\\\nstatic int s_test_s3_put_fail_object_bad_parallel_read_stream(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    /* Override the parallel input stream new function to create a bad parallel input stream */\\\\\\\\n    client->vtable->parallel_input_stream_new_from_file = aws_parallel_input_stream_new_from_file_failure_tester;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 100,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_UNIMPLEMENTED, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_single_part_fail_object_inputstream_fail_reading,\\\\\\\\n    s_test_s3_put_single_part_fail_object_inputstream_fail_reading)\\\\\\\\nstatic int s_test_s3_put_single_part_fail_object_inputstream_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n                .content_length = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_single_part_fail_object_inputstream_mismatch_content_length,\\\\\\\\n    s_test_s3_put_single_part_fail_object_inputstream_mismatch_content_length)\\\\\\\\nstatic int s_test_s3_put_single_part_fail_object_inputstream_mismatch_content_length(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .content_length = MB_TO_BYTES(2),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_inputstream_fail_reading, s_test_s3_put_fail_object_inputstream_fail_reading)\\\\\\\\nstatic int s_test_s3_put_fail_object_inputstream_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n                .content_length = 10 * 1024 * 1024,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_IO_STREAM_READ_FAILED, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_fail_object_inputstream_mismatch_content_length,\\\\\\\\n    s_test_s3_put_fail_object_inputstream_mismatch_content_length)\\\\\\\\nstatic int s_test_s3_put_fail_object_inputstream_mismatch_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = false,\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .content_length = 10 * 1024 * 1024,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INCORRECT_CONTENT_LENGTH, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_clamp_part_size, s_test_s3_put_object_clamp_part_size)\\\\\\\\nstatic int s_test_s3_put_object_clamp_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n        .max_part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client_config.part_size < g_s3_min_upload_part_size);\\\\\\\\n    ASSERT_TRUE(client_config.max_part_size < g_s3_min_upload_part_size);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    /* Upload should now succeed even when specifying a smaller than allowed part size. */\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(test_results.part_size == g_s3_min_upload_part_size);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_get_expected_user_agent(struct aws_allocator *allocator, struct aws_byte_buf *dest) {\\\\\\\\n    AWS_ASSERT(allocator);\\\\\\\\n    AWS_ASSERT(dest);\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor forward_slash = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/\\\\\\\\\\\\\");\\\\\\\\n    const struct aws_byte_cursor single_space = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\" \\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_init(dest, allocator, 32));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_product_name));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &forward_slash));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_s3_client_version));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &single_space));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_platform));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &forward_slash));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_unknown));\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_add_user_agent_header, s_test_add_user_agent_header)\\\\\\\\nstatic int s_test_add_user_agent_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor single_space = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\" \\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_buf expected_user_agent_value_buf;\\\\\\\\n    s_get_expected_user_agent(allocator, &expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor expected_user_agent_value = aws_byte_cursor_from_buf(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_byte_cursor user_agent_value;\\\\\\\\n        AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n\\\\\\\\n        struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n\\\\\\\\n        aws_s3_add_user_agent_header(allocator, message);\\\\\\\\n\\\\\\\\n        struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(headers != NULL);\\\\\\\\n        ASSERT_SUCCESS(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value));\\\\\\\\n        ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n            user_agent_value.ptr, user_agent_value.len, expected_user_agent_value.ptr, expected_user_agent_value.len);\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        const struct aws_byte_cursor dummy_agent_header_value =\\\\\\\\n            AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_user_agent_product/dummy_user_agent_value\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        struct aws_byte_buf total_expected_user_agent_value_buf;\\\\\\\\n        aws_byte_buf_init(&total_expected_user_agent_value_buf, allocator, 64);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &dummy_agent_header_value);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &single_space);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &expected_user_agent_value);\\\\\\\\n\\\\\\\\n        struct aws_byte_cursor total_expected_user_agent_value =\\\\\\\\n            aws_byte_cursor_from_buf(&total_expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n        struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n        struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n        ASSERT_TRUE(headers != NULL);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_http_headers_add(headers, g_user_agent_header_name, dummy_agent_header_value));\\\\\\\\n\\\\\\\\n        aws_s3_add_user_agent_header(allocator, message);\\\\\\\\n\\\\\\\\n        {\\\\\\\\n            struct aws_byte_cursor user_agent_value;\\\\\\\\n            AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n            ASSERT_SUCCESS(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value));\\\\\\\\n            ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n                user_agent_value.ptr,\\\\\\\\n                user_agent_value.len,\\\\\\\\n                total_expected_user_agent_value.ptr,\\\\\\\\n                total_expected_user_agent_value.len);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_byte_buf_clean_up(&total_expected_user_agent_value_buf);\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&expected_user_agent_value_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_user_agent_meta_request_finished_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *results = meta_request->user_data;\\\\\\\\n    AWS_ASSERT(results != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = results->tester;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf expected_user_agent_value_buf;\\\\\\\\n    s_get_expected_user_agent(meta_request->allocator, &expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor expected_user_agent_value = aws_byte_cursor_from_buf(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = request->send_data.message;\\\\\\\\n    struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor user_agent_value;\\\\\\\\n    AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n\\\\\\\\n    AWS_FATAL_ASSERT(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value) == AWS_OP_SUCCESS);\\\\\\\\n    AWS_FATAL_ASSERT(aws_byte_cursor_eq(&user_agent_value, &expected_user_agent_value));\\\\\\\\n    aws_byte_buf_clean_up(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *original_meta_request_vtable =\\\\\\\\n        aws_s3_tester_get_meta_request_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    original_meta_request_vtable->finished_request(meta_request, request, error_code);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_s3_meta_request *s_s3_meta_request_factory_override_finished_request(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    const struct aws_s3_meta_request_options *options) {\\\\\\\\n    AWS_ASSERT(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = client->shutdown_callback_user_data;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *original_client_vtable =\\\\\\\\n        aws_s3_tester_get_client_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = original_client_vtable->meta_request_factory(client, options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *patched_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(tester, meta_request, NULL);\\\\\\\\n    patched_meta_request_vtable->finished_request = s_s3_test_user_agent_meta_request_finished_request;\\\\\\\\n\\\\\\\\n    return meta_request;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_test_sending_user_agent_create_client(struct aws_s3_tester *tester, struct aws_s3_client **client) {\\\\\\\\n    AWS_ASSERT(tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(tester, &client_options, client));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(tester, *client, NULL);\\\\\\\\n    patched_client_vtable->meta_request_factory = s_s3_meta_request_factory_override_finished_request;\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_auto_ranged_get_sending_user_agent, s_test_s3_auto_ranged_get_sending_user_agent)\\\\\\\\nstatic int s_test_s3_auto_ranged_get_sending_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = g_pre_existing_object_1MB,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_auto_ranged_put_sending_user_agent, s_test_s3_auto_ranged_put_sending_user_agent)\\\\\\\\nstatic int s_test_s3_auto_ranged_put_sending_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .put_options =\\\\\\\\n                {\\\\\\\\n                    .ensure_multipart = true,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_sending_meta_request_user_agent, s_test_s3_default_sending_meta_request_user_agent)\\\\\\\\nstatic int s_test_s3_default_sending_meta_request_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .default_type_options =\\\\\\\\n                {\\\\\\\\n                    .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                    .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n                },\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = g_pre_existing_object_1MB,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct range_requests_test_user_data {\\\\\\\\n    struct aws_http_headers *headers;\\\\\\\\n    struct aws_byte_buf *body_buffer;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic int s_range_requests_headers_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)response_status;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results = user_data;\\\\\\\\n    struct range_requests_test_user_data *test_user_data = test_results->tester->user_data;\\\\\\\\n\\\\\\\\n    if (test_user_data != NULL) {\\\\\\\\n        copy_http_headers(headers, test_user_data->headers);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_range_requests_receive_body_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)range_start;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results = user_data;\\\\\\\\n    struct range_requests_test_user_data *test_user_data = test_results->tester->user_data;\\\\\\\\n\\\\\\\\n    aws_byte_buf_append_dynamic(test_user_data->body_buffer, body);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_range_requests, s_test_s3_range_requests)\\\\\\\\nstatic int s_test_s3_range_requests(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor object_names[] = {\\\\\\\\n        g_pre_existing_object_1MB,\\\\\\\\n        g_pre_existing_object_kms_10MB,\\\\\\\\n        g_pre_existing_object_aes256_10MB,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    enum aws_s3_tester_sse_type object_sse_types[] = {\\\\\\\\n        AWS_S3_TESTER_SSE_NONE,\\\\\\\\n        AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        AWS_S3_TESTER_SSE_AES256,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor ranges[] = {\\\\\\\\n        // No range at all.\\\\\\\\n        {0, NULL},\\\\\\\\n\\\\\\\\n        // Single byte range.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=8-8\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Single byte range (first byte).\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-0\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // First 8K.  8K < client\\'s 16K part size.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-8191\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // First 0.5 MB.  0.5 MB < 1 MB test file.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-524287\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // 0.5 MB - 2 MB range.  This overlaps and goes beyond the 1 MB test file size.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=524288-2097151\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Get everything after the first 0.5 MB\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=524288-\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Last 0.5 MB\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=-524288\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Everything after first 8K\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=8192-\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Last 8K\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=-8192\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* List of headers that should have matching values between the auto_ranged_get and default (which sends the HTTP\\\\\\\\n     * request as-is to S3) meta request.*/\\\\\\\\n    const struct aws_byte_cursor headers_that_should_match[] = {\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"ETag\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Accept-Ranges\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Range\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Type\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Length\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Server\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"x-amz-server-side-encryption\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"x-amz-server-side-encryption-aws-kms-key\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* List of headers that are okay to be in the auto_ranged_get response and not in the default response, or vice\\\\\\\\n     * versa.*/\\\\\\\\n    const struct aws_byte_cursor headers_to_ignore[] = {\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Connection\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    const size_t num_object_names = AWS_ARRAY_SIZE(object_names);\\\\\\\\n    const size_t num_ranges = AWS_ARRAY_SIZE(ranges);\\\\\\\\n\\\\\\\\n    for (size_t object_name_index = 0; object_name_index < num_object_names; ++object_name_index) {\\\\\\\\n        for (size_t range_index = 0; range_index < num_ranges; ++range_index) {\\\\\\\\n\\\\\\\\n            AWS_LOGF_INFO(\\\\\\\\n                AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Testing object name %d and range %d\\\\\\\\\\\\\", (int)object_name_index, (int)range_index);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf range_get_buffer;\\\\\\\\n            aws_byte_buf_init(&range_get_buffer, allocator, 256);\\\\\\\\n            struct aws_http_headers *range_get_headers = aws_http_headers_new(allocator);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf verify_range_get_buffer;\\\\\\\\n            aws_byte_buf_init(&verify_range_get_buffer, allocator, 256);\\\\\\\\n            struct aws_http_headers *verify_range_get_headers = aws_http_headers_new(allocator);\\\\\\\\n\\\\\\\\n            struct aws_s3_tester_meta_request_options options = {\\\\\\\\n                .allocator = allocator,\\\\\\\\n                .client = client,\\\\\\\\n                .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n                .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n                .headers_callback = s_range_requests_headers_callback,\\\\\\\\n                .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n                .get_options =\\\\\\\\n                    {\\\\\\\\n                        .object_path = object_names[object_name_index],\\\\\\\\n                        .object_range = ranges[range_index],\\\\\\\\n                    },\\\\\\\\n                .sse_type = object_sse_types[object_name_index],\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            {\\\\\\\\n                struct range_requests_test_user_data test_user_data = {\\\\\\\\n                    .headers = range_get_headers,\\\\\\\\n                    .body_buffer = &range_get_buffer,\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                tester.user_data = &test_user_data;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            /* Send a default meta request (which just pushes the request directly to S3) with the same options to\\\\\\\\n             * verify the format of each request. */\\\\\\\\n            struct aws_s3_tester_meta_request_options verify_options = {\\\\\\\\n                .allocator = allocator,\\\\\\\\n                .client = client,\\\\\\\\n                .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n                .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n                .headers_callback = s_range_requests_headers_callback,\\\\\\\\n                .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n                .default_type_options =\\\\\\\\n                    {\\\\\\\\n                        .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                        .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n                    },\\\\\\\\n                .get_options =\\\\\\\\n                    {\\\\\\\\n                        .object_path = object_names[object_name_index],\\\\\\\\n                        .object_range = ranges[range_index],\\\\\\\\n                    },\\\\\\\\n                .sse_type = object_sse_types[object_name_index],\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            {\\\\\\\\n                struct range_requests_test_user_data test_user_data = {\\\\\\\\n                    .headers = verify_range_get_headers,\\\\\\\\n                    .body_buffer = &verify_range_get_buffer,\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                tester.user_data = &test_user_data;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &verify_options, NULL));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            /* Compare headers. */\\\\\\\\n            for (size_t i = 0; i < aws_http_headers_count(verify_range_get_headers); ++i) {\\\\\\\\n                struct aws_http_header verify_header;\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get_index(verify_range_get_headers, i, &verify_header));\\\\\\\\n\\\\\\\\n                bool ignore_header = false;\\\\\\\\n\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_to_ignore); ++j) {\\\\\\\\n                    if (aws_byte_cursor_eq_ignore_case(&headers_to_ignore[j], &verify_header.name)) {\\\\\\\\n                        ignore_header = true;\\\\\\\\n                        break;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                if (ignore_header) {\\\\\\\\n                    aws_http_headers_erase(range_get_headers, verify_header.name);\\\\\\\\n                    continue;\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                AWS_LOGF_INFO(\\\\\\\\n                    AWS_LS_S3_GENERAL,\\\\\\\\n                    \\\\\\\\\\\\\"%d,%d Checking for header \\\\\\\\\\\\\" PRInSTR,\\\\\\\\n                    (int)object_name_index,\\\\\\\\n                    (int)range_index,\\\\\\\\n                    AWS_BYTE_CURSOR_PRI(verify_header.name));\\\\\\\\n\\\\\\\\n                struct aws_byte_cursor header_value;\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get(range_get_headers, verify_header.name, &header_value));\\\\\\\\n\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_that_should_match); ++j) {\\\\\\\\n                    if (!aws_byte_cursor_eq_ignore_case(&headers_that_should_match[j], &verify_header.name)) {\\\\\\\\n                        continue;\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    AWS_LOGF_INFO(\\\\\\\\n                        AWS_LS_S3_GENERAL,\\\\\\\\n                        \\\\\\\\\\\\\"%d,%d Header Contents \\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\" vs \\\\\\\\\\\\\" PRInSTR,\\\\\\\\n                        (int)object_name_index,\\\\\\\\n                        (int)range_index,\\\\\\\\n                        AWS_BYTE_CURSOR_PRI(verify_header.value),\\\\\\\\n                        AWS_BYTE_CURSOR_PRI(header_value));\\\\\\\\n\\\\\\\\n                    ASSERT_TRUE(aws_byte_cursor_eq(&verify_header.value, &header_value));\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_erase(range_get_headers, verify_header.name));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            for (size_t i = 0; i < aws_http_headers_count(range_get_headers); ++i) {\\\\\\\\n                struct aws_http_header header;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get_index(range_get_headers, i, &header));\\\\\\\\n                bool ignore_header = false;\\\\\\\\n\\\\\\\\n                /* If the ignore header doesn\\'t exist in the verify_range_get_headers, ignore it here. */\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_to_ignore); ++j) {\\\\\\\\n                    if (aws_byte_cursor_eq_ignore_case(&headers_to_ignore[j], &header.name)) {\\\\\\\\n                        ignore_header = true;\\\\\\\\n                        break;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                if (ignore_header) {\\\\\\\\n                    ASSERT_SUCCESS(aws_http_headers_erase(range_get_headers, header.name));\\\\\\\\n                    continue;\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                AWS_LOGF_INFO(AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Left over header: \\\\\\\\\\\\\" PRInSTR, AWS_BYTE_CURSOR_PRI(header.name));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(aws_http_headers_count(range_get_headers) == 0);\\\\\\\\n\\\\\\\\n            /* Compare Body Contents */\\\\\\\\n            ASSERT_TRUE(aws_byte_buf_eq(&range_get_buffer, &verify_range_get_buffer));\\\\\\\\n\\\\\\\\n            aws_http_headers_release(range_get_headers);\\\\\\\\n            aws_byte_buf_clean_up(&range_get_buffer);\\\\\\\\n\\\\\\\\n            aws_http_headers_release(verify_range_get_headers);\\\\\\\\n            aws_byte_buf_clean_up(&verify_range_get_buffer);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_not_satisfiable_range, s_test_s3_not_satisfiable_range)\\\\\\\\nstatic int s_test_s3_not_satisfiable_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .headers_callback = s_range_requests_headers_callback,\\\\\\\\n        .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=2097151-\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_416_REQUESTED_RANGE_NOT_SATISFIABLE, results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_invalid_start_range_greator_than_end_range, s_test_s3_invalid_start_range_greator_than_end_range)\\\\\\\\nstatic int s_test_s3_invalid_start_range_greator_than_end_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=20-10\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n    ASSERT_INT_EQUALS(results.finished_error_code, AWS_ERROR_S3_INVALID_RANGE_HEADER);\\\\\\\\n    ASSERT_INT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_invalid_empty_file_with_range, s_test_s3_invalid_empty_file_with_range)\\\\\\\\nstatic int s_test_s3_invalid_empty_file_with_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_empty_object,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-0\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_416_REQUESTED_RANGE_NOT_SATISFIABLE, results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_copy_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor source_key,\\\\\\\\n    struct aws_byte_cursor destination_key,\\\\\\\\n    int expected_error_code,\\\\\\\\n    int expected_response_status,\\\\\\\\n    uint64_t expected_size) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    struct aws_byte_buf encoded_path;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n    AWS_ZERO_STRUCT(encoded_path);\\\\\\\\n\\\\\\\\n    aws_byte_buf_init(&encoded_path, allocator, source_key.len);\\\\\\\\n    aws_byte_buf_append_encoding_uri_path(&encoded_path, &source_key);\\\\\\\\n\\\\\\\\n    /* without copy_source_uri */\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    /* with path style copy_source_uri */\\\\\\\\n    char source_url[1024];\\\\\\\\n    snprintf(\\\\\\\\n        source_url,\\\\\\\\n        sizeof(source_url),\\\\\\\\n        \\\\\\\\\\\\\"https://s3.%s.amazonaws.com/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"\\\\\\\\\\\\\",\\\\\\\\n        g_test_s3_region.ptr,\\\\\\\\n        AWS_BYTE_CURSOR_PRI(source_bucket),\\\\\\\\n        AWS_BYTE_BUF_PRI(encoded_path));\\\\\\\\n    copy_source_uri = aws_byte_cursor_from_c_str(source_url);\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    /* with virtual style copy_source_uri */\\\\\\\\n    snprintf(\\\\\\\\n        source_url,\\\\\\\\n        sizeof(source_url),\\\\\\\\n        \\\\\\\\\\\\\"https://\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\".s3.%s.amazonaws.com/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(source_bucket),\\\\\\\\n        g_test_s3_region.ptr,\\\\\\\\n        AWS_BYTE_BUF_PRI(encoded_path));\\\\\\\\n    copy_source_uri = aws_byte_cursor_from_c_str(source_url);\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_byte_buf_clean_up(&encoded_path);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_small_object, s_test_s3_copy_small_object)\\\\\\\\nstatic int s_test_s3_copy_small_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, MB_TO_BYTES(1));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_small_object_special_char, s_test_s3_copy_small_object_special_char)\\\\\\\\nstatic int s_test_s3_copy_small_object_special_char(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB-@\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB_@\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, MB_TO_BYTES(1));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_copy_large_object_special_char, s_test_s3_multipart_copy_large_object_special_char)\\\\\\\\nstatic int s_test_s3_multipart_copy_large_object_special_char(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-2GB-@\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_2GB-@\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, GB_TO_BYTES(2));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_copy_large_object, s_test_s3_multipart_copy_large_object)\\\\\\\\nstatic int s_test_s3_multipart_copy_large_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-2GB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_2GB\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, GB_TO_BYTES(2));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_object_invalid_source_key, s_test_s3_copy_object_invalid_source_key)\\\\\\\\nstatic int s_test_s3_copy_object_invalid_source_key(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"__INVALID__\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/__INVALID__\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        source_key,\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_S3_INVALID_RESPONSE_STATUS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_404_NOT_FOUND,\\\\\\\\n        0 /* expected_size is ignored */);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test a bypass Copy Object meta request using a slash prefix in the x_amz_copy_source header.\\\\\\\\n * S3 supports both bucket/key and /bucket/key\\\\\\\\n * This test validates the fix for the bug described in https://sim.amazon.com/issues/AWSCRT-730\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_copy_source_prefixed_by_slash, s_test_s3_copy_source_prefixed_by_slash)\\\\\\\\nstatic int s_test_s3_copy_source_prefixed_by_slash(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK,\\\\\\\\n        MB_TO_BYTES(1),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_invalid_source_uri, s_test_s3_copy_invalid_source_uri)\\\\\\\\nstatic int s_test_s3_copy_invalid_source_uri(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"http://invalid-uri.com:80:80/path\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_MALFORMED_INPUT_STRING,\\\\\\\\n        0,\\\\\\\\n        MB_TO_BYTES(1),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test multipart Copy Object meta request using a slash prefix in the x_amz_copy_source header.\\\\\\\\n * S3 supports both bucket/key and /bucket/key\\\\\\\\n * This test validates the fix for the bug described in https://sim.amazon.com/issues/AWSCRT-730\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_copy_source_prefixed_by_slash_multipart, s_test_s3_copy_source_prefixed_by_slash_multipart)\\\\\\\\nstatic int s_test_s3_copy_source_prefixed_by_slash_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-256MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_256MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK,\\\\\\\\n        MB_TO_BYTES(256),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_get_object_mrap_helper(struct aws_allocator *allocator, bool multipart) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_signing_config_aws signing_config = tester.default_signing_config;\\\\\\\\n    /* Use Sigv4A for signing */\\\\\\\\n    signing_config.algorithm = AWS_SIGNING_ALGORITHM_V4_ASYMMETRIC;\\\\\\\\n    /* Use * for region to sign */\\\\\\\\n    signing_config.region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = multipart ? 64 * 1024 : 20 * 1024 * 1024,\\\\\\\\n        .region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\"),\\\\\\\\n        .signing_config = &signing_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0 /*flag*/));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .mrap_test = true,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test single-part get object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_less_than_part_size_mrap, s_test_s3_get_object_less_than_part_size_mrap)\\\\\\\\nstatic int s_test_s3_get_object_less_than_part_size_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_get_object_mrap_helper(allocator, false /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test multi-part get object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multipart_mrap, s_test_s3_get_object_multipart_mrap)\\\\\\\\nstatic int s_test_s3_get_object_multipart_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_get_object_mrap_helper(allocator, true /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_put_object_mrap_helper(struct aws_allocator *allocator, bool multipart) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_signing_config_aws signing_config = tester.default_signing_config;\\\\\\\\n    /* Use Sigv4A for signing */\\\\\\\\n    signing_config.algorithm = AWS_SIGNING_ALGORITHM_V4_ASYMMETRIC;\\\\\\\\n    /* Use * for region to sign */\\\\\\\\n    signing_config.region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n        .region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\"),\\\\\\\\n        .signing_config = &signing_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0 /*flag*/));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .mrap_test = true,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = multipart ? 10 : 1,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test single-part put object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_less_than_part_size_mrap, s_test_s3_put_object_less_than_part_size_mrap)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_put_object_mrap_helper(allocator, false /*multipart*/);\\\\\\\\n}\\\\\\\\n/* Test multi-part put object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multipart_mrap, s_test_s3_put_object_multipart_mrap)\\\\\\\\nstatic int s_test_s3_put_object_multipart_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_put_object_mrap_helper(allocator, true /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_http_message *s_put_object_request_new(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor key,\\\\\\\\n    struct aws_byte_cursor endpoint,\\\\\\\\n    struct aws_input_stream *body_stream,\\\\\\\\n    uint64_t content_length) {\\\\\\\\n\\\\\\\\n    AWS_PRECONDITION(allocator);\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n\\\\\\\\n    if (message == NULL) {\\\\\\\\n        return NULL;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if (aws_http_message_set_request_path(message, key)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_http_header host_header = {\\\\\\\\n        .name = g_host_header_name,\\\\\\\\n        .value = endpoint,\\\\\\\\n    };\\\\\\\\n    if (aws_http_message_add_header(message, host_header)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    char content_length_c_str[1024];\\\\\\\\n    snprintf(content_length_c_str, sizeof(content_length_c_str), \\\\\\\\\\\\\"%\\\\\\\\\\\\\" PRIu64, content_length);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_length_header = {\\\\\\\\n        .name = g_content_length_header_name,\\\\\\\\n        .value = aws_byte_cursor_from_c_str(content_length_c_str),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    if (aws_http_message_add_header(message, content_length_header)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if (aws_http_message_set_request_method(message, aws_http_method_put)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_set_body_stream(message, body_stream);\\\\\\\\n\\\\\\\\n    return message;\\\\\\\\n\\\\\\\\nerror_clean_up_message:\\\\\\\\n\\\\\\\\n    if (message != NULL) {\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n        message = NULL;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return NULL;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct put_object_pause_resume_test_data {\\\\\\\\n    struct aws_mutex mutex;\\\\\\\\n    struct aws_condition_variable c_var;\\\\\\\\n\\\\\\\\n    /* execution of the test meta request completed */\\\\\\\\n    bool execution_completed;\\\\\\\\n\\\\\\\\n    /* accumulator of amount of bytes uploaded */\\\\\\\\n    struct aws_atomic_var total_bytes_uploaded;\\\\\\\\n\\\\\\\\n    /* the offset where upload should be paused */\\\\\\\\n    struct aws_atomic_var request_pause_offset;\\\\\\\\n\\\\\\\\n    struct aws_atomic_var pause_requested;\\\\\\\\n\\\\\\\\n    struct aws_atomic_var pause_result;\\\\\\\\n\\\\\\\\n    /* the persistable state of the paused request */\\\\\\\\n    struct aws_atomic_var persistable_state_ptr;\\\\\\\\n\\\\\\\\n    int meta_request_error_code;\\\\\\\\n    int response_status_code;\\\\\\\\n\\\\\\\\n    /* (Optional) content_length to send. If not set, use the length of the input stream. */\\\\\\\\n    uint64_t content_length;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic void s_put_pause_resume_meta_request_finish(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *meta_request_result,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    struct aws_s3_tester *tester = user_data;\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = tester->user_data;\\\\\\\\n\\\\\\\\n    /* if error response body is available, dump it to test result to help investigation of failed tests */\\\\\\\\n    if (meta_request_result->error_response_body != NULL && meta_request_result->error_response_body->len > 0) {\\\\\\\\n        AWS_LOGF_ERROR(\\\\\\\\n            AWS_LS_S3_GENERAL,\\\\\\\\n            \\\\\\\\\\\\\"Response error body: %.*s\\\\\\\\\\\\\",\\\\\\\\n            (int)meta_request_result->error_response_body->len,\\\\\\\\n            meta_request_result->error_response_body->buffer);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_mutex_lock(&test_data->mutex);\\\\\\\\n    test_data->meta_request_error_code = meta_request_result->error_code;\\\\\\\\n    test_data->response_status_code = meta_request_result->response_status;\\\\\\\\n    test_data->execution_completed = true;\\\\\\\\n    aws_mutex_unlock(&test_data->mutex);\\\\\\\\n    aws_condition_variable_notify_one(&test_data->c_var);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic bool s_put_pause_resume_test_completion_predicate(void *arg) {\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = arg;\\\\\\\\n    return test_data->execution_completed;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Patched version of aws_s3_meta_request_vtable->finished_request() for pause/resume tests.\\\\\\\\n * It can pause the meta-request immediately after a part completes.\\\\\\\\n * We use a patched vtable, instead of the progress_callback, because\\\\\\\\n * the progress_callback fires on another thread, which might be too late to\\\\\\\\n * prevent more parts from being sent. */\\\\\\\\nstatic void s_meta_request_finished_request_patched_for_pause_resume_tests(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    struct aws_s3_tester *tester = meta_request->user_data;\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = tester->user_data;\\\\\\\\n    AWS_ASSERT(test_data);\\\\\\\\n\\\\\\\\n    if ((error_code == AWS_ERROR_SUCCESS) && (meta_request->type == AWS_S3_META_REQUEST_TYPE_PUT_OBJECT) &&\\\\\\\\n        (request->request_tag == AWS_S3_AUTO_RANGED_PUT_REQUEST_TAG_PART)) {\\\\\\\\n\\\\\\\\n        if (!request->is_noop) {\\\\\\\\n            /* If the request is noop, we are not really uploading the part */\\\\\\\\n            aws_atomic_fetch_add(&test_data->total_bytes_uploaded, request->request_body.len);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        size_t total_bytes_uploaded = aws_atomic_load_int(&test_data->total_bytes_uploaded);\\\\\\\\n        uint64_t offset_to_pause = aws_atomic_load_int(&test_data->request_pause_offset);\\\\\\\\n\\\\\\\\n        if (total_bytes_uploaded >= offset_to_pause) {\\\\\\\\n            /* offset of the upload at which we should pause was reached. let\\'s pause the upload */\\\\\\\\n            /* if the meta request has already been paused previously, do nothing. */\\\\\\\\n            size_t expected = false;\\\\\\\\n            bool request_pause = aws_atomic_compare_exchange_int(&test_data->pause_requested, &expected, true);\\\\\\\\n            if (request_pause) {\\\\\\\\n                struct aws_s3_meta_request_resume_token *resume_token = NULL;\\\\\\\\n                int pause_result = aws_s3_meta_request_pause(meta_request, &resume_token);\\\\\\\\n                struct aws_byte_cursor upload_id = aws_s3_meta_request_resume_token_upload_id(resume_token);\\\\\\\\n                /* Make Sure we have upload ID */\\\\\\\\n                AWS_FATAL_ASSERT(aws_byte_cursor_eq_c_str(&upload_id, \\\\\\\\\\\\\"\\\\\\\\\\\\\") == false);\\\\\\\\n                aws_atomic_store_int(&test_data->pause_result, pause_result);\\\\\\\\n                aws_atomic_store_ptr(&test_data->persistable_state_ptr, resume_token);\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Continue with original vtable function... */\\\\\\\\n    struct aws_s3_meta_request_vtable *original_meta_request_vtable =\\\\\\\\n        aws_s3_tester_get_meta_request_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    original_meta_request_vtable->finished_request(meta_request, request, error_code);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_s3_meta_request *s_meta_request_factory_patch_for_pause_resume_tests(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    const struct aws_s3_meta_request_options *options) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(client != NULL);\\\\\\\\n    struct aws_s3_tester *tester = client->shutdown_callback_user_data;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *original_client_vtable =\\\\\\\\n        aws_s3_tester_get_client_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = original_client_vtable->meta_request_factory(client, options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *patched_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(tester, meta_request, NULL);\\\\\\\\n    patched_meta_request_vtable->finished_request = s_meta_request_finished_request_patched_for_pause_resume_tests;\\\\\\\\n\\\\\\\\n    return meta_request;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* total length of the object to simulate for upload */\\\\\\\\nstatic const size_t s_pause_resume_object_length_128MB = 128 * 1024 * 1024;\\\\\\\\n\\\\\\\\n/* this runs when a RESUMED upload is about to successfully complete */\\\\\\\\nstatic int s_pause_resume_upload_review_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_upload_review *review,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)user_data;\\\\\\\\n    struct aws_allocator *allocator = meta_request->allocator;\\\\\\\\n\\\\\\\\n    /* A bit hacky, but stream the same data that the test always uploads, and ensure the checksums match */\\\\\\\\n\\\\\\\\n    struct aws_input_stream *reread_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    for (size_t part_index = 0; part_index < review->part_count; ++part_index) {\\\\\\\\n        const struct aws_s3_upload_part_review *part_review = &review->part_array[part_index];\\\\\\\\n        struct aws_byte_buf reread_part_buf;\\\\\\\\n        ASSERT_TRUE(part_review->size <= SIZE_MAX);\\\\\\\\n        aws_byte_buf_init(&reread_part_buf, allocator, (size_t)part_review->size);\\\\\\\\n        ASSERT_SUCCESS(aws_input_stream_read(reread_stream, &reread_part_buf));\\\\\\\\n\\\\\\\\n        /* part sizes should match */\\\\\\\\n        ASSERT_UINT_EQUALS(part_review->size, reread_part_buf.len);\\\\\\\\n\\\\\\\\n        if (review->checksum_algorithm != AWS_SCA_NONE) {\\\\\\\\n            struct aws_byte_cursor reread_part_cursor = aws_byte_cursor_from_buf(&reread_part_buf);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf checksum_buf;\\\\\\\\n            aws_byte_buf_init(&checksum_buf, allocator, 128);\\\\\\\\n            ASSERT_SUCCESS(\\\\\\\\n                aws_checksum_compute(allocator, review->checksum_algorithm, &reread_part_cursor, &checksum_buf));\\\\\\\\n            struct aws_byte_cursor checksum_cursor = aws_byte_cursor_from_buf(&checksum_buf);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf encoded_checksum_buf;\\\\\\\\n            aws_byte_buf_init(&encoded_checksum_buf, allocator, 128);\\\\\\\\n\\\\\\\\n            ASSERT_SUCCESS(aws_base64_encode(&checksum_cursor, &encoded_checksum_buf));\\\\\\\\n\\\\\\\\n            /* part checksums should match */\\\\\\\\n            ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n                encoded_checksum_buf.buffer,\\\\\\\\n                encoded_checksum_buf.len,\\\\\\\\n                part_review->checksum.ptr,\\\\\\\\n                part_review->checksum.len);\\\\\\\\n\\\\\\\\n            aws_byte_buf_clean_up(&checksum_buf);\\\\\\\\n            aws_byte_buf_clean_up(&encoded_checksum_buf);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_byte_buf_clean_up(&reread_part_buf);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_input_stream_release(reread_stream);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_pause_resume_receive_body_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)range_start;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    // TODO: this is a bit hacky, as it will try to compare every partial get result we receive to the input stream.\\\\\\\\n    // Something better?\\\\\\\\n\\\\\\\\n    struct aws_input_stream *input_stream =\\\\\\\\n        aws_s3_test_input_stream_new(meta_request->allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf buf;\\\\\\\\n    aws_byte_buf_init(&buf, meta_request->allocator, (size_t)range_start);\\\\\\\\n    aws_input_stream_read(input_stream, &buf);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&buf);\\\\\\\\n    aws_byte_buf_init(&buf, meta_request->allocator, body->len);\\\\\\\\n    aws_input_stream_read(input_stream, &buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor input_cur = aws_byte_cursor_from_buf(&buf);\\\\\\\\n\\\\\\\\n    bool body_matches_expected = aws_byte_cursor_eq(&input_cur, body);\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(input_stream);\\\\\\\\n    aws_byte_buf_clean_up(&buf);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_matches_expected);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_pause_resume_helper(\\\\\\\\n    struct aws_s3_tester *tester,\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    struct put_object_pause_resume_test_data *test_data,\\\\\\\\n    struct aws_byte_cursor destination_key,\\\\\\\\n    struct aws_input_stream *upload_body_stream,\\\\\\\\n    struct aws_s3_meta_request_resume_token *resume_state,\\\\\\\\n    enum aws_s3_checksum_algorithm checksum_algorithm,\\\\\\\\n    int expected_error_code,\\\\\\\\n    int expected_response_status) {\\\\\\\\n\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    if (resume_state == NULL) {\\\\\\\\n        /* If we\\'re going to cancel this operation, limit the client to 1 HTTP connection.\\\\\\\\n         * That way, we don\\'t end up \\\\\\\\\\\\\"cancelling\\\\\\\\\\\\\" but all the parts actually\\\\\\\\n         * succeed anyway on other connections */\\\\\\\\n        client_config.max_active_connections_override = 1;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(tester, client, NULL);\\\\\\\\n    patched_client_vtable->meta_request_factory = s_meta_request_factory_patch_for_pause_resume_tests;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    /* creates a PutObject request */\\\\\\\\n    int64_t content_length = test_data->content_length;\\\\\\\\n    if (content_length == 0) {\\\\\\\\n        /* If not set, use the length of the input stream */\\\\\\\\n        aws_input_stream_get_length(upload_body_stream, &content_length);\\\\\\\\n    }\\\\\\\\n    struct aws_http_message *message = s_put_object_request_new(\\\\\\\\n        allocator, destination_key, aws_byte_cursor_from_c_str(endpoint), upload_body_stream, content_length);\\\\\\\\n\\\\\\\\n    test_data->c_var = (struct aws_condition_variable)AWS_CONDITION_VARIABLE_INIT;\\\\\\\\n    aws_mutex_init(&test_data->mutex);\\\\\\\\n    test_data->execution_completed = false;\\\\\\\\n\\\\\\\\n    tester->user_data = test_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_checksum_config checksum_config = {\\\\\\\\n        .checksum_algorithm = checksum_algorithm,\\\\\\\\n        .location = checksum_algorithm == AWS_SCA_NONE ? AWS_SCL_NONE : AWS_SCL_TRAILER,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options meta_request_options = {\\\\\\\\n        .user_data = tester,\\\\\\\\n        .body_callback = NULL,\\\\\\\\n        .signing_config = client_config.signing_config,\\\\\\\\n        .finish_callback = s_put_pause_resume_meta_request_finish,\\\\\\\\n        .headers_callback = NULL,\\\\\\\\n        .upload_review_callback = s_pause_resume_upload_review_callback,\\\\\\\\n        .message = message,\\\\\\\\n        .shutdown_callback = NULL,\\\\\\\\n        .resume_token = NULL,\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_config = &checksum_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    if (resume_state) {\\\\\\\\n        meta_request_options.resume_token = resume_state;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &meta_request_options);\\\\\\\\n    ASSERT_NOT_NULL(meta_request);\\\\\\\\n\\\\\\\\n    /* wait completion of the meta request */\\\\\\\\n    aws_mutex_lock(&test_data->mutex);\\\\\\\\n    aws_condition_variable_wait_pred(\\\\\\\\n        &test_data->c_var, &test_data->mutex, s_put_pause_resume_test_completion_predicate, test_data);\\\\\\\\n    aws_mutex_unlock(&test_data->mutex);\\\\\\\\n\\\\\\\\n    /* assert error_code and response_status_code */\\\\\\\\n    ASSERT_INT_EQUALS(expected_error_code, test_data->meta_request_error_code);\\\\\\\\n    ASSERT_INT_EQUALS(expected_response_status, test_data->response_status_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_mutex_clean_up(&test_data->mutex);\\\\\\\\n    aws_http_message_destroy(message);\\\\\\\\n\\\\\\\\n    /* release this client with its crazy patched vtables */\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_wait_for_client_shutdown(tester);\\\\\\\\n    tester->bound_to_client = false;\\\\\\\\n\\\\\\\\n    if (expected_error_code == AWS_ERROR_SUCCESS) {\\\\\\\\n        /* get the file and verify it matches what we uploaded */\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .body_callback = s_pause_resume_receive_body_callback,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = destination_key,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_test_results results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(tester, &options, &results));\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_happy_path, s_test_s3_put_pause_resume_happy_path)\\\\\\\\nstatic int s_test_s3_put_pause_resume_happy_path(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded < s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_all_parts_done, s_test_s3_put_pause_resume_all_parts_done)\\\\\\\\nstatic int s_test_s3_put_pause_resume_all_parts_done(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_all_parts_done.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 128 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_NONE,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    AWS_LOGF_INFO(AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Persistable state %p\\\\\\\\\\\\\", persistable_state);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_NONE,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_INT_EQUALS(0, bytes_uploaded);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_resume_data, s_test_s3_put_pause_resume_invalid_resume_data)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_resume_data(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_resume_data.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_s3_test_input_stream_new_with_value_type(\\\\\\\\n        allocator, s_pause_resume_object_length_128MB, TEST_STREAM_VALUE_2);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_RESUMED_PART_CHECKSUM_MISMATCH,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded < s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_resume_stream, s_test_s3_put_pause_resume_invalid_resume_stream)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_resume_stream(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_bad_resume_stream.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_release(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* a bad input stream to resume from */\\\\\\\\n    struct aws_input_stream_tester_options stream_options = {\\\\\\\\n        .autogen_length = s_pause_resume_object_length_128MB,\\\\\\\\n        .fail_on_nth_read = 1,\\\\\\\\n        .fail_with_error_code = AWS_IO_STREAM_READ_FAILED,\\\\\\\\n    };\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_input_stream_new_tester(allocator, &stream_options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    /* Each failed resume will delete the MPU */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_IO_STREAM_READ_FAILED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* resume didn\\'t read any bytes because the bad input stream failed to read. */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded == 0);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_release(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_content_length, s_test_s3_put_pause_resume_invalid_content_length)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_bad_resume_stream.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n    test_data.content_length = s_pause_resume_object_length_128MB;\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_release(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* a small input stream to resume with */\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_s3_test_input_stream_new(allocator, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    /* Each failed resume will delete the MPU */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_INCORRECT_CONTENT_LENGTH,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* resume didn\\'t read any bytes because the bad input stream failed to read. */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded == 0);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_release(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Most basic test of the upload_review_callback */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review, s_test_s3_upload_review)\\\\\\\\nstatic int s_test_s3_upload_review(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_CRC32.txt\\\\\\\\\\\\\"),\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(2, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(8), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(10) - MB_TO_BYTES(8), test_results.upload_review.part_sizes_array[1]);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_SCA_CRC32, test_results.upload_review.checksum_algorithm);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"9J8ZNA==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"BNjxzQ==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[1]));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test upload_review_callback when Content-Length is not declared */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_no_content_length, s_test_s3_upload_review_no_content_length)\\\\\\\\nstatic int s_test_s3_upload_review_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_1MB_CRC32.txt\\\\\\\\\\\\\"),\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"4hP4ig==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_upload_review_raise_canceled_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_upload_review *review,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)review;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    return aws_raise_error(AWS_ERROR_S3_CANCELED);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that if upload_review_callback raises an error, then the upload is canceled. */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_rejection, s_test_s3_upload_review_rejection)\\\\\\\\nstatic int s_test_s3_upload_review_rejection(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_rejection.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    /* Send meta-request that will raise an error from the review_upload_callback */\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .upload_review_callback = s_upload_review_raise_canceled_error,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* Check that meta-request failed with the error raised by the upload_review_callback */\\\\\\\\n    ASSERT_INT_EQUALS(AWS_ERROR_S3_CANCELED, test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    /*\\\\\\\\n     * Now check that the upload did not complete on the server either\\\\\\\\n     * (server should have received AbortMultipartUpload).\\\\\\\\n     * Check by attempting to GET the object, which should fail with 404 NOT FOUND.\\\\\\\\n     */\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &test_results));\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_404_NOT_FOUND, test_results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(test_results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(test_results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(test_results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that an MPU can be done with checksum location = NONE as long as an upload review callback\\\\\\\\n * is used, and the resulting object doesn\\'t have checksums uploaded. */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_checksum_location_none, s_test_s3_upload_review_checksum_location_none)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(2, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(5), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(5), test_results.upload_review.part_sizes_array[1]);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_SCA_CRC32, test_results.upload_review.checksum_algorithm);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"7/xUXw==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"PCOjcw==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[1]));\\\\\\\\n\\\\\\\\n    /* S3 will store the crc64 checksum for the whole object, and we can still have validate the checksum, but the algo\\\\\\\\n     * be validated will be crc64, instead of the crc32 we get from the client. */\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC64NVME,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_checksum_location_none_async, s_test_s3_upload_review_checksum_location_none_async)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none_async(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Trying to reach the noop case of async read */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_upload_review_checksum_location_none_async_noop_part,\\\\\\\\n    s_test_s3_upload_review_checksum_location_none_async_noop_part)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none_async_noop_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n                .eof_requires_extra_read = true, /* don\\'t report EOF until it tries to read 2nd part */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_http_stream *s_http_connection_make_request_patch(\\\\\\\\n    struct aws_http_connection *client_connection,\\\\\\\\n    const struct aws_http_make_request_options *options) {\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = options->request;\\\\\\\\n    struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n    struct aws_byte_cursor out_value;\\\\\\\\n    int e = aws_http_headers_get(headers, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"Content-Length\\\\\\\\\\\\\"), &out_value);\\\\\\\\n    AWS_FATAL_ASSERT(e == AWS_OP_ERR); // Assert that the header is not present\\\\\\\\n    AWS_FATAL_ASSERT(aws_last_error() == AWS_ERROR_HTTP_HEADER_NOT_FOUND);\\\\\\\\n\\\\\\\\n    return aws_http_connection_make_request(client_connection, options);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_get_without_content_length, s_test_s3_default_get_without_content_length)\\\\\\\\nstatic int s_test_s3_default_get_without_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    /* Send default type */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.message = message;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct aws_string *test_helper(struct aws_allocator *allocator) {\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n    return host_name;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_get, aws_test_s3_default_get)\\\\\\\\nstatic int aws_test_s3_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_string *hsot_name = test_helper(allocator);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(hsot_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    /* Send default type */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.message = message;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\",\\\\n  \\\\\"encoding\\\\\": \\\\\"base64\\\\\",\\\\n  \\\\\"_links\\\\\": {\\\\n    \\\\\"self\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests/s3_data_plane_tests.c?ref=dummy-delete-me\\\\\",\\\\n    \\\\\"git\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/git/blobs/dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n    \\\\\"html\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\"\\\\n  }\\\\n}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Let me examine the comments styles file you mentioned to understand how I should format my comments:\"},{\"type\":\"tool_use\",\"name\":\"filesystem-read_file\",\"input\":{\"path\":\"/Users/dengket/project/hackthon/fast-agent/crt_c_reviewer/summarization/comments_styles.md\"},\"id\":\"toolu_bdrk_01VNh1vSTvhtTx4LEcYPMe9X\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01VNh1vSTvhtTx4LEcYPMe9X\",\"content\":[{\"type\":\"text\",\"text\":\"# Effective Code Review Comment Guidelines\\\\n\\\\nBased on an analysis of multiple GitHub Pull Request reviews, this document summarizes key patterns and best practices for writing effective code review comments.\\\\n\\\\n## General Principles\\\\n\\\\n### 1. Comment Classification\\\\n\\\\n* **Use clear prefixes to indicate severity:**\\\\n  + `trivial:` - Minor issues that should be fixed but don\\'t block approval\\\\n  + `debatable:` or `extremely debatable:` - Suggestions open to discussion\\\\n  + `nit:` - Extremely minor stylistic preferences\\\\n  + `important:` - Issues that should be addressed before merging\\\\n  + `blocking:` - Critical issues that must be resolved\\\\n\\\\n* **Be explicit about expectations:**\\\\n  + Distinguish between mandatory changes and optional suggestions\\\\n  + Indicate when comments are informational rather than requesting changes\\\\n\\\\n### 2. Comment Structure\\\\n\\\\n* **Be specific and actionable:**\\\\n  + Refer to specific lines or sections of code\\\\n  + Explain both what the issue is and why it matters\\\\n  + Provide concrete solutions when possible\\\\n\\\\n* **Use GitHub suggestion blocks for direct code changes:**\\\\n  \\\\n\\\\n```\\\\n  ```suggestion\\\\n  actual code change goes here\\\\n  ```\\\\n\\\\n  \\\\n\\\\n```\\\\n\\\\n- **Group related issues together:**\\\\n  - Number multiple points for clarity\\\\n  - Address similar issues in a single comment when possible\\\\n\\\\n- **Provide context:**\\\\n  - Link to relevant documentation, PRs, or issues\\\\n  - Reference cross-repository standards when applicable\\\\n  - Explain reasoning behind suggestions, not just what to change\\\\n\\\\n### 3. Comment Scope\\\\n\\\\n- **Focus on the right level of detail:**\\\\n  - For simple PRs: Brief approvals may be sufficient\\\\n  - For complex PRs: Detailed, organized feedback is necessary\\\\n\\\\n- **Consider multiple aspects of code quality:**\\\\n  - Functional correctness\\\\n  - Error handling and edge cases\\\\n  - Performance implications\\\\n  - Security considerations\\\\n  - Consistency with existing patterns\\\\n  - Documentation and readability\\\\n  - Cross-platform compatibility\\\\n  - API design and usability\\\\n\\\\n## Technical Focus Areas\\\\n\\\\n### 1. Code Architecture and Design\\\\n\\\\n- **API Usability:**\\\\n  - Consider the developer experience of using the API\\\\n  - Question potentially confusing or redundant API requirements\\\\n  - Think about cross-language compatibility\\\\n\\\\n- **Error Handling:**\\\\n  - Verify proper cleanup in error cases\\\\n  - Ensure appropriate error propagation\\\\n  - Check for consistent error handling patterns\\\\n  - In C code, prefer unified error paths with consolidated cleanup\\\\n\\\\n- **Consistency:**\\\\n  - Flag inconsistent naming conventions\\\\n  - Highlight deviations from established patterns\\\\n  - Ensure consistency across related repositories\\\\n\\\\n### 2. Code Style and Readability\\\\n\\\\n- **Prioritize clear organization:**\\\\n  - Suggest clearer code structure when logic is hard to follow\\\\n  - Flag complex conditionals that could be simplified\\\\n  - Recommend extracting complex logic into well-named helper functions\\\\n\\\\n- **Comment on documentation:**\\\\n  - Ensure comments accurately describe behavior\\\\n  - Request documentation for parameters with specific usage requirements\\\\n  - Verify public API documentation clarity\\\\n\\\\n- **Focus on maintainability:**\\\\n  - Consider how code might evolve in the future\\\\n  - Identify fragile patterns that could break with future changes\\\\n  - Suggest explicit guards against potential future bugs\\\\n\\\\n### 3. Cross-Team and Ecosystem Considerations\\\\n\\\\n- **Coordinate across teams:**\\\\n  - Flag changes that might affect other teams or services\\\\n  - Recommend cross-team communication when necessary\\\\n\\\\n- **Verify ecosystem consistency:**\\\\n  - Check if behavior matches related SDKs or libraries\\\\n  - Confirm conformance to broader project standards\\\\n\\\\n## Review Process\\\\n\\\\n### 1. Reviewing Approach\\\\n\\\\n- **Progressive reviews:**\\\\n  - Start with critical issues and architectural concerns\\\\n  - Follow up on remaining issues after major concerns are addressed\\\\n  - Provide final approval once all necessary changes are made\\\\n\\\\n- **Approval comments:**\\\\n  - Use \\\\\"fix & ship\\\\\" for PRs with only minor issues\\\\n  - Include verification steps if needed before merging\\\\n  - Acknowledge when previous feedback has been addressed\\\\n\\\\n### 2. Review Tone\\\\n\\\\n- **Be direct but constructive:**\\\\n  - Focus on the code, not the person\\\\n  - Frame feedback as improvements rather than criticisms\\\\n  - Use a professional, collaborative tone\\\\n\\\\n- **Acknowledge good work:**\\\\n  - Provide positive feedback on well-implemented features\\\\n  - Recognize when authors have addressed previous feedback well\\\\n  - Use phrases like \\\\\"nice job\\\\\" or \\\\\"this looks good\\\\\" where appropriate\\\\n\\\\n- **Balance criticism with encouragement:**\\\\n  - Point out both strengths and areas for improvement\\\\n  - Recognize the effort that went into the implementation\\\\n\\\\n## Comment Examples by Category\\\\n\\\\n### Effective Trivial Comments\\\\n\\\\n```\\\\n\\\\ntrivial: undoing needless changes to whitespace\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\ntrivial: it\\'s weird to use the `_10MB` and then upload 5MB\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\ntrivial: I found this if-statement confusing, and the helper function that did different things depending on how it\\'s called...\\\\n\\\\n```\\\\n\\\\n### Effective Technical Suggestions\\\\n\\\\n```\\\\n\\\\nif there\\'s an error, we need to cleanup out_checksum\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nSo, if users already added a checksum header, they ALSO need to set this enum?\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nInstead of the `on_error:` label sharing 90% the same cleanup code as `s_s3_client_finish_destroy_default()` , have them share code\\\\n\\\\n```\\\\n\\\\n### Effective Process Comments\\\\n\\\\n```\\\\n\\\\nI\\'d advise checking this branch from aws-crt-cpp, and making sure it all works nicely, before merging\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nChecked the C++ SDK and Java SDK and they also retry on TLS errors.\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nneed to coordinate with python teams on this...\\\\n```\\\\n\\\\n### Silent Approvals (When Appropriate)\\\\n\\\\nSilent approvals (no comments, just approval) are appropriate for:\\\\n* Simple, straightforward changes\\\\n* Well-understood code\\\\n* Follow-up to previous discussions\\\\n* Self-explanatory code\\\\n* Trivial fixes\\\\n* When there\\'s an established trust relationship between reviewer and author\\\\n\\\\n## Special Cases\\\\n\\\\n### 1. Automated/Routine Changes\\\\n\\\\n* **Minimize comments for routine updates:**\\\\n  + For automated changes or version bumps, simple approvals may be sufficient\\\\n  + Focus comments on any unexpected deviations from expected patterns\\\\n\\\\n### 2. Cross-Repository Changes\\\\n\\\\n* **Consider broader impacts:**\\\\n  + For changes affecting multiple repositories, test across all affected codebases\\\\n  + Verify consistency with related repositories\\' standards\\\\n\\\\n### 3. Documentation Changes\\\\n\\\\n* **Focus on accuracy and clarity:**\\\\n  + Ensure documentation correctly describes behavior\\\\n  + Verify examples work as described\\\\n  + Check for consistent formatting and terminology\\\\n\\\\n## Conclusion\\\\n\\\\nEffective code review comments are specific, actionable, appropriately categorized, and delivered in a constructive tone. They focus on technical accuracy while maintaining readability and consistency with project standards. The level of detail should match the complexity of the change, ranging from brief approvals for simple changes to detailed, structured feedback for complex modifications.\\\\n\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Let me also examine the changes in the PR more closely by specifically getting the diff:\"},{\"type\":\"tool_use\",\"name\":\"github-get_pull_request_files\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"pull_number\":519},\"id\":\"toolu_bdrk_01GgbrNtrUVHVL6GbDsA2bEJ\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01GgbrNtrUVHVL6GbDsA2bEJ\",\"content\":[{\"type\":\"text\",\"text\":\"[\\\\n  {\\\\n    \\\\\"sha\\\\\": \\\\\"dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n    \\\\\"filename\\\\\": \\\\\"tests/s3_data_plane_tests.c\\\\\",\\\\n    \\\\\"status\\\\\": \\\\\"modified\\\\\",\\\\n    \\\\\"additions\\\\\": 49,\\\\n    \\\\\"deletions\\\\\": 0,\\\\n    \\\\\"changes\\\\\": 49,\\\\n    \\\\\"blob_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6/tests%2Fs3_data_plane_tests.c\\\\\",\\\\n    \\\\\"raw_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/raw/e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6/tests%2Fs3_data_plane_tests.c\\\\\",\\\\n    \\\\\"contents_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests%2Fs3_data_plane_tests.c?ref=e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6\\\\\",\\\\n    \\\\\"patch\\\\\": \\\\\"@@ -8114,3 +8114,52 @@ static int s_test_s3_default_get_without_content_length(struct aws_allocator *al\\\\\\\\n \\\\\\\\n     return AWS_OP_SUCCESS;\\\\\\\\n }\\\\\\\\n+\\\\\\\\n+struct aws_string *test_helper(struct aws_allocator *allocator) {\\\\\\\\n+    struct aws_string *host_name =\\\\\\\\n+        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n+    return host_name;\\\\\\\\n+}\\\\\\\\n+\\\\\\\\n+AWS_TEST_CASE(test_s3_default_get, aws_test_s3_default_get)\\\\\\\\n+static int aws_test_s3_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n+    (void)ctx;\\\\\\\\n+\\\\\\\\n+    struct aws_s3_tester tester;\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n+\\\\\\\\n+    struct aws_s3_client *client = NULL;\\\\\\\\n+    struct aws_s3_tester_client_options client_options;\\\\\\\\n+    AWS_ZERO_STRUCT(client_options);\\\\\\\\n+\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n+    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n+    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n+\\\\\\\\n+    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n+    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n+\\\\\\\\n+    struct aws_string *hsot_name = test_helper(allocator);\\\\\\\\n+\\\\\\\\n+    /* Put together a simple S3 Get Object request. */\\\\\\\\n+    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n+        allocator, aws_byte_cursor_from_string(hsot_name), g_pre_existing_object_1MB);\\\\\\\\n+\\\\\\\\n+    struct aws_s3_meta_request_options options;\\\\\\\\n+    AWS_ZERO_STRUCT(options);\\\\\\\\n+    /* Send default type */\\\\\\\\n+    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n+    options.message = message;\\\\\\\\n+    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n+\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n+        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n+\\\\\\\\n+    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n+    aws_http_message_release(message);\\\\\\\\n+    aws_s3_client_release(client);\\\\\\\\n+    aws_s3_tester_clean_up(&tester);\\\\\\\\n+\\\\\\\\n+    return AWS_OP_SUCCESS;\\\\\\\\n+}\\\\\"\\\\n  }\\\\n]\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now I\\'ll create a file with my comments on the PR focusing on code simplicity:\"},{\"type\":\"tool_use\",\"name\":\"filesystem-create_directory\",\"input\":{\"path\":\"./new_comments_s3_PR519\"},\"id\":\"toolu_bdrk_01AFJeNDnfYyG1BMcVin5ZCX\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01AFJeNDnfYyG1BMcVin5ZCX\",\"content\":[{\"type\":\"text\",\"text\":\"Successfully created directory ./new_comments_s3_PR519\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"tool_use\",\"name\":\"filesystem-write_file\",\"input\":{\"path\":\"./new_comments_s3_PR519/PR519_Comments_Impl.md\",\"content\":\"# Code Simplicity Comments for PR #519\\\\n\\\\n## Line 8116-8120: `test_helper` Function\\\\n\\\\n```\\\\nstruct aws_string *test_helper(struct aws_allocator *allocator) {\\\\n    struct aws_string *host_name =\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\n    return host_name;\\\\n}\\\\n```\\\\n\\\\n**trivial:** The `test_helper` function has a vague name that doesn\\'t clearly indicate its purpose. Consider renaming it to something more specific like `build_test_endpoint_string` to better describe what it does. This would improve code readability and make the intent clearer.\\\\n\\\\n**trivial:** This helper function could be simplified to a one-liner by removing the temporary variable:\\\\n\\\\n```suggestion\\\\nstruct aws_string *build_test_endpoint_string(struct aws_allocator *allocator) {\\\\n    return aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\n}\\\\n```\\\\n\\\\n## Line 8132: Variable Typo \\\\n\\\\n```\\\\nstruct aws_string *hsot_name = test_helper(allocator);\\\\n```\\\\n\\\\n**trivial:** The variable name `hsot_name` contains a typo; it should be `host_name`. Consistent naming improves code readability.\\\\n\\\\n## Line 8121 and 8123: Function Naming Convention\\\\n\\\\n```\\\\nAWS_TEST_CASE(test_s3_default_get, aws_test_s3_default_get)\\\\nstatic int aws_test_s3_default_get(struct aws_allocator *allocator, void *ctx) {\\\\n```\\\\n\\\\n**debatable:** The test function is named `aws_test_s3_default_get` while all the other tests in the file follow the convention of starting with `s_test_...`. Consider renaming to `s_test_s3_default_get` for consistency with the rest of the codebase. This would make it easier to identify test implementations.\\\\n\\\\n## Overall Test Structure\\\\n\\\\n**nit:** The test structure is very similar to `s_test_s3_default_get_without_content_length` that\\'s defined above. Consider extracting common testing patterns or parameterizing the test to reduce code duplication. This would make the tests more maintainable.\\\\n\\\\n## Line 8145-8146: Memory Management\\\\n\\\\n```\\\\naws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\naws_http_message_release(message);\\\\n```\\\\n\\\\n**trivial:** Consider releasing the `hsot_name` string before other resources. The current code is correct but would be more consistent if all AWS resources are released in reverse order of allocation.\\\\n\\\\n```suggestion\\\\naws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\naws_http_message_release(message);\\\\naws_string_destroy(hsot_name);\\\\n```\"},\"id\":\"toolu_bdrk_017Z3TbD4oCrvfcbaZPRg7GY\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_017Z3TbD4oCrvfcbaZPRg7GY\",\"content\":[{\"type\":\"text\",\"text\":\"Successfully wrote to ./new_comments_s3_PR519/PR519_Comments_Impl.md\"}],\"is_error\":false}]}],\"stop_sequences\":null,\"system\":\"Given a github pull request.         The code in the pull request is very related to the knowledge base, fetch the details of the code base you want to learn about the code from the knowledge base.             Use 8BRIG4RFWU as Knowledge Base ID and aws profile as bedrock, region us-east-1                But if the code is just added by the pull request, then the knowledge base will not help         and follow the guidance in /Users/dengket/project/hackthon/fast-agent/crt_c_reviewer/summarization/comments_styles.md to be how you will make comments then make your comments             as details as you can for each specific lines about the code simplicity on the pull request and suggest on how you can simplify the code without changing the functionality,                 save your comments about the specific line or lines with the number of the lines to a folder naming followed by ./new_comments_s3_PR<the PR number> with name related to the Pull request like PR454_Comments_Impl.md.                     And then, generates the comments only if needed and keep the positive comments out for the specific line or lines as the input for create_pull_request_review,                         save it to a file to the same folder with naming like `input_PR454_comments_code_simplicity.json`, but don\\'t really submit the comments\",\"tools\":[{\"name\":\"github-create_or_update_file\",\"description\":\"Create or update a single file in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"path\":{\"type\":\"string\",\"description\":\"Path where to create/update the file\"},\"content\":{\"type\":\"string\",\"description\":\"Content of the file\"},\"message\":{\"type\":\"string\",\"description\":\"Commit message\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to create/update the file in\"},\"sha\":{\"type\":\"string\",\"description\":\"SHA of the file being replaced (required when updating existing files)\"}},\"required\":[\"owner\",\"repo\",\"path\",\"content\",\"message\",\"branch\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_repositories\",\"description\":\"Search for GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"query\":{\"type\":\"string\",\"description\":\"Search query (see GitHub search syntax)\"},\"page\":{\"type\":\"number\",\"description\":\"Page number for pagination (default: 1)\"},\"perPage\":{\"type\":\"number\",\"description\":\"Number of results per page (default: 30, max: 100)\"}},\"required\":[\"query\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_repository\",\"description\":\"Create a new GitHub repository in your account\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\",\"description\":\"Repository name\"},\"description\":{\"type\":\"string\",\"description\":\"Repository description\"},\"private\":{\"type\":\"boolean\",\"description\":\"Whether the repository should be private\"},\"autoInit\":{\"type\":\"boolean\",\"description\":\"Initialize with README.md\"}},\"required\":[\"name\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_file_contents\",\"description\":\"Get the contents of a file or directory from a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"path\":{\"type\":\"string\",\"description\":\"Path to the file or directory\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to get contents from\"}},\"required\":[\"owner\",\"repo\",\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-push_files\",\"description\":\"Push multiple files to a GitHub repository in a single commit\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to push to (e.g., \\'main\\' or \\'master\\')\"},\"files\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"content\":{\"type\":\"string\"}},\"required\":[\"path\",\"content\"],\"additionalProperties\":false},\"description\":\"Array of files to push\"},\"message\":{\"type\":\"string\",\"description\":\"Commit message\"}},\"required\":[\"owner\",\"repo\",\"branch\",\"files\",\"message\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_issue\",\"description\":\"Create a new issue in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"body\":{\"type\":\"string\"},\"assignees\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"milestone\":{\"type\":\"number\"},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"owner\",\"repo\",\"title\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_pull_request\",\"description\":\"Create a new pull request in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"title\":{\"type\":\"string\",\"description\":\"Pull request title\"},\"body\":{\"type\":\"string\",\"description\":\"Pull request body/description\"},\"head\":{\"type\":\"string\",\"description\":\"The name of the branch where your changes are implemented\"},\"base\":{\"type\":\"string\",\"description\":\"The name of the branch you want the changes pulled into\"},\"draft\":{\"type\":\"boolean\",\"description\":\"Whether to create the pull request as a draft\"},\"maintainer_can_modify\":{\"type\":\"boolean\",\"description\":\"Whether maintainers can modify the pull request\"}},\"required\":[\"owner\",\"repo\",\"title\",\"head\",\"base\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-fork_repository\",\"description\":\"Fork a GitHub repository to your account or specified organization\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"organization\":{\"type\":\"string\",\"description\":\"Optional: organization to fork to (defaults to your personal account)\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_branch\",\"description\":\"Create a new branch in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"branch\":{\"type\":\"string\",\"description\":\"Name for the new branch\"},\"from_branch\":{\"type\":\"string\",\"description\":\"Optional: source branch to create from (defaults to the repository\\'s default branch)\"}},\"required\":[\"owner\",\"repo\",\"branch\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_commits\",\"description\":\"Get list of commits of a branch in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"sha\":{\"type\":\"string\"},\"page\":{\"type\":\"number\"},\"perPage\":{\"type\":\"number\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_issues\",\"description\":\"List issues in a GitHub repository with filtering options\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"direction\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"page\":{\"type\":\"number\"},\"per_page\":{\"type\":\"number\"},\"since\":{\"type\":\"string\"},\"sort\":{\"type\":\"string\",\"enum\":[\"created\",\"updated\",\"comments\"]},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\",\"all\"]}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-update_issue\",\"description\":\"Update an existing issue in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"},\"title\":{\"type\":\"string\"},\"body\":{\"type\":\"string\"},\"assignees\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"milestone\":{\"type\":\"number\"},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\"]}},\"required\":[\"owner\",\"repo\",\"issue_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-add_issue_comment\",\"description\":\"Add a comment to an existing issue\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"},\"body\":{\"type\":\"string\"}},\"required\":[\"owner\",\"repo\",\"issue_number\",\"body\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_code\",\"description\":\"Search for code across GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_issues\",\"description\":\"Search for issues and pull requests across GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100},\"sort\":{\"type\":\"string\",\"enum\":[\"comments\",\"reactions\",\"reactions-+1\",\"reactions--1\",\"reactions-smile\",\"reactions-thinking_face\",\"reactions-heart\",\"reactions-tada\",\"interactions\",\"created\",\"updated\"]}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_users\",\"description\":\"Search for users on GitHub\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100},\"sort\":{\"type\":\"string\",\"enum\":[\"followers\",\"repositories\",\"joined\"]}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_issue\",\"description\":\"Get details of a specific issue in a GitHub repository.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"}},\"required\":[\"owner\",\"repo\",\"issue_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request\",\"description\":\"Get details of a specific pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_pull_requests\",\"description\":\"List and filter repository pull requests\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\",\"all\"],\"description\":\"State of the pull requests to return\"},\"head\":{\"type\":\"string\",\"description\":\"Filter by head user or head organization and branch name\"},\"base\":{\"type\":\"string\",\"description\":\"Filter by base branch name\"},\"sort\":{\"type\":\"string\",\"enum\":[\"created\",\"updated\",\"popularity\",\"long-running\"],\"description\":\"What to sort results by\"},\"direction\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"],\"description\":\"The direction of the sort\"},\"per_page\":{\"type\":\"number\",\"description\":\"Results per page (max 100)\"},\"page\":{\"type\":\"number\",\"description\":\"Page number of the results\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_pull_request_review\",\"description\":\"Create a review on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"commit_id\":{\"type\":\"string\",\"description\":\"The SHA of the commit that needs a review\"},\"body\":{\"type\":\"string\",\"description\":\"The body text of the review\"},\"event\":{\"type\":\"string\",\"enum\":[\"APPROVE\",\"REQUEST_CHANGES\",\"COMMENT\"],\"description\":\"The review action to perform\"},\"comments\":{\"type\":\"array\",\"items\":{\"anyOf\":[{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\",\"description\":\"The relative path to the file being commented on\"},\"position\":{\"type\":\"number\",\"description\":\"The position in the diff where you want to add a review comment\"},\"body\":{\"type\":\"string\",\"description\":\"Text of the review comment\"}},\"required\":[\"path\",\"position\",\"body\"],\"additionalProperties\":false},{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\",\"description\":\"The relative path to the file being commented on\"},\"line\":{\"type\":\"number\",\"description\":\"The line number in the file where you want to add a review comment\"},\"body\":{\"type\":\"string\",\"description\":\"Text of the review comment\"}},\"required\":[\"path\",\"line\",\"body\"],\"additionalProperties\":false}]},\"description\":\"Comments to post as part of the review (specify either position or line, not both)\"}},\"required\":[\"owner\",\"repo\",\"pull_number\",\"body\",\"event\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-merge_pull_request\",\"description\":\"Merge a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"commit_title\":{\"type\":\"string\",\"description\":\"Title for the automatic commit message\"},\"commit_message\":{\"type\":\"string\",\"description\":\"Extra detail to append to automatic commit message\"},\"merge_method\":{\"type\":\"string\",\"enum\":[\"merge\",\"squash\",\"rebase\"],\"description\":\"Merge method to use\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_files\",\"description\":\"Get the list of files changed in a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_status\",\"description\":\"Get the combined status of all status checks for a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-update_pull_request_branch\",\"description\":\"Update a pull request branch with the latest changes from the base branch\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"expected_head_sha\":{\"type\":\"string\",\"description\":\"The expected SHA of the pull request\\'s HEAD ref\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_comments\",\"description\":\"Get the review comments on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_reviews\",\"description\":\"Get the reviews on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-read_file\",\"description\":\"Read the complete contents of a file from the file system. Handles various text encodings and provides detailed error messages if the file cannot be read. Use this tool when you need to examine the contents of a single file. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-read_multiple_files\",\"description\":\"Read the contents of multiple files simultaneously. This is more efficient than reading files one by one when you need to analyze or compare multiple files. Each file\\'s content is returned with its path as a reference. Failed reads for individual files won\\'t stop the entire operation. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"paths\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"paths\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-write_file\",\"description\":\"Create a new file or completely overwrite an existing file with new content. Use with caution as it will overwrite existing files without warning. Handles text content with proper encoding. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"content\":{\"type\":\"string\"}},\"required\":[\"path\",\"content\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-edit_file\",\"description\":\"Make line-based edits to a text file. Each edit replaces exact line sequences with new content. Returns a git-style diff showing the changes made. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"edits\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"oldText\":{\"type\":\"string\",\"description\":\"Text to search for - must match exactly\"},\"newText\":{\"type\":\"string\",\"description\":\"Text to replace with\"}},\"required\":[\"oldText\",\"newText\"],\"additionalProperties\":false}},\"dryRun\":{\"type\":\"boolean\",\"default\":false,\"description\":\"Preview changes using git-style diff format\"}},\"required\":[\"path\",\"edits\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-create_directory\",\"description\":\"Create a new directory or ensure a directory exists. Can create multiple nested directories in one operation. If the directory already exists, this operation will succeed silently. Perfect for setting up directory structures for projects or ensuring required paths exist. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-list_directory\",\"description\":\"Get a detailed listing of all files and directories in a specified path. Results clearly distinguish between files and directories with [FILE] and [DIR] prefixes. This tool is essential for understanding directory structure and finding specific files within a directory. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-directory_tree\",\"description\":\"Get a recursive tree view of files and directories as a JSON structure. Each entry includes \\'name\\', \\'type\\' (file/directory), and \\'children\\' for directories. Files have no children array, while directories always have a children array (which may be empty). The output is formatted with 2-space indentation for readability. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-move_file\",\"description\":\"Move or rename files and directories. Can move files between directories and rename them in a single operation. If the destination exists, the operation will fail. Works across different directories and can be used for simple renaming within the same directory. Both source and destination must be within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"source\":{\"type\":\"string\"},\"destination\":{\"type\":\"string\"}},\"required\":[\"source\",\"destination\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-search_files\",\"description\":\"Recursively search for files and directories matching a pattern. Searches through all subdirectories from the starting path. The search is case-insensitive and matches partial names. Returns full paths to all matching items. Great for finding files when you don\\'t know their exact location. Only searches within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"pattern\":{\"type\":\"string\"},\"excludePatterns\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"default\":[]}},\"required\":[\"path\",\"pattern\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-get_file_info\",\"description\":\"Retrieve detailed metadata about a file or directory. Returns comprehensive information including size, creation time, last modified time, permissions, and type. This tool is perfect for understanding file characteristics without reading the actual content. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-list_allowed_directories\",\"description\":\"Returns the list of directories that this server is allowed to access. Use this to understand which directories are available before trying to access files.\",\"input_schema\":{\"type\":\"object\",\"properties\":{},\"required\":[]}},{\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"description\":\"Query an Amazon Bedrock Knowledge Base using natural language.\\\\n\\\\n    ## Usage Requirements\\\\n    - You MUST first use the `resource://knowledgebases` resource to get valid knowledge base IDs\\\\n    - You can query different knowledge bases or make multiple queries to the same knowledge base\\\\n\\\\n    ## Query Tips\\\\n    - Use clear, specific natural language queries for best results\\\\n    - You can use this tool MULTIPLE TIMES with different queries to gather comprehensive information\\\\n    - Break complex questions into multiple focused queries\\\\n    - Consider querying for factual information and explanations separately\\\\n\\\\n    ## Tool output format\\\\n    The response contains multiple JSON objects (one per line), each representing a retrieved document with:\\\\n    - content: The text content of the document\\\\n    - location: The source location of the document\\\\n    - score: The relevance score of the document\\\\n\\\\n\\\\n    ## Interpretation Best Practices\\\\n    1. Extract and combine key information from multiple results\\\\n    2. Consider the source and relevance score when evaluating information\\\\n    3. Use follow-up queries to clarify ambiguous or incomplete information\\\\n    4. If the response is not relevant, try a different query, knowledge base, and/or data source\\\\n    5. After a few attempts, ask the user for clarification or a different query.\\\\n    \",\"input_schema\":{\"properties\":{\"query\":{\"description\":\"A natural language query to search the knowledge base with\",\"title\":\"Query\",\"type\":\"string\"},\"knowledge_base_id\":{\"description\":\"The knowledge base ID to query. It must be a valid ID from the resource://knowledgebases MCP resource\",\"title\":\"Knowledge Base Id\",\"type\":\"string\"},\"number_of_results\":{\"default\":10,\"description\":\"The number of results to return. Use smaller values for focused results and larger values for broader coverage.\",\"title\":\"Number Of Results\",\"type\":\"integer\"},\"reranking\":{\"default\":false,\"description\":\"Whether to rerank the results. Useful for improving relevance and sorting. Can be globally configured with BEDROCK_KB_RERANKING_ENABLED environment variable.\",\"title\":\"Reranking\",\"type\":\"boolean\"},\"reranking_model_name\":{\"default\":\"AMAZON\",\"description\":\"The name of the reranking model to use. Options: \\'COHERE\\', \\'AMAZON\\'\",\"enum\":[\"COHERE\",\"AMAZON\"],\"title\":\"Reranking Model Name\",\"type\":\"string\"},\"data_source_ids\":{\"anyOf\":[{\"items\":{\"type\":\"string\"},\"type\":\"array\"},{\"type\":\"null\"}],\"default\":null,\"description\":\"The data source IDs to filter the knowledge base by. It must be a list of valid data source IDs from the resource://knowledgebases MCP resource\",\"title\":\"Data Source Ids\"}},\"required\":[\"query\",\"knowledge_base_id\"],\"title\":\"query_knowledge_bases_toolArguments\",\"type\":\"object\"}}],\"anthropic_version\":\"bedrock-2023-05-31\"}'"},"message":"Error code: 429 - {'message': 'Too many tokens, please wait before trying again.'}","body":{"message":"Too many tokens, please wait before trying again."},"response":"<httpx.Response [429] https://bedrock-runtime.us-west-2.amazonaws.com/model/us.anthropic.claude-3-7-sonnet-20250219-v1:0/invoke>","status_code":429,"request_id":null}]}}
{"level":"ERROR","timestamp":"2025-05-15T11:01:58.834525","namespace":"mcp_agent.llm.augmented_llm","message":"Error: Error code: 429 - {'message': 'Too many tokens, please wait before trying again.'}","data":{"data":[{"request":{"method":"POST","url":{"_uri_reference":["https","","bedrock-runtime.us-west-2.amazonaws.com",null,"/model/us.anthropic.claude-3-7-sonnet-20250219-v1:0/invoke",null,null]},"headers":["connection","host","accept-encoding","x-stainless-timeout","accept","content-type","user-agent","x-stainless-lang","x-stainless-package-version","x-stainless-os","x-stainless-arch","x-stainless-runtime","x-stainless-runtime-version","x-stainless-retry-count","x-stainless-read-timeout","content-length","x-amz-date","x-amz-security-token","authorization"],"extensions":{"timeout":{"connect":5.0,"read":600,"write":"600","pool":"600"}},"stream":[{"capitalize":"<callable: capitalize>","center":"<callable: center>","count":"<callable: count>","decode":"<callable: decode>","endswith":"<callable: endswith>","expandtabs":"<callable: expandtabs>","find":"<callable: find>","fromhex":"<callable: fromhex>","hex":"<callable: hex>","index":"<callable: index>","isalnum":"<callable: isalnum>","isalpha":"<callable: isalpha>","isascii":"<callable: isascii>","isdigit":"<callable: isdigit>","islower":"<callable: islower>","isspace":"<callable: isspace>","istitle":"<callable: istitle>","isupper":"<callable: isupper>","join":"<callable: join>","ljust":"<callable: ljust>","lower":"<callable: lower>","lstrip":"<callable: lstrip>","maketrans":"<callable: maketrans>","partition":"<callable: partition>","removeprefix":"<callable: removeprefix>","removesuffix":"<callable: removesuffix>","replace":"<callable: replace>","rfind":"<callable: rfind>","rindex":"<callable: rindex>","rjust":"<callable: rjust>","rpartition":"<callable: rpartition>","rsplit":"<callable: rsplit>","rstrip":"<callable: rstrip>","split":"<callable: split>","splitlines":"<callable: splitlines>","startswith":"<callable: startswith>","strip":"<callable: strip>","swapcase":"<callable: swapcase>","title":"<callable: title>","translate":"<callable: translate>","upper":"<callable: upper>","zfill":"<callable: zfill>"}],"_content":"b'{\"max_tokens\":4096,\"messages\":[{\"role\":\"user\",\"content\":[{\"type\":\"text\",\"text\":\"please review https://github.com/awslabs/aws-c-s3/pull/519\"}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"I\\'ll review the pull request from the GitHub repository awslabs/aws-c-s3 with PR number 519. Let me fetch the details and provide a detailed review based on the knowledge base and code analysis.\"},{\"type\":\"tool_use\",\"name\":\"github-get_pull_request\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"pull_number\":519},\"id\":\"toolu_bdrk_01UNn6s1Ctv5176WfdNtRdKh\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01UNn6s1Ctv5176WfdNtRdKh\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\n  \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/pulls/519\\\\\",\\\\n  \\\\\"id\\\\\": 2520395028,\\\\n  \\\\\"node_id\\\\\": \\\\\"PR_kwDOEJB4Sc6WOi0U\\\\\",\\\\n  \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519\\\\\",\\\\n  \\\\\"diff_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519.diff\\\\\",\\\\n  \\\\\"patch_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519.patch\\\\\",\\\\n  \\\\\"issue_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/issues/519\\\\\",\\\\n  \\\\\"number\\\\\": 519,\\\\n  \\\\\"state\\\\\": \\\\\"open\\\\\",\\\\n  \\\\\"locked\\\\\": false,\\\\n  \\\\\"title\\\\\": \\\\\"dummy test\\\\\",\\\\n  \\\\\"user\\\\\": {\\\\n    \\\\\"login\\\\\": \\\\\"TingDaoK\\\\\",\\\\n    \\\\\"id\\\\\": 26829806,\\\\n    \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/26829806?v=4\\\\\",\\\\n    \\\\\"url\\\\\": \\\\\"https://api.github.com/users/TingDaoK\\\\\",\\\\n    \\\\\"html_url\\\\\": \\\\\"https://github.com/TingDaoK\\\\\"\\\\n  },\\\\n  \\\\\"body\\\\\": \\\\\"*Issue #, if available:*\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n*Description of changes:*\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.\\\\\\\\r\\\\\\\\n\\\\\",\\\\n  \\\\\"created_at\\\\\": \\\\\"2025-05-14T21:35:46Z\\\\\",\\\\n  \\\\\"updated_at\\\\\": \\\\\"2025-05-14T23:38:00Z\\\\\",\\\\n  \\\\\"closed_at\\\\\": null,\\\\n  \\\\\"merged_at\\\\\": null,\\\\n  \\\\\"merge_commit_sha\\\\\": \\\\\"b8fc1c78ceeba7906b6ac56483199a3faaf5e9cd\\\\\",\\\\n  \\\\\"assignee\\\\\": null,\\\\n  \\\\\"assignees\\\\\": [],\\\\n  \\\\\"requested_reviewers\\\\\": [],\\\\n  \\\\\"labels\\\\\": [],\\\\n  \\\\\"head\\\\\": {\\\\n    \\\\\"label\\\\\": \\\\\"awslabs:dummy-delete-me\\\\\",\\\\n    \\\\\"ref\\\\\": \\\\\"dummy-delete-me\\\\\",\\\\n    \\\\\"sha\\\\\": \\\\\"e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6\\\\\",\\\\n    \\\\\"user\\\\\": {\\\\n      \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n      \\\\\"id\\\\\": 3299148,\\\\n      \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\"\\\\n    },\\\\n    \\\\\"repo\\\\\": {\\\\n      \\\\\"id\\\\\": 277903433,\\\\n      \\\\\"node_id\\\\\": \\\\\"MDEwOlJlcG9zaXRvcnkyNzc5MDM0MzM=\\\\\",\\\\n      \\\\\"name\\\\\": \\\\\"aws-c-s3\\\\\",\\\\n      \\\\\"full_name\\\\\": \\\\\"awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"private\\\\\": false,\\\\n      \\\\\"owner\\\\\": {\\\\n        \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n        \\\\\"id\\\\\": 3299148,\\\\n        \\\\\"node_id\\\\\": \\\\\"MDEyOk9yZ2FuaXphdGlvbjMyOTkxNDg=\\\\\",\\\\n        \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n        \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n        \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\",\\\\n        \\\\\"type\\\\\": \\\\\"Organization\\\\\"\\\\n      },\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"description\\\\\": \\\\\"C99 library implementation for communicating with the S3 service, designed for maximizing throughput on high bandwidth EC2 instances.\\\\\",\\\\n      \\\\\"fork\\\\\": false,\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"created_at\\\\\": \\\\\"2020-07-07T19:21:45Z\\\\\",\\\\n      \\\\\"updated_at\\\\\": \\\\\"2025-05-15T17:15:47Z\\\\\",\\\\n      \\\\\"pushed_at\\\\\": \\\\\"2025-05-15T17:16:08Z\\\\\",\\\\n      \\\\\"git_url\\\\\": \\\\\"git://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"ssh_url\\\\\": \\\\\"git@github.com:awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"clone_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"default_branch\\\\\": \\\\\"main\\\\\"\\\\n    }\\\\n  },\\\\n  \\\\\"base\\\\\": {\\\\n    \\\\\"label\\\\\": \\\\\"awslabs:main\\\\\",\\\\n    \\\\\"ref\\\\\": \\\\\"main\\\\\",\\\\n    \\\\\"sha\\\\\": \\\\\"7d2d4b3070109c882ff78e8719f60597c7ba0472\\\\\",\\\\n    \\\\\"user\\\\\": {\\\\n      \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n      \\\\\"id\\\\\": 3299148,\\\\n      \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\"\\\\n    },\\\\n    \\\\\"repo\\\\\": {\\\\n      \\\\\"id\\\\\": 277903433,\\\\n      \\\\\"node_id\\\\\": \\\\\"MDEwOlJlcG9zaXRvcnkyNzc5MDM0MzM=\\\\\",\\\\n      \\\\\"name\\\\\": \\\\\"aws-c-s3\\\\\",\\\\n      \\\\\"full_name\\\\\": \\\\\"awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"private\\\\\": false,\\\\n      \\\\\"owner\\\\\": {\\\\n        \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n        \\\\\"id\\\\\": 3299148,\\\\n        \\\\\"node_id\\\\\": \\\\\"MDEyOk9yZ2FuaXphdGlvbjMyOTkxNDg=\\\\\",\\\\n        \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n        \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n        \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\",\\\\n        \\\\\"type\\\\\": \\\\\"Organization\\\\\"\\\\n      },\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"description\\\\\": \\\\\"C99 library implementation for communicating with the S3 service, designed for maximizing throughput on high bandwidth EC2 instances.\\\\\",\\\\n      \\\\\"fork\\\\\": false,\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"created_at\\\\\": \\\\\"2020-07-07T19:21:45Z\\\\\",\\\\n      \\\\\"updated_at\\\\\": \\\\\"2025-05-15T17:15:47Z\\\\\",\\\\n      \\\\\"pushed_at\\\\\": \\\\\"2025-05-15T17:16:08Z\\\\\",\\\\n      \\\\\"git_url\\\\\": \\\\\"git://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"ssh_url\\\\\": \\\\\"git@github.com:awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"clone_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"default_branch\\\\\": \\\\\"main\\\\\"\\\\n    }\\\\n  }\\\\n}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now let me check what files were changed in this pull request:\"},{\"type\":\"tool_use\",\"name\":\"github-get_pull_request_files\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"pull_number\":519},\"id\":\"toolu_bdrk_016LDPeJmPUu8eopS7eXzaNu\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_016LDPeJmPUu8eopS7eXzaNu\",\"content\":[{\"type\":\"text\",\"text\":\"[\\\\n  {\\\\n    \\\\\"sha\\\\\": \\\\\"dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n    \\\\\"filename\\\\\": \\\\\"tests/s3_data_plane_tests.c\\\\\",\\\\n    \\\\\"status\\\\\": \\\\\"modified\\\\\",\\\\n    \\\\\"additions\\\\\": 49,\\\\n    \\\\\"deletions\\\\\": 0,\\\\n    \\\\\"changes\\\\\": 49,\\\\n    \\\\\"blob_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6/tests%2Fs3_data_plane_tests.c\\\\\",\\\\n    \\\\\"raw_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/raw/e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6/tests%2Fs3_data_plane_tests.c\\\\\",\\\\n    \\\\\"contents_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests%2Fs3_data_plane_tests.c?ref=e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6\\\\\",\\\\n    \\\\\"patch\\\\\": \\\\\"@@ -8114,3 +8114,52 @@ static int s_test_s3_default_get_without_content_length(struct aws_allocator *al\\\\\\\\n \\\\\\\\n     return AWS_OP_SUCCESS;\\\\\\\\n }\\\\\\\\n+\\\\\\\\n+struct aws_string *test_helper(struct aws_allocator *allocator) {\\\\\\\\n+    struct aws_string *host_name =\\\\\\\\n+        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n+    return host_name;\\\\\\\\n+}\\\\\\\\n+\\\\\\\\n+AWS_TEST_CASE(test_s3_default_get, aws_test_s3_default_get)\\\\\\\\n+static int aws_test_s3_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n+    (void)ctx;\\\\\\\\n+\\\\\\\\n+    struct aws_s3_tester tester;\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n+\\\\\\\\n+    struct aws_s3_client *client = NULL;\\\\\\\\n+    struct aws_s3_tester_client_options client_options;\\\\\\\\n+    AWS_ZERO_STRUCT(client_options);\\\\\\\\n+\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n+    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n+    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n+\\\\\\\\n+    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n+    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n+\\\\\\\\n+    struct aws_string *hsot_name = test_helper(allocator);\\\\\\\\n+\\\\\\\\n+    /* Put together a simple S3 Get Object request. */\\\\\\\\n+    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n+        allocator, aws_byte_cursor_from_string(hsot_name), g_pre_existing_object_1MB);\\\\\\\\n+\\\\\\\\n+    struct aws_s3_meta_request_options options;\\\\\\\\n+    AWS_ZERO_STRUCT(options);\\\\\\\\n+    /* Send default type */\\\\\\\\n+    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n+    options.message = message;\\\\\\\\n+    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n+\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n+        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n+\\\\\\\\n+    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n+    aws_http_message_release(message);\\\\\\\\n+    aws_s3_client_release(client);\\\\\\\\n+    aws_s3_tester_clean_up(&tester);\\\\\\\\n+\\\\\\\\n+    return AWS_OP_SUCCESS;\\\\\\\\n+}\\\\\"\\\\n  }\\\\n]\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now let me get the style guide that should be followed for the comments:\"},{\"type\":\"tool_use\",\"name\":\"filesystem-read_file\",\"input\":{\"path\":\"/Users/dengket/project/hackthon/fast-agent/crt_c_reviewer/summarization/comments_styles.md\"},\"id\":\"toolu_bdrk_013StBzGMny5xAQncpKRGHrv\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_013StBzGMny5xAQncpKRGHrv\",\"content\":[{\"type\":\"text\",\"text\":\"# Effective Code Review Comment Guidelines\\\\n\\\\nBased on an analysis of multiple GitHub Pull Request reviews, this document summarizes key patterns and best practices for writing effective code review comments.\\\\n\\\\n## General Principles\\\\n\\\\n### 1. Comment Classification\\\\n\\\\n* **Use clear prefixes to indicate severity:**\\\\n  + `trivial:` - Minor issues that should be fixed but don\\'t block approval\\\\n  + `debatable:` or `extremely debatable:` - Suggestions open to discussion\\\\n  + `nit:` - Extremely minor stylistic preferences\\\\n  + `important:` - Issues that should be addressed before merging\\\\n  + `blocking:` - Critical issues that must be resolved\\\\n\\\\n* **Be explicit about expectations:**\\\\n  + Distinguish between mandatory changes and optional suggestions\\\\n  + Indicate when comments are informational rather than requesting changes\\\\n\\\\n### 2. Comment Structure\\\\n\\\\n* **Be specific and actionable:**\\\\n  + Refer to specific lines or sections of code\\\\n  + Explain both what the issue is and why it matters\\\\n  + Provide concrete solutions when possible\\\\n\\\\n* **Use GitHub suggestion blocks for direct code changes:**\\\\n  \\\\n\\\\n```\\\\n  ```suggestion\\\\n  actual code change goes here\\\\n  ```\\\\n\\\\n  \\\\n\\\\n```\\\\n\\\\n- **Group related issues together:**\\\\n  - Number multiple points for clarity\\\\n  - Address similar issues in a single comment when possible\\\\n\\\\n- **Provide context:**\\\\n  - Link to relevant documentation, PRs, or issues\\\\n  - Reference cross-repository standards when applicable\\\\n  - Explain reasoning behind suggestions, not just what to change\\\\n\\\\n### 3. Comment Scope\\\\n\\\\n- **Focus on the right level of detail:**\\\\n  - For simple PRs: Brief approvals may be sufficient\\\\n  - For complex PRs: Detailed, organized feedback is necessary\\\\n\\\\n- **Consider multiple aspects of code quality:**\\\\n  - Functional correctness\\\\n  - Error handling and edge cases\\\\n  - Performance implications\\\\n  - Security considerations\\\\n  - Consistency with existing patterns\\\\n  - Documentation and readability\\\\n  - Cross-platform compatibility\\\\n  - API design and usability\\\\n\\\\n## Technical Focus Areas\\\\n\\\\n### 1. Code Architecture and Design\\\\n\\\\n- **API Usability:**\\\\n  - Consider the developer experience of using the API\\\\n  - Question potentially confusing or redundant API requirements\\\\n  - Think about cross-language compatibility\\\\n\\\\n- **Error Handling:**\\\\n  - Verify proper cleanup in error cases\\\\n  - Ensure appropriate error propagation\\\\n  - Check for consistent error handling patterns\\\\n  - In C code, prefer unified error paths with consolidated cleanup\\\\n\\\\n- **Consistency:**\\\\n  - Flag inconsistent naming conventions\\\\n  - Highlight deviations from established patterns\\\\n  - Ensure consistency across related repositories\\\\n\\\\n### 2. Code Style and Readability\\\\n\\\\n- **Prioritize clear organization:**\\\\n  - Suggest clearer code structure when logic is hard to follow\\\\n  - Flag complex conditionals that could be simplified\\\\n  - Recommend extracting complex logic into well-named helper functions\\\\n\\\\n- **Comment on documentation:**\\\\n  - Ensure comments accurately describe behavior\\\\n  - Request documentation for parameters with specific usage requirements\\\\n  - Verify public API documentation clarity\\\\n\\\\n- **Focus on maintainability:**\\\\n  - Consider how code might evolve in the future\\\\n  - Identify fragile patterns that could break with future changes\\\\n  - Suggest explicit guards against potential future bugs\\\\n\\\\n### 3. Cross-Team and Ecosystem Considerations\\\\n\\\\n- **Coordinate across teams:**\\\\n  - Flag changes that might affect other teams or services\\\\n  - Recommend cross-team communication when necessary\\\\n\\\\n- **Verify ecosystem consistency:**\\\\n  - Check if behavior matches related SDKs or libraries\\\\n  - Confirm conformance to broader project standards\\\\n\\\\n## Review Process\\\\n\\\\n### 1. Reviewing Approach\\\\n\\\\n- **Progressive reviews:**\\\\n  - Start with critical issues and architectural concerns\\\\n  - Follow up on remaining issues after major concerns are addressed\\\\n  - Provide final approval once all necessary changes are made\\\\n\\\\n- **Approval comments:**\\\\n  - Use \\\\\"fix & ship\\\\\" for PRs with only minor issues\\\\n  - Include verification steps if needed before merging\\\\n  - Acknowledge when previous feedback has been addressed\\\\n\\\\n### 2. Review Tone\\\\n\\\\n- **Be direct but constructive:**\\\\n  - Focus on the code, not the person\\\\n  - Frame feedback as improvements rather than criticisms\\\\n  - Use a professional, collaborative tone\\\\n\\\\n- **Acknowledge good work:**\\\\n  - Provide positive feedback on well-implemented features\\\\n  - Recognize when authors have addressed previous feedback well\\\\n  - Use phrases like \\\\\"nice job\\\\\" or \\\\\"this looks good\\\\\" where appropriate\\\\n\\\\n- **Balance criticism with encouragement:**\\\\n  - Point out both strengths and areas for improvement\\\\n  - Recognize the effort that went into the implementation\\\\n\\\\n## Comment Examples by Category\\\\n\\\\n### Effective Trivial Comments\\\\n\\\\n```\\\\n\\\\ntrivial: undoing needless changes to whitespace\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\ntrivial: it\\'s weird to use the `_10MB` and then upload 5MB\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\ntrivial: I found this if-statement confusing, and the helper function that did different things depending on how it\\'s called...\\\\n\\\\n```\\\\n\\\\n### Effective Technical Suggestions\\\\n\\\\n```\\\\n\\\\nif there\\'s an error, we need to cleanup out_checksum\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nSo, if users already added a checksum header, they ALSO need to set this enum?\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nInstead of the `on_error:` label sharing 90% the same cleanup code as `s_s3_client_finish_destroy_default()` , have them share code\\\\n\\\\n```\\\\n\\\\n### Effective Process Comments\\\\n\\\\n```\\\\n\\\\nI\\'d advise checking this branch from aws-crt-cpp, and making sure it all works nicely, before merging\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nChecked the C++ SDK and Java SDK and they also retry on TLS errors.\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nneed to coordinate with python teams on this...\\\\n```\\\\n\\\\n### Silent Approvals (When Appropriate)\\\\n\\\\nSilent approvals (no comments, just approval) are appropriate for:\\\\n* Simple, straightforward changes\\\\n* Well-understood code\\\\n* Follow-up to previous discussions\\\\n* Self-explanatory code\\\\n* Trivial fixes\\\\n* When there\\'s an established trust relationship between reviewer and author\\\\n\\\\n## Special Cases\\\\n\\\\n### 1. Automated/Routine Changes\\\\n\\\\n* **Minimize comments for routine updates:**\\\\n  + For automated changes or version bumps, simple approvals may be sufficient\\\\n  + Focus comments on any unexpected deviations from expected patterns\\\\n\\\\n### 2. Cross-Repository Changes\\\\n\\\\n* **Consider broader impacts:**\\\\n  + For changes affecting multiple repositories, test across all affected codebases\\\\n  + Verify consistency with related repositories\\' standards\\\\n\\\\n### 3. Documentation Changes\\\\n\\\\n* **Focus on accuracy and clarity:**\\\\n  + Ensure documentation correctly describes behavior\\\\n  + Verify examples work as described\\\\n  + Check for consistent formatting and terminology\\\\n\\\\n## Conclusion\\\\n\\\\nEffective code review comments are specific, actionable, appropriately categorized, and delivered in a constructive tone. They focus on technical accuracy while maintaining readability and consistency with project standards. The level of detail should match the complexity of the change, ranging from brief approvals for simple changes to detailed, structured feedback for complex modifications.\\\\n\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Let me create the necessary directory for the comments:\"},{\"type\":\"tool_use\",\"name\":\"filesystem-create_directory\",\"input\":{\"path\":\"./new_comments_s3_PR519\"},\"id\":\"toolu_bdrk_01WirLUdVpvzPdbxck6f6kdM\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01WirLUdVpvzPdbxck6f6kdM\",\"content\":[{\"type\":\"text\",\"text\":\"Successfully created directory ./new_comments_s3_PR519\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now let\\'s get the content of the file that was modified in the PR to analyze it thoroughly:\"},{\"type\":\"tool_use\",\"name\":\"github-get_file_contents\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"path\":\"tests/s3_data_plane_tests.c\",\"branch\":\"dummy-delete-me\"},\"id\":\"toolu_bdrk_01AGLqYtzNwxd5DN1Su8SKAZ\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01AGLqYtzNwxd5DN1Su8SKAZ\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\n  \\\\\"name\\\\\": \\\\\"s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"path\\\\\": \\\\\"tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"sha\\\\\": \\\\\"dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n  \\\\\"size\\\\\": 319574,\\\\n  \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests/s3_data_plane_tests.c?ref=dummy-delete-me\\\\\",\\\\n  \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"git_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/git/blobs/dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n  \\\\\"download_url\\\\\": \\\\\"https://raw.githubusercontent.com/awslabs/aws-c-s3/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"type\\\\\": \\\\\"file\\\\\",\\\\n  \\\\\"content\\\\\": \\\\\"/**\\\\\\\\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\\\\\\\\n * SPDX-License-Identifier: Apache-2.0.\\\\\\\\n */\\\\\\\\n\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_checksums.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\"\\\\\\\\n#include <aws/common/byte_buf.h>\\\\\\\\n#include <aws/common/clock.h>\\\\\\\\n#include <aws/common/common.h>\\\\\\\\n#include <aws/common/encoding.h>\\\\\\\\n#include <aws/common/environment.h>\\\\\\\\n#include <aws/common/ref_count.h>\\\\\\\\n#include <aws/http/request_response.h>\\\\\\\\n#include <aws/http/status_code.h>\\\\\\\\n#include <aws/io/channel_bootstrap.h>\\\\\\\\n#include <aws/io/event_loop.h>\\\\\\\\n#include <aws/io/host_resolver.h>\\\\\\\\n#include <aws/io/stream.h>\\\\\\\\n#include <aws/io/tls_channel_handler.h>\\\\\\\\n#include <aws/io/uri.h>\\\\\\\\n#include <aws/testing/aws_test_harness.h>\\\\\\\\n#include <aws/testing/stream_tester.h>\\\\\\\\n#include <inttypes.h>\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_create_destroy, s_test_s3_client_create_destroy)\\\\\\\\nstatic int s_test_s3_client_create_destroy(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_create_error, s_test_s3_client_create_error)\\\\\\\\nstatic int s_test_s3_client_create_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    struct aws_http_proxy_options proxy_options = {\\\\\\\\n        .connection_type = AWS_HPCT_HTTP_LEGACY,\\\\\\\\n        .host = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"localhost\\\\\\\\\\\\\"),\\\\\\\\n        .port = 8899,\\\\\\\\n    };\\\\\\\\n    client_config.proxy_options = &proxy_options;\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_client_create_error_with_invalid_memory_limit_config,\\\\\\\\n    s_test_s3_client_create_error_with_invalid_memory_limit_config)\\\\\\\\nstatic int s_test_s3_client_create_error_with_invalid_memory_limit_config(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    client_config.memory_limit_in_bytes = 100;\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n    client_config.memory_limit_in_bytes = GB_TO_BYTES(1);\\\\\\\\n    client_config.max_part_size = GB_TO_BYTES(2);\\\\\\\\n    client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_client_create_error_with_invalid_network_interface,\\\\\\\\n    s_test_s3_client_create_error_with_invalid_network_interface)\\\\\\\\nstatic int s_test_s3_client_create_error_with_invalid_network_interface(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor *interface_names_array = aws_mem_calloc(allocator, 1, sizeof(struct aws_byte_cursor));\\\\\\\\n    interface_names_array[0] = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"invalid-nic\\\\\\\\\\\\\");\\\\\\\\n    client_config.network_interface_names_array = interface_names_array;\\\\\\\\n    client_config.num_network_interface_names = 1;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_mem_release(allocator, interface_names_array);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_monitoring_options_override, s_test_s3_client_monitoring_options_override)\\\\\\\\nstatic int s_test_s3_client_monitoring_options_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_http_connection_monitoring_options monitoring_options = {.minimum_throughput_bytes_per_second = 3000};\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.monitoring_options = &monitoring_options};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        client->monitoring_options.minimum_throughput_bytes_per_second ==\\\\\\\\n        client_config.monitoring_options->minimum_throughput_bytes_per_second);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_proxy_ev_settings_override, s_test_s3_client_proxy_ev_settings_override)\\\\\\\\nstatic int s_test_s3_client_proxy_ev_settings_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_tls_connection_options tls_conn_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_conn_options);\\\\\\\\n\\\\\\\\n    struct proxy_env_var_settings proxy_ev_settings = {\\\\\\\\n        .env_var_type = AWS_HPEV_ENABLE,\\\\\\\\n        .tls_options = &tls_conn_options,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.proxy_ev_settings = &proxy_ev_settings};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->proxy_ev_settings->env_var_type == client_config.proxy_ev_settings->env_var_type);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_tcp_keep_alive_options_override, s_test_s3_client_tcp_keep_alive_options_override)\\\\\\\\nstatic int s_test_s3_client_tcp_keep_alive_options_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tcp_keep_alive_options keep_alive_options = {.keep_alive_interval_sec = 20};\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.tcp_keep_alive_options = &keep_alive_options};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        client->tcp_keep_alive_options->keep_alive_interval_sec ==\\\\\\\\n        client_config.tcp_keep_alive_options->keep_alive_interval_sec);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_max_active_connections_override, s_test_s3_client_max_active_connections_override)\\\\\\\\nstatic int s_test_s3_client_max_active_connections_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .max_active_connections_override = 10,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->max_active_connections_override == client_config.max_active_connections_override);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_byo_crypto_no_options, s_test_s3_client_byo_crypto_no_options)\\\\\\\\nstatic int s_test_s3_client_byo_crypto_no_options(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .tls_mode = AWS_MR_TLS_ENABLED,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_last_error() == AWS_ERROR_INVALID_ARGUMENT);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_byo_crypto_with_options, s_test_s3_client_byo_crypto_with_options)\\\\\\\\nstatic int s_test_s3_client_byo_crypto_with_options(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_conn_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_conn_options);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n    client_config.tls_connection_options = &tls_conn_options;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nsize_t s_test_max_active_connections_host_count = 0;\\\\\\\\n\\\\\\\\nsize_t s_test_get_max_active_connections_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    return s_test_max_active_connections_host_count;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_get_max_active_connections, s_test_s3_client_get_max_active_connections)\\\\\\\\nstatic int s_test_s3_client_get_max_active_connections(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)allocator;\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_client_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_client_bootstrap);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    *((uint32_t *)&mock_client->max_active_connections_override) = 0;\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = 100;\\\\\\\\n    mock_client->client_bootstrap = &mock_client_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_get_max_active_connections_host_address_count;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_requests[AWS_S3_META_REQUEST_TYPE_MAX];\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n        /* Setup test data. */\\\\\\\\n        mock_meta_requests[i] = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n        mock_meta_requests[i]->type = i;\\\\\\\\n        mock_meta_requests[i]->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    s_test_max_active_connections_host_count = 2;\\\\\\\\n\\\\\\\\n    /* Behavior should not be affected by max_active_connections_override since it is 0, and should just be in relation\\\\\\\\n     * to ideal-connection-count. */\\\\\\\\n    {\\\\\\\\n        ASSERT_TRUE(aws_s3_client_get_max_active_connections(mock_client, NULL) == mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->ideal_connection_count);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Max active connections override should now cap the calculated amount of active connections. */\\\\\\\\n    {\\\\\\\\n        *((uint32_t *)&mock_client->max_active_connections_override) = 3;\\\\\\\\n\\\\\\\\n        /* Assert that override is low enough to have effect */\\\\\\\\n        ASSERT_TRUE(mock_client->max_active_connections_override < mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(\\\\\\\\n            aws_s3_client_get_max_active_connections(mock_client, NULL) ==\\\\\\\\n            mock_client->max_active_connections_override);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(mock_client->max_active_connections_override < mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->max_active_connections_override);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Max active connections override should be ignored since the calculated amount of max connections is less. */\\\\\\\\n    {\\\\\\\\n        *((uint32_t *)&mock_client->max_active_connections_override) = 100000;\\\\\\\\n\\\\\\\\n        /* Assert that override is NOT low enough to have effect */\\\\\\\\n        ASSERT_TRUE(mock_client->max_active_connections_override > mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(aws_s3_client_get_max_active_connections(mock_client, NULL) == mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(mock_client->max_active_connections_override > mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->ideal_connection_count);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n        mock_meta_requests[i] = aws_s3_meta_request_release(mock_meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_request_create_destroy, s_test_s3_request_create_destroy)\\\\\\\\nstatic int s_test_s3_request_create_destroy(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const int request_tag = 1234;\\\\\\\\n    const enum aws_s3_request_type request_type = AWS_S3_REQUEST_TYPE_LIST_PARTS;\\\\\\\\n    const uint32_t part_number = 5678;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n    meta_request->client = aws_s3_client_acquire(client);\\\\\\\\n\\\\\\\\n    struct aws_http_message *request_message = aws_s3_tester_dummy_http_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(request_message != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n        meta_request, request_tag, request_type, part_number, AWS_S3_REQUEST_FLAG_RECORD_RESPONSE_HEADERS);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->meta_request == meta_request);\\\\\\\\n    ASSERT_TRUE(request->part_number == part_number);\\\\\\\\n    ASSERT_TRUE(request->request_tag == request_tag);\\\\\\\\n    ASSERT_TRUE(request->request_type == request_type);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"ListParts\\\\\\\\\\\\\", aws_string_c_str(request->operation_name));\\\\\\\\n    ASSERT_TRUE(request->record_response_headers == true);\\\\\\\\n\\\\\\\\n    aws_s3_request_setup_send_data(request, request_message);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->send_data.message != NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers == NULL);\\\\\\\\n\\\\\\\\n    request->send_data.response_headers = aws_http_headers_new(allocator);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers != NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.metrics != NULL);\\\\\\\\n    request->send_data.metrics = aws_s3_request_metrics_release(request->send_data.metrics);\\\\\\\\n\\\\\\\\n    aws_s3_request_clean_up_send_data(request);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->send_data.message == NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers == NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_status == 0);\\\\\\\\n\\\\\\\\n    aws_s3_request_release(request);\\\\\\\\n    aws_http_message_release(request_message);\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct s3_test_body_streaming_user_data {\\\\\\\\n    struct aws_s3_tester *tester;\\\\\\\\n    struct aws_allocator *allocator;\\\\\\\\n    uint64_t expected_range_start;\\\\\\\\n    uint64_t received_body_size;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic int s_s3_meta_request_test_body_streaming_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)body;\\\\\\\\n    (void)range_start;\\\\\\\\n\\\\\\\\n    struct s3_test_body_streaming_user_data *body_streaming_user_data = user_data;\\\\\\\\n\\\\\\\\n    body_streaming_user_data->received_body_size += body->len;\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_streaming_user_data->expected_range_start == range_start);\\\\\\\\n    body_streaming_user_data->expected_range_start += body->len;\\\\\\\\n\\\\\\\\n    aws_s3_tester_inc_counter1(body_streaming_user_data->tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test the meta request body streaming functionality. */\\\\\\\\nAWS_TEST_CASE(test_s3_meta_request_body_streaming, s_test_s3_meta_request_body_streaming)\\\\\\\\nstatic int s_test_s3_meta_request_body_streaming(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const uint32_t part_range0_start = 1;\\\\\\\\n    const uint32_t part_range0_end = part_range0_start + 4;\\\\\\\\n\\\\\\\\n    const uint32_t part_range1_start = part_range0_end + 1;\\\\\\\\n    const uint32_t part_range1_end = part_range1_start + 4;\\\\\\\\n\\\\\\\\n    const size_t request_response_body_size = 16;\\\\\\\\n\\\\\\\\n    const uint64_t total_object_size = (uint64_t)part_range1_end * request_response_body_size;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf response_body_source_buffer;\\\\\\\\n    aws_byte_buf_init(&response_body_source_buffer, allocator, request_response_body_size);\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor test_byte_cursor = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"0\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < request_response_body_size; ++i) {\\\\\\\\n        aws_byte_buf_append(&response_body_source_buffer, &test_byte_cursor);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct s3_test_body_streaming_user_data body_streaming_user_data = {\\\\\\\\n        .tester = &tester,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_event_loop_group *event_loop_group = aws_event_loop_group_new_default(allocator, 0, NULL);\\\\\\\\n    meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    meta_request->user_data = &body_streaming_user_data;\\\\\\\\n    *((size_t *)&meta_request->part_size) = request_response_body_size;\\\\\\\\n    meta_request->body_callback = s_s3_meta_request_test_body_streaming_callback;\\\\\\\\n    meta_request->io_event_loop = aws_event_loop_group_get_next_loop(event_loop_group);\\\\\\\\n\\\\\\\\n    /* Queue the first range of parts in order. Each part should be flushed one-by-one. */\\\\\\\\n    {\\\\\\\\n        for (uint32_t part_number = part_range0_start; part_number <= part_range0_end; ++part_number) {\\\\\\\\n            struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n                meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_number, 0 /*flags*/);\\\\\\\\n\\\\\\\\n            aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n                0ULL,\\\\\\\\n                total_object_size - 1,\\\\\\\\n                request_response_body_size /*part_size*/,\\\\\\\\n                (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n                part_number,\\\\\\\\n                &request->part_range_start,\\\\\\\\n                &request->part_range_end);\\\\\\\\n\\\\\\\\n            aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n            aws_s3_tester_set_counter1_desired(&tester, part_number);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n            ASSERT_TRUE(aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == 0);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_tester_wait_for_counters(&tester);\\\\\\\\n\\\\\\\\n            aws_s3_request_release(request);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_set_counter1_desired(&tester, part_range1_end);\\\\\\\\n\\\\\\\\n    /* Queue parts for second range, but skip over the first part.*/\\\\\\\\n    {\\\\\\\\n        uint32_t num_parts_queued = 0;\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(part_range1_start != part_range1_end);\\\\\\\\n\\\\\\\\n        for (uint32_t part_number = part_range1_start + 1; part_number <= part_range1_end; ++part_number) {\\\\\\\\n            struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n                meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_number, 0 /*flags*/);\\\\\\\\n\\\\\\\\n            aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n                0ULL,\\\\\\\\n                total_object_size - 1,\\\\\\\\n                request_response_body_size /*part_size*/,\\\\\\\\n                (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n                part_number,\\\\\\\\n                &request->part_range_start,\\\\\\\\n                &request->part_range_end);\\\\\\\\n\\\\\\\\n            aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n            aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n            aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_request_release(request);\\\\\\\\n            ++num_parts_queued;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        ASSERT_TRUE(\\\\\\\\n            aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == num_parts_queued);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Stream the last part of the body, which should flush the priority queue. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n            meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_range1_start, 0 /*flags*/);\\\\\\\\n\\\\\\\\n        aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n            0ULL,\\\\\\\\n            total_object_size - 1,\\\\\\\\n            request_response_body_size /*part_size*/,\\\\\\\\n            (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n            part_range1_start,\\\\\\\\n            &request->part_range_start,\\\\\\\\n            &request->part_range_end);\\\\\\\\n\\\\\\\\n        aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        ASSERT_TRUE(aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == 0);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n        aws_s3_request_release(request);\\\\\\\\n\\\\\\\\n        aws_s3_tester_wait_for_counters(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_streaming_user_data.received_body_size == (request_response_body_size * part_range1_end));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_event_loop_group_release(event_loop_group);\\\\\\\\n    aws_byte_buf_clean_up(&response_body_source_buffer);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test aws_s3_client_queue_requests_threaded and aws_s3_client_dequeue_request_threaded */\\\\\\\\nAWS_TEST_CASE(test_s3_client_queue_requests, s_test_s3_client_queue_requests)\\\\\\\\nstatic int s_test_s3_client_queue_requests(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *pivot_request = aws_s3_request_new(mock_meta_request, 0, 0, 0, 0);\\\\\\\\n\\\\\\\\n    struct aws_linked_list pivot_request_list;\\\\\\\\n    aws_linked_list_init(&pivot_request_list);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *requests[] = {\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    const uint32_t num_requests = AWS_ARRAY_SIZE(requests);\\\\\\\\n\\\\\\\\n    struct aws_linked_list request_list;\\\\\\\\n    aws_linked_list_init(&request_list);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        aws_linked_list_push_back(&pivot_request_list, &pivot_request->node);\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &pivot_request_list, false);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 1);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n            aws_linked_list_push_back(&request_list, &requests[i]->node);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Move the requests to the back of the queue. */\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &request_list, false);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&request_list));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests + 1));\\\\\\\\n    ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        /* The first request should be the pivot request since the other requests were pushed to the back. */\\\\\\\\n        struct aws_s3_request *first_request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n        ASSERT_TRUE(first_request == pivot_request);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == num_requests);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        struct aws_s3_request *request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(request == requests[i]);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests - (i + 1)));\\\\\\\\n\\\\\\\\n        if (i < num_requests - 1) {\\\\\\\\n            ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        aws_linked_list_push_back(&pivot_request_list, &pivot_request->node);\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &pivot_request_list, false);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 1);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n            aws_linked_list_push_back(&request_list, &requests[i]->node);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Move the requests to the front of the queue. */\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &request_list, true);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&request_list));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests + 1));\\\\\\\\n    ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        struct aws_s3_request *request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(request == requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        /* The last request should be the pivot request since the other requests were pushed to the front. */\\\\\\\\n        struct aws_s3_request *last_request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n        ASSERT_TRUE(last_request == pivot_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        aws_s3_request_release(requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_request_release(pivot_request);\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct test_work_meta_request_update_user_data {\\\\\\\\n    bool has_work_remaining;\\\\\\\\n    uint32_t num_prepares;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic bool s_s3_test_work_meta_request_update(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    uint32_t flags,\\\\\\\\n    struct aws_s3_request **out_request) {\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data *user_data = meta_request->user_data;\\\\\\\\n\\\\\\\\n    if (out_request) {\\\\\\\\n        if (user_data->has_work_remaining) {\\\\\\\\n            *out_request = aws_s3_request_new(meta_request, 0, 0, 0, 0);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return user_data->has_work_remaining;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_work_meta_request_schedule_prepare_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    aws_s3_meta_request_prepare_request_callback_fn *callback,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)request;\\\\\\\\n    (void)callback;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data *test_user_data = meta_request->user_data;\\\\\\\\n    ++test_user_data->num_prepares;\\\\\\\\n\\\\\\\\n    aws_s3_request_release(request);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic size_t s_test_s3_update_meta_request_trigger_prepare_host_address_count = 0;\\\\\\\\n\\\\\\\\nstatic size_t s_test_s3_update_meta_request_trigger_prepare_get_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n    return s_test_s3_update_meta_request_trigger_prepare_host_address_count;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_validate_prepared_requests(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    size_t expected_num_being_prepared,\\\\\\\\n    struct aws_s3_meta_request *meta_request_with_work,\\\\\\\\n    struct aws_s3_meta_request *meta_request_without_work) {\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->threaded_data.request_queue_size == 0);\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&client->threaded_data.request_queue));\\\\\\\\n    ASSERT_TRUE(client->threaded_data.num_requests_being_prepared == expected_num_being_prepared);\\\\\\\\n    ASSERT_TRUE(aws_atomic_load_int(&client->stats.num_requests_in_flight) == expected_num_being_prepared);\\\\\\\\n\\\\\\\\n    uint32_t num_meta_requests_in_list = 0;\\\\\\\\n    bool meta_request_with_work_found = false;\\\\\\\\n\\\\\\\\n    for (struct aws_linked_list_node *node = aws_linked_list_begin(&client->threaded_data.meta_requests);\\\\\\\\n         node != aws_linked_list_end(&client->threaded_data.meta_requests);\\\\\\\\n         node = aws_linked_list_next(node)) {\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request *meta_request =\\\\\\\\n            AWS_CONTAINER_OF(node, struct aws_s3_meta_request, client_process_work_threaded_data);\\\\\\\\n\\\\\\\\n        if (meta_request == meta_request_with_work) {\\\\\\\\n            meta_request_with_work_found = true;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_request != meta_request_without_work);\\\\\\\\n\\\\\\\\n        ++num_meta_requests_in_list;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_with_work_found);\\\\\\\\n    ASSERT_TRUE(num_meta_requests_in_list == 1);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the client will prepare requests correctly. */\\\\\\\\nAWS_TEST_CASE(test_s3_update_meta_requests_trigger_prepare, s_test_s3_update_meta_requests_trigger_prepare)\\\\\\\\nstatic int s_test_s3_update_meta_requests_trigger_prepare(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_bootstrap);\\\\\\\\n\\\\\\\\n    const uint32_t ideal_connection_count = 100;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    mock_client->client_bootstrap = &mock_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_s3_update_meta_request_trigger_prepare_get_host_address_count;\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = ideal_connection_count;\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.meta_requests);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request_without_work = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request_without_work->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    mock_meta_request_without_work->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data mock_meta_request_without_work_data = {\\\\\\\\n        .has_work_remaining = false,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    mock_meta_request_without_work->user_data = &mock_meta_request_without_work_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *meta_request_without_work_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request_without_work, NULL);\\\\\\\\n    meta_request_without_work_vtable->update = s_s3_test_work_meta_request_update;\\\\\\\\n    meta_request_without_work_vtable->schedule_prepare_request = s_s3_test_work_meta_request_schedule_prepare_request;\\\\\\\\n\\\\\\\\n    /* Intentionally push this meta request first to test that it\\'s properly removed from the list. */\\\\\\\\n    aws_linked_list_push_back(\\\\\\\\n        &mock_client->threaded_data.meta_requests,\\\\\\\\n        &mock_meta_request_without_work->client_process_work_threaded_data.node);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_acquire(mock_meta_request_without_work);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request_with_work = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request_with_work->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    struct test_work_meta_request_update_user_data mock_meta_request_with_work_data = {\\\\\\\\n        .has_work_remaining = true,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    mock_meta_request_with_work->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n    mock_meta_request_with_work->user_data = &mock_meta_request_with_work_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *mock_meta_request_with_work_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request_with_work, NULL);\\\\\\\\n    mock_meta_request_with_work_vtable->update = s_s3_test_work_meta_request_update;\\\\\\\\n    mock_meta_request_with_work_vtable->schedule_prepare_request = s_s3_test_work_meta_request_schedule_prepare_request;\\\\\\\\n\\\\\\\\n    aws_linked_list_push_back(\\\\\\\\n        &mock_client->threaded_data.meta_requests,\\\\\\\\n        &mock_meta_request_with_work->client_process_work_threaded_data.node);\\\\\\\\n    aws_s3_meta_request_acquire(mock_meta_request_with_work);\\\\\\\\n\\\\\\\\n    /* With no known addresses, the amount of requests that can be prepared should be lower. */\\\\\\\\n    {\\\\\\\\n        s_test_s3_update_meta_request_trigger_prepare_host_address_count = 0;\\\\\\\\n        aws_s3_client_update_meta_requests_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(s_validate_prepared_requests(\\\\\\\\n            mock_client, g_min_num_connections, mock_meta_request_with_work, mock_meta_request_without_work));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* When the number of known addresses is 1+, the max number of requests should be reached. */\\\\\\\\n    {\\\\\\\\n        const uint32_t max_requests_prepare = aws_s3_client_get_max_requests_prepare(mock_client);\\\\\\\\n\\\\\\\\n        s_test_s3_update_meta_request_trigger_prepare_host_address_count = 1;\\\\\\\\n        aws_s3_client_update_meta_requests_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(s_validate_prepared_requests(\\\\\\\\n            mock_client, max_requests_prepare, mock_meta_request_with_work, mock_meta_request_without_work));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    while (!aws_linked_list_empty(&mock_client->threaded_data.meta_requests)) {\\\\\\\\n        struct aws_linked_list_node *meta_request_node =\\\\\\\\n            aws_linked_list_pop_front(&mock_client->threaded_data.meta_requests);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request *meta_request =\\\\\\\\n            AWS_CONTAINER_OF(meta_request_node, struct aws_s3_meta_request, client_process_work_threaded_data);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_release(meta_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request_without_work);\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request_with_work);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct s3_test_update_connections_finish_result_user_data {\\\\\\\\n    struct aws_s3_request *finished_request;\\\\\\\\n    struct aws_s3_request *create_connection_request;\\\\\\\\n\\\\\\\\n    uint32_t finished_request_call_counter;\\\\\\\\n    uint32_t create_connection_request_call_counter;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic void s_s3_test_meta_request_has_finish_result_finished_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    AWS_ASSERT(request);\\\\\\\\n    (void)error_code;\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data *user_data = meta_request->user_data;\\\\\\\\n    user_data->finished_request = request;\\\\\\\\n    ++user_data->finished_request_call_counter;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_meta_request_has_finish_result_client_create_connection_for_request(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    struct aws_s3_request *request) {\\\\\\\\n    (void)client;\\\\\\\\n    (void)request;\\\\\\\\n    AWS_ASSERT(client);\\\\\\\\n    AWS_ASSERT(request);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = request->meta_request;\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data *user_data = meta_request->user_data;\\\\\\\\n    user_data->create_connection_request = request;\\\\\\\\n    ++user_data->create_connection_request_call_counter;\\\\\\\\n}\\\\\\\\n\\\\\\\\nsize_t s_test_update_conns_finish_result_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    return 1;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the client will correctly discard requests for meta requests that are trying to finish. */\\\\\\\\nAWS_TEST_CASE(test_s3_client_update_connections_finish_result, s_test_s3_client_update_connections_finish_result)\\\\\\\\nstatic int s_test_s3_client_update_connections_finish_result(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_client_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_client_bootstrap);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    mock_client->client_bootstrap = &mock_client_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_update_conns_finish_result_host_address_count;\\\\\\\\n    mock_client->vtable->create_connection_for_request =\\\\\\\\n        s_s3_test_meta_request_has_finish_result_client_create_connection_for_request;\\\\\\\\n\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = 1;\\\\\\\\n\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data test_update_connections_finish_result_user_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_update_connections_finish_result_user_data);\\\\\\\\n\\\\\\\\n    /* Put together a mock meta request that is finished. */\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    mock_meta_request->synced_data.finish_result_set = true;\\\\\\\\n    mock_meta_request->user_data = &test_update_connections_finish_result_user_data;\\\\\\\\n    mock_meta_request->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *mock_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request, NULL);\\\\\\\\n    mock_meta_request_vtable->finished_request = s_s3_test_meta_request_has_finish_result_finished_request;\\\\\\\\n\\\\\\\\n    /* Verify that the request does not get sent because the meta request has finish-result. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request = aws_s3_request_new(mock_meta_request, 0, 0, 0, 0);\\\\\\\\n        aws_linked_list_push_back(&mock_client->threaded_data.request_queue, &request->node);\\\\\\\\n        ++mock_client->threaded_data.request_queue_size;\\\\\\\\n\\\\\\\\n        aws_s3_client_update_connections_threaded(mock_client);\\\\\\\\n\\\\\\\\n        /* Request should still have been dequeued, but immediately passed to the meta request finish function. */\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n        ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request == request);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request_call_counter == 1);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request == NULL);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request_call_counter == 0);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    AWS_ZERO_STRUCT(test_update_connections_finish_result_user_data);\\\\\\\\n\\\\\\\\n    /* Verify that a request with the \\'always send\\' flag still gets sent when the meta request has a finish-result. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request =\\\\\\\\n            aws_s3_request_new(mock_meta_request, 0, 0, 0, AWS_S3_REQUEST_FLAG_ALWAYS_SEND);\\\\\\\\n        aws_linked_list_push_back(&mock_client->threaded_data.request_queue, &request->node);\\\\\\\\n        ++mock_client->threaded_data.request_queue_size;\\\\\\\\n\\\\\\\\n        aws_s3_client_update_connections_threaded(mock_client);\\\\\\\\n\\\\\\\\n        /* Request should have been dequeued, and then sent on a connection. */\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n        ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request == NULL);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request_call_counter == 0);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request == request);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request_call_counter == 1);\\\\\\\\n\\\\\\\\n        aws_s3_request_release(request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_get_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    enum aws_s3_client_tls_usage tls_usage,\\\\\\\\n    uint32_t extra_meta_request_flag,\\\\\\\\n    struct aws_byte_cursor s3_path) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_connection_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_connection_options);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    struct aws_tls_ctx_options tls_context_options;\\\\\\\\n    aws_tls_ctx_options_init_default_client(&tls_context_options, allocator);\\\\\\\\n\\\\\\\\n    struct aws_tls_ctx *context = aws_tls_client_ctx_new(allocator, &tls_context_options);\\\\\\\\n    aws_tls_connection_options_init_from_ctx(&tls_connection_options, context);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    struct aws_string *endpoint =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n    struct aws_byte_cursor endpoint_cursor = aws_byte_cursor_from_string(endpoint);\\\\\\\\n\\\\\\\\n    tls_connection_options.server_name = aws_string_new_from_cursor(allocator, &endpoint_cursor);\\\\\\\\n\\\\\\\\n    switch (tls_usage) {\\\\\\\\n        case AWS_S3_TLS_ENABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n            client_config.tls_connection_options = &tls_connection_options;\\\\\\\\n            break;\\\\\\\\n        case AWS_S3_TLS_DISABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_DISABLED;\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS | extra_meta_request_flag;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_get_object_meta_request(&tester, client, s3_path, flags, NULL));\\\\\\\\n\\\\\\\\n    aws_string_destroy(endpoint);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    aws_tls_ctx_release(context);\\\\\\\\n    aws_tls_connection_options_clean_up(&tls_connection_options);\\\\\\\\n    aws_tls_ctx_options_clean_up(&tls_context_options);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_disabled, s_test_s3_get_object_tls_disabled)\\\\\\\\nstatic int s_test_s3_get_object_tls_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_DISABLED, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_enabled, s_test_s3_get_object_tls_enabled)\\\\\\\\nstatic int s_test_s3_get_object_tls_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_ENABLED, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_default, s_test_s3_get_object_tls_default)\\\\\\\\nstatic int s_test_s3_get_object_tls_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_DEFAULT, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_no_signing, s_test_s3_no_signing)\\\\\\\\nstatic int s_test_s3_no_signing(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_signing_override, s_test_s3_signing_override)\\\\\\\\nstatic int s_test_s3_signing_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    /* Getting without signing should fail since the client has no signing set up. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request.*/\\\\\\\\n        struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request(&tester, client, &options, &meta_request_test_results, 0));\\\\\\\\n        ASSERT_TRUE(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0) != AWS_OP_SUCCESS);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Getting with signing should succeed if we set up signing on the meta request. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n        options.signing_config = &tester.default_signing_config;\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request. */\\\\\\\\n        struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n            &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_less_than_part_size, s_test_s3_get_object_less_than_part_size)\\\\\\\\nstatic int s_test_s3_get_object_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_get_object_meta_request(\\\\\\\\n        &tester, client, g_pre_existing_object_1MB, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_with_part_remainder, s_test_s3_put_object_with_part_remainder)\\\\\\\\nstatic int s_test_s3_put_object_with_part_remainder(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Object size meant to be one megabyte larger than the part size of the client. */\\\\\\\\n                .object_size_mb = 6,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multiple, s_test_s3_get_object_multiple)\\\\\\\\nstatic int s_test_s3_get_object_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_requests[4];\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results[4];\\\\\\\\n    size_t num_meta_requests = AWS_ARRAY_SIZE(meta_requests);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(num_meta_requests == AWS_ARRAY_SIZE(meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        /* Put together a simple S3 Get Object request. */\\\\\\\\n        struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n            allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results[i], allocator);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results[i]));\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request. */\\\\\\\\n        meta_requests[i] = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_requests[i] != NULL);\\\\\\\\n\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        meta_requests[i] = aws_s3_meta_request_release(meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        aws_s3_tester_validate_get_object_results(&meta_request_test_results[i], 0);\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multiple_serial, s_test_s3_get_object_multiple_serial)\\\\\\\\nstatic int s_test_s3_get_object_multiple_serial(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-10MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < 4; ++i) {\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Sleep for some time to wait for the cleanup task to run */\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(7, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    /* BEGIN CRITICAL SECTION */\\\\\\\\n    aws_s3_client_lock_synced_data(client);\\\\\\\\n\\\\\\\\n    AWS_ASSERT(client->synced_data.num_endpoints_allocated == 0);\\\\\\\\n\\\\\\\\n    aws_s3_client_unlock_synced_data(client);\\\\\\\\n    /* END CRITICAL SECTION */\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path, s_test_s3_get_object_file_path)\\\\\\\\nstatic int s_test_s3_get_object_file_path(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_create_new, s_test_s3_get_object_file_path_create_new)\\\\\\\\nstatic int s_test_s3_get_object_file_path_create_new(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_CREATE_NEW,\\\\\\\\n                .pre_exist_file_length = 10,\\\\\\\\n                .recv_file_delete_on_failure = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_RECV_FILE_ALREADY_EXISTS, aws_last_error());\\\\\\\\n\\\\\\\\n    /* The request failed without invoking the finish callback. Reset the finish and shutdown count */\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_shutdown_count);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n    tester.synced_data.desired_meta_request_shutdown_count = 0;\\\\\\\\n    tester.synced_data.desired_meta_request_finish_count = 0;\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    get_options.validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS;\\\\\\\\n    get_options.get_options.pre_exist_file_length = 0;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_append, s_test_s3_get_object_file_path_append)\\\\\\\\nstatic int s_test_s3_get_object_file_path_append(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    uint64_t pre_exist_file_length = 10;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_CREATE_OR_APPEND,\\\\\\\\n                .pre_exist_file_length = pre_exist_file_length,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(pre_exist_file_length + MB_TO_BYTES(1), meta_request_test_results.received_file_size);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), meta_request_test_results.progress.total_bytes_transferred);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_to_position, s_test_s3_get_object_file_path_to_position)\\\\\\\\nstatic int s_test_s3_get_object_file_path_to_position(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    uint64_t pre_exist_file_length = 10;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_WRITE_TO_POSITION,\\\\\\\\n                .pre_exist_file_length = 0,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_RECV_FILE_NOT_FOUND, aws_last_error());\\\\\\\\n\\\\\\\\n    /* The request failed without invoking the finish callback. Reset the finish and shutdown count */\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_shutdown_count);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n    tester.synced_data.desired_meta_request_shutdown_count = 0;\\\\\\\\n    tester.synced_data.desired_meta_request_finish_count = 0;\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    get_options.validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS;\\\\\\\\n    get_options.get_options.pre_exist_file_length = pre_exist_file_length;\\\\\\\\n    get_options.get_options.recv_file_position = 20;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(\\\\\\\\n        get_options.get_options.recv_file_position + MB_TO_BYTES(1), meta_request_test_results.received_file_size);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), meta_request_test_results.progress.total_bytes_transferred);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_empty_object, s_test_s3_get_object_empty_default)\\\\\\\\nstatic int s_test_s3_get_object_empty_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    return (s_test_s3_get_object_helper(allocator, AWS_S3_TLS_ENABLED, 0, g_pre_existing_empty_object));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_sse_kms, s_test_s3_get_object_sse_kms)\\\\\\\\nstatic int s_test_s3_get_object_sse_kms(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Keep TLS enabled for SSE related download, or it will fail. */\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, AWS_S3_TESTER_SEND_META_REQUEST_SSE_KMS, g_pre_existing_object_kms_10MB);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_sse_aes256, s_test_s3_get_object_sse_aes256)\\\\\\\\nstatic int s_test_s3_get_object_sse_aes256(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Keep TLS enabled for SSE related download, or it will fail. */\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, AWS_S3_TESTER_SEND_META_REQUEST_SSE_AES256, g_pre_existing_object_aes256_10MB);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Assert that GetObject can download an object whose body is XML identical to an \\\\\\\\\\\\\"async error\\\\\\\\\\\\\" aka \\\\\\\\\\\\\"200 error\\\\\\\\\\\\\":\\\\\\\\n * <?xml version=\\\\\\\\\\\\\"1.0\\\\\\\\\\\\\" encoding=\\\\\\\\\\\\\"UTF-8\\\\\\\\\\\\\"?>\\\\\\\\\\\\\\\\n<Error><Code>InternalError</Code>... */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_looks_like_async_error_xml, s_test_s3_get_object_looks_like_async_error_xml)\\\\\\\\nstatic int s_test_s3_get_object_looks_like_async_error_xml(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, 0 /*extra_meta_request_flag*/, g_pre_existing_object_async_error_xml);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Same as above, but send the \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\" via AWS_S3_META_REQUEST_TYPE_DEFAULT\\\\\\\\n * (instead of the typical AWS_S3_META_REQUEST_TYPE_GET_OBJECT) */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_default_get_object_looks_like_async_error_xml,\\\\\\\\n    s_test_s3_default_get_object_looks_like_async_error_xml)\\\\\\\\nstatic int s_test_s3_default_get_object_looks_like_async_error_xml(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_async_error_xml,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test read-backpressure functionality by repeatedly:\\\\\\\\n * - letting the download stall\\\\\\\\n * - incrementing the read window\\\\\\\\n * - repeat...\\\\\\\\n */\\\\\\\\nstatic int s_apply_backpressure_until_meta_request_finish(\\\\\\\\n    struct aws_s3_tester *tester,\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results,\\\\\\\\n    size_t part_size,\\\\\\\\n    size_t window_initial_size,\\\\\\\\n    uint64_t window_increment_size) {\\\\\\\\n\\\\\\\\n    /* Remember the last time something happened (we received download data, or incremented read window) */\\\\\\\\n    uint64_t last_time_something_happened;\\\\\\\\n    ASSERT_SUCCESS(aws_sys_clock_get_ticks(&last_time_something_happened));\\\\\\\\n\\\\\\\\n    /* To ensure that backpressure is working, we wait a bit after download stalls\\\\\\\\n     * before incrementing the read window again.\\\\\\\\n     * This number also controls the max time we wait for bytes to start arriving\\\\\\\\n     * after incrementing the window.\\\\\\\\n     * If the magic number is too high the test will be slow,\\\\\\\\n     * if it\\'s too low the test will fail on slow networks */\\\\\\\\n    const uint64_t wait_duration_with_nothing_happening =\\\\\\\\n        aws_timestamp_convert(3, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL);\\\\\\\\n\\\\\\\\n    uint64_t accumulated_window_increments = window_initial_size;\\\\\\\\n    uint64_t accumulated_data_size = 0;\\\\\\\\n\\\\\\\\n    while (true) {\\\\\\\\n        /* Check if meta-request is done (don\\'t exit yet, we want to check some numbers first...) */\\\\\\\\n        aws_s3_tester_lock_synced_data(tester);\\\\\\\\n        bool done = tester->synced_data.meta_requests_finished != 0;\\\\\\\\n        aws_s3_tester_unlock_synced_data(tester);\\\\\\\\n\\\\\\\\n        /* Check how much data we\\'ve received */\\\\\\\\n        size_t received_body_size_delta = aws_atomic_exchange_int(&test_results->received_body_size_delta, 0);\\\\\\\\n        accumulated_data_size += (uint64_t)received_body_size_delta;\\\\\\\\n\\\\\\\\n        /* Check that we haven\\'t received more data than the window allows.\\\\\\\\n         * TODO: Stop allowing \\\\\\\\\\\\\"hacky wiggle room\\\\\\\\\\\\\". The current implementation\\\\\\\\n         *       may push more bytes to the user (up to 1 part) than they\\'ve asked for. */\\\\\\\\n        uint64_t hacky_wiggle_room = part_size;\\\\\\\\n        uint64_t max_data_allowed = accumulated_window_increments + hacky_wiggle_room;\\\\\\\\n        ASSERT_TRUE(accumulated_data_size <= max_data_allowed, \\\\\\\\\\\\\"Received more data than the read window allows\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        /* If we\\'re done, we\\'re done */\\\\\\\\n        if (done) {\\\\\\\\n            break;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Figure out how long it\\'s been since we last received data */\\\\\\\\n        uint64_t current_time;\\\\\\\\n        ASSERT_SUCCESS(aws_sys_clock_get_ticks(&current_time));\\\\\\\\n\\\\\\\\n        if (received_body_size_delta != 0) {\\\\\\\\n            last_time_something_happened = current_time;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        uint64_t duration_since_something_happened = current_time - last_time_something_happened;\\\\\\\\n\\\\\\\\n        /* If it seems like data has stopped flowing... */\\\\\\\\n        if (duration_since_something_happened >= wait_duration_with_nothing_happening) {\\\\\\\\n\\\\\\\\n            /* Assert that data stopped flowing because the window reached 0. */\\\\\\\\n            uint64_t current_window = aws_sub_u64_saturating(accumulated_window_increments, accumulated_data_size);\\\\\\\\n            ASSERT_INT_EQUALS(0, current_window, \\\\\\\\\\\\\"Data stopped flowing but read window isn\\'t 0 yet.\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n            /* Open the window a bit (this resets the \\\\\\\\\\\\\"something happened\\\\\\\\\\\\\" timer */\\\\\\\\n            accumulated_window_increments += window_increment_size;\\\\\\\\n            aws_s3_meta_request_increment_read_window(meta_request, window_increment_size);\\\\\\\\n\\\\\\\\n            last_time_something_happened = current_time;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Sleep a moment, and loop again... */\\\\\\\\n        aws_thread_current_sleep(aws_timestamp_convert(100, AWS_TIMESTAMP_MILLIS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_get_object_backpressure_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    size_t part_size,\\\\\\\\n    size_t window_initial_size,\\\\\\\\n    uint64_t window_increment_size,\\\\\\\\n    bool file_on_disk) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = part_size,\\\\\\\\n        .enable_read_backpressure = true,\\\\\\\\n        .initial_read_window = window_initial_size,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options = {\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .message = message,\\\\\\\\n    };\\\\\\\\n    struct aws_string *filepath_str = NULL;\\\\\\\\n    if (file_on_disk) {\\\\\\\\n        filepath_str = aws_s3_tester_create_file(allocator, g_pre_existing_object_1MB, NULL);\\\\\\\\n        options.recv_filepath = aws_byte_cursor_from_string(filepath_str);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Increment read window bit by bit until all data is downloaded */\\\\\\\\n    ASSERT_SUCCESS(s_apply_backpressure_until_meta_request_finish(\\\\\\\\n        &tester, meta_request, &meta_request_test_results, part_size, window_initial_size, window_increment_size));\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    /* Regression test:\\\\\\\\n     * Ensure that it\\'s safe to call increment-window even after the meta-request has finished */\\\\\\\\n    aws_s3_meta_request_increment_read_window(meta_request, 1024);\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    if (filepath_str) {\\\\\\\\n        aws_file_delete(filepath_str);\\\\\\\\n        aws_string_destroy(filepath_str);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_small_increments, s_test_s3_get_object_backpressure_small_increments)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_small_increments(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments smaller than part-size.\\\\\\\\n     * Only 1 part at a time should be in flight */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_big_increments, s_test_s3_get_object_backpressure_big_increments)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_big_increments(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments larger than part-size.\\\\\\\\n     * Multiple parts should be in flight at a time */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 8;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size * 3;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_initial_size_zero, s_test_s3_get_object_backpressure_initial_size_zero)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_initial_size_zero(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test with initial window size of zero */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 0;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_small_increments_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_small_increments_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_small_increments_recv_filepath(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    /* Test increments smaller than part-size.\\\\\\\\n     * Only 1 part at a time should be in flight */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_big_increments_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_big_increments_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_big_increments_recv_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments larger than part-size.\\\\\\\\n     * Multiple parts should be in flight at a time */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 8;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size * 3;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_initial_size_zero_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_initial_size_zero_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_initial_size_zero_recv_filepath(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    /* Test with initial window size of zero */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 0;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_part, s_test_s3_get_object_part)\\\\\\\\nstatic int s_test_s3_get_object_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/get_object_part_test\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /* GET FILE */\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_NO_VALIDATE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .part_number = 2,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_SUCCESS, meta_request_test_results.finished_error_code);\\\\\\\\n    /* Only one request was made to get the second part of the object */\\\\\\\\n    ASSERT_UINT_EQUALS(1, aws_array_list_length(&meta_request_test_results.synced_data.metrics));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    enum aws_s3_client_tls_usage tls_usage,\\\\\\\\n    uint32_t extra_meta_request_flag) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_connection_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_connection_options);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    struct aws_tls_ctx_options tls_context_options;\\\\\\\\n    aws_tls_ctx_options_init_default_client(&tls_context_options, allocator);\\\\\\\\n\\\\\\\\n    struct aws_tls_ctx *context = aws_tls_client_ctx_new(allocator, &tls_context_options);\\\\\\\\n    aws_tls_connection_options_init_from_ctx(&tls_connection_options, context);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    struct aws_string *endpoint =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n    struct aws_byte_cursor endpoint_cursor = aws_byte_cursor_from_string(endpoint);\\\\\\\\n\\\\\\\\n    tls_connection_options.server_name = aws_string_new_from_cursor(allocator, &endpoint_cursor);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    switch (tls_usage) {\\\\\\\\n        case AWS_S3_TLS_ENABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n            client_config.tls_connection_options = &tls_connection_options;\\\\\\\\n            break;\\\\\\\\n        case AWS_S3_TLS_DISABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_DISABLED;\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_put_object_meta_request(\\\\\\\\n        &tester, client, 10, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS | extra_meta_request_flag, NULL));\\\\\\\\n\\\\\\\\n    aws_string_destroy(endpoint);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    aws_tls_ctx_release(context);\\\\\\\\n    aws_tls_connection_options_clean_up(&tls_connection_options);\\\\\\\\n    aws_tls_ctx_options_clean_up(&tls_context_options);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_disabled, s_test_s3_put_object_tls_disabled)\\\\\\\\nstatic int s_test_s3_put_object_tls_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DISABLED, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_enabled, s_test_s3_put_object_tls_enabled)\\\\\\\\nstatic int s_test_s3_put_object_tls_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_ENABLED, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_default, s_test_s3_put_object_tls_default)\\\\\\\\nstatic int s_test_s3_put_object_tls_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DEFAULT, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_put_object_with_acl, s_test_s3_multipart_put_object_with_acl)\\\\\\\\nstatic int s_test_s3_multipart_put_object_with_acl(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DEFAULT, AWS_S3_TESTER_SEND_META_REQUEST_PUT_ACL));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_multiple_helper(struct aws_allocator *allocator, bool file_on_disk) {\\\\\\\\n\\\\\\\\n    enum s_numbers { NUM_REQUESTS = 5 };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_requests[NUM_REQUESTS];\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results[NUM_REQUESTS];\\\\\\\\n    struct aws_http_message *messages[NUM_REQUESTS];\\\\\\\\n    struct aws_input_stream *input_streams[NUM_REQUESTS];\\\\\\\\n    struct aws_byte_buf input_stream_buffers[NUM_REQUESTS];\\\\\\\\n    struct aws_string *filepath_str[NUM_REQUESTS];\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    size_t content_length = MB_TO_BYTES(10);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results[i], allocator);\\\\\\\\n        char object_path_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n        snprintf(\\\\\\\\n            object_path_buffer,\\\\\\\\n            sizeof(object_path_buffer),\\\\\\\\n            \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-10MB-%zu.txt\\\\\\\\\\\\\",\\\\\\\\n            AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n            i);\\\\\\\\n        AWS_ZERO_STRUCT(input_stream_buffers[i]);\\\\\\\\n        aws_s3_create_test_buffer(allocator, content_length, &input_stream_buffers[i]);\\\\\\\\n        struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&input_stream_buffers[i]);\\\\\\\\n        input_streams[i] = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n        struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(object_path_buffer);\\\\\\\\n        struct aws_byte_cursor host_cur = aws_byte_cursor_from_string(host_name);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT;\\\\\\\\n        if (file_on_disk) {\\\\\\\\n            filepath_str[i] = aws_s3_tester_create_file(allocator, test_object_path, input_streams[i]);\\\\\\\\n            messages[i] = aws_s3_test_put_object_request_new_without_body(\\\\\\\\n                allocator, &host_cur, g_test_body_content_type, test_object_path, content_length, 0 /*flags*/);\\\\\\\\n            options.send_filepath = aws_byte_cursor_from_string(filepath_str[i]);\\\\\\\\n        } else {\\\\\\\\n            filepath_str[i] = NULL;\\\\\\\\n            messages[i] = aws_s3_test_put_object_request_new(\\\\\\\\n                allocator, &host_cur, test_object_path, g_test_body_content_type, input_streams[i], 0);\\\\\\\\n        }\\\\\\\\n        options.message = messages[i];\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results[i]));\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Put Object request. */\\\\\\\\n        meta_requests[i] = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_requests[i] != NULL);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        meta_requests[i] = aws_s3_meta_request_release(meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_s3_tester_validate_get_object_results(&meta_request_test_results[i], 0);\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_http_message_release(messages[i]);\\\\\\\\n        aws_input_stream_release(input_streams[i]);\\\\\\\\n        aws_byte_buf_clean_up(&input_stream_buffers[i]);\\\\\\\\n        if (filepath_str[i]) {\\\\\\\\n            ASSERT_SUCCESS(aws_file_delete(filepath_str[i]));\\\\\\\\n            aws_string_destroy(filepath_str[i]);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multiple, s_test_s3_put_object_multiple)\\\\\\\\nstatic int s_test_s3_put_object_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_put_object_multiple_helper(allocator, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multiple_with_filepath, s_test_s3_put_object_multiple_with_filepath)\\\\\\\\nstatic int s_test_s3_put_object_multiple_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_put_object_multiple_helper(allocator, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_less_than_part_size, s_test_s3_put_object_less_than_part_size)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_buffer_pool_trim, s_test_s3_put_object_buffer_pool_trim)\\\\\\\\nstatic int s_test_s3_put_object_buffer_pool_trim(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 8 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 32,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    struct aws_s3_buffer_pool_usage_stats usage_before = aws_s3_buffer_pool_get_usage(client->buffer_pool);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(0 != usage_before.primary_num_blocks);\\\\\\\\n\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(6, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    struct aws_s3_buffer_pool_usage_stats usage_after = aws_s3_buffer_pool_get_usage(client->buffer_pool);\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(0, usage_after.primary_num_blocks);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_less_than_part_size_with_content_encoding,\\\\\\\\n    s_test_s3_put_object_less_than_part_size_with_content_encoding)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size_with_content_encoding(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor content_encoding_cursor = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"gzip\\\\\\\\\\\\\");\\\\\\\\n    uint32_t object_size_mb = 1;\\\\\\\\n    char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n    snprintf(\\\\\\\\n        object_path_sprintf_buffer,\\\\\\\\n        sizeof(object_path_sprintf_buffer),\\\\\\\\n        \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-content-encoding-%uMB.txt\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n        object_size_mb);\\\\\\\\n    struct aws_byte_cursor object_path_cursor = aws_byte_cursor_from_c_str(object_path_sprintf_buffer);\\\\\\\\n\\\\\\\\n    /*** put file with encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_SHA256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path_cursor,\\\\\\\\n                .content_encoding = content_encoding_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** get file and validate encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results get_object_result;\\\\\\\\n    aws_s3_meta_request_test_results_init(&get_object_result, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &get_object_result));\\\\\\\\n    struct aws_byte_cursor content_encoding_header_cursor;\\\\\\\\n    ASSERT_SUCCESS(aws_http_headers_get(\\\\\\\\n        get_object_result.response_headers, g_content_encoding_header_name, &content_encoding_header_cursor));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq(&content_encoding_cursor, &content_encoding_header_cursor));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&get_object_result);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_mpu_with_content_encoding, s_test_s3_put_object_mpu_with_content_encoding)\\\\\\\\nstatic int s_test_s3_put_object_mpu_with_content_encoding(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor content_encoding_cursor = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"gzip\\\\\\\\\\\\\");\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n    char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n    snprintf(\\\\\\\\n        object_path_sprintf_buffer,\\\\\\\\n        sizeof(object_path_sprintf_buffer),\\\\\\\\n        \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-content-encoding-%uMB.txt\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n        object_size_mb);\\\\\\\\n    struct aws_byte_cursor object_path_cursor = aws_byte_cursor_from_c_str(object_path_sprintf_buffer);\\\\\\\\n\\\\\\\\n    /*** put file with encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_SHA256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path_cursor,\\\\\\\\n                .content_encoding = content_encoding_cursor,\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** get file and validate encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results get_object_result;\\\\\\\\n    aws_s3_meta_request_test_results_init(&get_object_result, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &get_object_result));\\\\\\\\n    struct aws_byte_cursor content_encoding_header_cursor;\\\\\\\\n    ASSERT_SUCCESS(aws_http_headers_get(\\\\\\\\n        get_object_result.response_headers, g_content_encoding_header_name, &content_encoding_header_cursor));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq(&content_encoding_cursor, &content_encoding_header_cursor));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&get_object_result);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multipart_threshold, s_test_s3_put_object_multipart_threshold)\\\\\\\\nstatic int s_test_s3_put_object_multipart_threshold(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n        .multipart_upload_threshold = MB_TO_BYTES(15),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    /* First smaller than the part size */\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 5,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a single part upload, and have 0 as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(0, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    /* Second smaller than threshold and larger than part size */\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    put_options.put_options.object_size_mb = 10;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a single part upload, and have 0 as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(0, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    /* Third larger than threshold*/\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    put_options.put_options.object_size_mb = 20;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in multi-part upload, and have the real part size */\\\\\\\\n    ASSERT_UINT_EQUALS(client_config.part_size, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_threshold_less_than_part_size,\\\\\\\\n    s_test_s3_put_object_multipart_threshold_less_than_part_size)\\\\\\\\nstatic int s_test_s3_put_object_multipart_threshold_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n        .multipart_upload_threshold = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    /* First smaller than the part size */\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 6,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a one part of multipart upload, and have the content length as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(put_options.put_options.object_size_mb), meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_empty_object, s_test_s3_put_object_empty_object)\\\\\\\\nstatic int s_test_s3_put_object_empty_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 0,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s3_no_content_length_test_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    uint32_t object_size_in_mb,\\\\\\\\n    bool use_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = use_checksum ? AWS_SCA_CRC32 : AWS_SCA_NONE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_in_mb,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_no_content_length, s_test_s3_put_object_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 19, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_single_part_no_content_length, s_test_s3_put_object_single_part_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_single_part_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 5, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_zero_size_no_content_length, s_test_s3_put_object_zero_size_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_zero_size_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 0, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_large_object_no_content_length_with_checksum,\\\\\\\\n    s_test_s3_put_large_object_no_content_length_with_checksum)\\\\\\\\nstatic int s_test_s3_put_large_object_no_content_length_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 128, true));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Once upon a time, we have a bug that without content-length, we will schedule more requests to prepare than needed.\\\\\\\\n * And those extra request will be cleaned up, however, the client level count of `num_requests_being_prepared` will\\\\\\\\n * still keep record for those.\\\\\\\\n *\\\\\\\\n * To reproduce, we create bunch of requests with less than a part body. And then sleep for a while to let dns resolve\\\\\\\\n * purge all records. (Otherwise, we will always have one valid request to be available to send.) to trigger not going\\\\\\\\n * full speed code. And we will hang.\\\\\\\\n *\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_no_content_length_multiple, s_test_s3_put_object_no_content_length_multiple)\\\\\\\\nstatic int s_test_s3_put_object_no_content_length_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    aws_s3_set_dns_ttl(55);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    for (int i = 0; i < 6; i++) {\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    }\\\\\\\\n    /* Sleep more than the DNS ttl to purge all records. */\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(60, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    /* After sleep for a while, make another meta request */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream when we\\'re not doing multipart upload */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_singlepart, s_test_s3_put_object_async_singlepart)\\\\\\\\nstatic int s_test_s3_put_object_async_singlepart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 4,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream in multipart upload */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_multipart, s_test_s3_put_object_async_multipart)\\\\\\\\nstatic int s_test_s3_put_object_async_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 16,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, but the aws_async_input_stream_read() calls all complete synchronously */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_read_completes_synchronously,\\\\\\\\n    s_test_s3_put_object_async_read_completes_synchronously)\\\\\\\\nstatic int s_test_s3_put_object_async_read_completes_synchronously(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .async_read_strategy = AWS_ASYNC_READ_COMPLETES_IMMEDIATELY,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, where it takes multiple read() calls to fill each part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_small_reads, s_test_s3_put_object_async_small_reads)\\\\\\\\nstatic int s_test_s3_put_object_async_small_reads(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .max_bytes_per_read = KB_TO_BYTES(1001), /* something that doesn\\'t evenly divide into 8MB parts */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test synchronous input-stream, where it takes multiple read() calls to fill each part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_small_reads, s_test_s3_put_object_small_reads)\\\\\\\\nstatic int s_test_s3_put_object_small_reads(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .max_bytes_per_read = KB_TO_BYTES(1001), /* something that doesn\\'t evenly divide into 8MB parts */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that doesn\\'t end exactly on a part boundary */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_no_content_length_partial_part,\\\\\\\\n    s_test_s3_put_object_async_no_content_length_partial_part)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_partial_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 3,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that fills exactly 1 part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_no_content_length_1part, s_test_s3_put_object_async_no_content_length_1part)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_1part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 8,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that doesn\\'t realize\\\\\\\\n * it\\'s at EOF until it tries to read the 2nd part and gets 0 bytes */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_no_content_length_empty_part2,\\\\\\\\n    s_test_s3_put_object_async_no_content_length_empty_part2)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_empty_part2(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 8,             /* read 1 part\\'s worth of data */\\\\\\\\n                .eof_requires_extra_read = true, /* don\\'t report EOF until it tries to read 2nd part */\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that fills multiple parts */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_no_content_length_2parts, s_test_s3_put_object_async_no_content_length_2parts)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_2parts(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 16,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_fail_reading, s_test_s3_put_object_async_fail_reading)\\\\\\\\nstatic int s_test_s3_put_object_async_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(AWS_IO_STREAM_READ_FAILED, test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_validate_if_none_match_failure_response(struct aws_s3_meta_request_test_results *test_results) {\\\\\\\\n\\\\\\\\n    /**\\\\\\\\n     * response body should be like:\\\\\\\\n     * <Error>\\\\\\\\n     * <Code>PreconditionFailed</Code>\\\\\\\\n     * <Message>At least one of the pre-conditions you specified did not hold</Message>\\\\\\\\n     * <Condition>If-None-Match</Condition>\\\\\\\\n     * <RequestId></RequestId>\\\\\\\\n     * <HostId></HostId>\\\\\\\\n     * </Error>\\\\\\\\n     */\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor xml_doc = aws_byte_cursor_from_buf(&test_results->error_response_body);\\\\\\\\n    struct aws_byte_cursor error_code_string = {0};\\\\\\\\n    struct aws_byte_cursor condition_string = {0};\\\\\\\\n\\\\\\\\n    const char *error_code_path[] = {\\\\\\\\\\\\\"Error\\\\\\\\\\\\\", \\\\\\\\\\\\\"Code\\\\\\\\\\\\\", NULL};\\\\\\\\n    ASSERT_SUCCESS(aws_xml_get_body_at_path(test_results->allocator, xml_doc, error_code_path, &error_code_string));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq_c_str(&error_code_string, \\\\\\\\\\\\\"PreconditionFailed\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    const char *condition_path[] = {\\\\\\\\\\\\\"Error\\\\\\\\\\\\\", \\\\\\\\\\\\\"Condition\\\\\\\\\\\\\", NULL};\\\\\\\\n    ASSERT_SUCCESS(aws_xml_get_body_at_path(test_results->allocator, xml_doc, condition_path, &condition_string));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq_c_str(&condition_string, \\\\\\\\\\\\\"If-None-Match\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_if_none_match, s_test_s3_put_object_if_none_match)\\\\\\\\nstatic int s_test_s3_put_object_if_none_match(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n    struct aws_byte_cursor if_none_match_all = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Use pre_exist object so that the request should fail with the expected failure message. */\\\\\\\\n                .object_path_override = g_pre_existing_object_1MB,\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .if_none_match_header = if_none_match_all,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_HTTP_STATUS_CODE_412_PRECONDITION_FAILED, test_results.finished_response_status);\\\\\\\\n    ASSERT_SUCCESS(s_test_validate_if_none_match_failure_response(&test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_mpu_if_none_match, s_test_s3_put_object_mpu_if_none_match)\\\\\\\\nstatic int s_test_s3_put_object_mpu_if_none_match(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n    struct aws_byte_cursor if_none_match_all = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Use pre_exist object so that the request should fail with the expected failure message. */\\\\\\\\n                .object_path_override = g_pre_existing_object_10MB,\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .if_none_match_header = if_none_match_all,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /** Complete MPU can fail with 200 error */\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        AWS_HTTP_STATUS_CODE_412_PRECONDITION_FAILED == test_results.finished_response_status ||\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK == test_results.finished_response_status);\\\\\\\\n    ASSERT_SUCCESS(s_test_validate_if_none_match_failure_response(&test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_kms, s_test_s3_put_object_sse_kms)\\\\\\\\nstatic int s_test_s3_put_object_sse_kms(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_kms_multipart, s_test_s3_put_object_sse_kms_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_kms_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_aes256, s_test_s3_put_object_sse_aes256)\\\\\\\\nstatic int s_test_s3_put_object_sse_aes256(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_aes256_multipart, s_test_s3_put_object_sse_aes256_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_aes256_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_c_aes256_multipart, s_test_s3_put_object_sse_c_aes256_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_c_aes256_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    (void)allocator;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        tester.allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_sse_c.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_C_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_sse_c_aes256_multipart_with_checksum,\\\\\\\\n    s_test_s3_put_object_sse_c_aes256_multipart_with_checksum)\\\\\\\\nstatic int s_test_s3_put_object_sse_c_aes256_multipart_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        tester.allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_sse_c_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_C_AES256,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_content_md5_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    bool multipart_upload,\\\\\\\\n    uint32_t flags,\\\\\\\\n    enum aws_s3_meta_request_compute_content_md5 compute_content_md5) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    size_t part_size = 5 * 1024 * 1024;\\\\\\\\n    if (!multipart_upload) {\\\\\\\\n        /* content_length < part_size */\\\\\\\\n        part_size = 15 * 1024 * 1024;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = part_size,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    client_config.compute_content_md5 = compute_content_md5;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_put_object_meta_request(&tester, client, 10, flags, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_no_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_no_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_no_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_no_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_no_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_no_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_correct_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_correct_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_correct_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_correct_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_correct_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_correct_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_incorrect_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_incorrect_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_incorrect_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_incorrect_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_incorrect_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_incorrect_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_no_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_no_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_no_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_no_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_no_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_no_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_correct_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_correct_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_correct_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_correct_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_correct_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_correct_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_incorrect_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_incorrect_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_incorrect_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_incorrect_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_incorrect_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_incorrect_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_upload_part_message_helper(struct aws_allocator *allocator, bool should_compute_content_md5) {\\\\\\\\n\\\\\\\\n    aws_s3_library_init(allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n    /* base64 encoded md5 of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */\\\\\\\\n    struct aws_byte_cursor expected_content_md5 = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"+y3U+EY5uFXhVVmRoiJWyA==\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    uint32_t part_number = 1;\\\\\\\\n    struct aws_string *upload_id = aws_string_new_from_c_str(allocator, \\\\\\\\\\\\\"dummy_upload_id\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message = aws_s3_upload_part_message_new(\\\\\\\\n        allocator, base_message, &test_buffer, part_number, upload_id, should_compute_content_md5, NULL, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    if (should_compute_content_md5) {\\\\\\\\n        ASSERT_TRUE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n        struct aws_byte_cursor content_md5;\\\\\\\\n        aws_http_headers_get(new_headers, g_content_md5_header_name, &content_md5);\\\\\\\\n        ASSERT_BIN_ARRAYS_EQUALS(expected_content_md5.ptr, expected_content_md5.len, content_md5.ptr, content_md5.len);\\\\\\\\n    } else {\\\\\\\\n        ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(upload_id);\\\\\\\\n    upload_id = NULL;\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    aws_s3_library_clean_up();\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_part_message_with_content_md5, s_test_s3_upload_part_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_upload_part_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_upload_part_message_helper(allocator, true));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_part_message_without_content_md5, s_test_s3_upload_part_message_without_content_md5)\\\\\\\\nstatic int s_test_s3_upload_part_message_without_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_upload_part_message_helper(allocator, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_create_multipart_upload_message_with_content_md5,\\\\\\\\n    s_test_s3_create_multipart_upload_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_create_multipart_upload_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_md5_header = {\\\\\\\\n        .name = g_content_md5_header_name,\\\\\\\\n        .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_content_md5\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_http_message_add_header(base_message, content_md5_header));\\\\\\\\n\\\\\\\\n    struct aws_http_headers *base_headers = aws_http_message_get_headers(base_message);\\\\\\\\n    ASSERT_TRUE(aws_http_headers_has(base_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message = aws_s3_create_multipart_upload_message_new(allocator, base_message, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_complete_multipart_message_with_content_md5,\\\\\\\\n    s_test_s3_complete_multipart_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_complete_multipart_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_md5_header = {\\\\\\\\n        .name = g_content_md5_header_name,\\\\\\\\n        .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_content_md5\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_http_message_add_header(base_message, content_md5_header));\\\\\\\\n\\\\\\\\n    struct aws_http_headers *base_headers = aws_http_message_get_headers(base_message);\\\\\\\\n    ASSERT_TRUE(aws_http_headers_has(base_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf body_buffer;\\\\\\\\n    aws_byte_buf_init(&body_buffer, allocator, 512);\\\\\\\\n\\\\\\\\n    struct aws_string *upload_id = aws_string_new_from_c_str(allocator, \\\\\\\\\\\\\"dummy_upload_id\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_array_list parts;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_init_dynamic(&parts, allocator, 0, sizeof(struct aws_s3_mpu_part_info *)));\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message =\\\\\\\\n        aws_s3_complete_multipart_message_new(allocator, base_message, &body_buffer, upload_id, &parts, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_array_list_clean_up(&parts);\\\\\\\\n\\\\\\\\n    aws_string_destroy(upload_id);\\\\\\\\n    upload_id = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&body_buffer);\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_double_slashes, s_test_s3_put_object_double_slashes)\\\\\\\\nstatic int s_test_s3_put_object_double_slashes(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix//test.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip, s_test_s3_round_trip)\\\\\\\\nstatic int s_test_s3_round_trip(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get, s_test_s3_round_trip_default_get)\\\\\\\\nstatic int s_test_s3_round_trip_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_default.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_validate_headers_checksum_set(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)headers;\\\\\\\\n    struct aws_s3_meta_request_test_results *meta_request_test_results =\\\\\\\\n        (struct aws_s3_meta_request_test_results *)user_data;\\\\\\\\n    ASSERT_NOT_NULL(meta_request->meta_request_level_running_response_sum);\\\\\\\\n    ASSERT_INT_EQUALS(\\\\\\\\n        meta_request->meta_request_level_running_response_sum->algorithm, meta_request_test_results->algorithm);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_validate_headers_checksum_unset(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)user_data;\\\\\\\\n    ASSERT_NULL(meta_request->meta_request_level_running_response_sum);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nvoid s_s3_test_validate_checksum(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *result,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    struct aws_s3_meta_request_test_results *meta_request_test_results =\\\\\\\\n        (struct aws_s3_meta_request_test_results *)user_data;\\\\\\\\n    AWS_FATAL_ASSERT(result->did_validate);\\\\\\\\n    AWS_FATAL_ASSERT(result->validation_algorithm == meta_request_test_results->algorithm);\\\\\\\\n    AWS_FATAL_ASSERT(result->error_code == AWS_OP_SUCCESS);\\\\\\\\n}\\\\\\\\nvoid s_s3_test_no_validate_checksum(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *result,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)user_data;\\\\\\\\n    AWS_FATAL_ASSERT(!result->did_validate);\\\\\\\\n    AWS_FATAL_ASSERT(result->error_code == AWS_OP_SUCCESS);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* TODO: maybe refactor the fc -> flexible checksum tests to be less copy/paste */\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header,\\\\\\\\n    uint32_t object_size_mb,\\\\\\\\n    enum aws_s3_tester_full_object_checksum full_object_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_ARRAY_SIZE(s_checksum_algo_priority_list); i++) {\\\\\\\\n        enum aws_s3_checksum_algorithm algorithm = s_checksum_algo_priority_list[i];\\\\\\\\n        char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n        snprintf(\\\\\\\\n            object_path_sprintf_buffer,\\\\\\\\n            sizeof(object_path_sprintf_buffer),\\\\\\\\n            \\\\\\\\\\\\\"/prefix/round_trip/test_default_fc_%d_%d.txt\\\\\\\\\\\\\",\\\\\\\\n            algorithm,\\\\\\\\n            object_size_mb);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n            allocator, &path_buf, aws_byte_cursor_from_c_str(object_path_sprintf_buffer)));\\\\\\\\n        struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n        /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n        struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n            .client = client,\\\\\\\\n            .checksum_algorithm = algorithm,\\\\\\\\n            .validate_get_response_checksum = false,\\\\\\\\n            .checksum_via_header = via_header,\\\\\\\\n            .put_options =\\\\\\\\n                {\\\\\\\\n                    .object_size_mb = object_size_mb,\\\\\\\\n                    .object_path_override = object_path,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n        if (algorithm != AWS_SCA_SHA1 && algorithm != AWS_SCA_SHA256) {\\\\\\\\n            /* Full object checksums doesn\\'t support SHA. */\\\\\\\\n            put_options.put_options.full_object_checksum = full_object_checksum;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n        /*** GET FILE ***/\\\\\\\\n\\\\\\\\n        struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .client = client,\\\\\\\\n            .expected_validate_checksum_alg = algorithm,\\\\\\\\n            .validate_get_response_checksum = true,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = object_path,\\\\\\\\n                },\\\\\\\\n            .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n            .headers_callback = s_s3_validate_headers_checksum_set,\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n        aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get_fc, s_test_s3_round_trip_default_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 1 /*object_size_mb*/, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_empty_fc, s_test_s3_round_trip_empty_fc)\\\\\\\\nstatic int s_test_s3_round_trip_empty_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 0, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get_fc_header, s_test_s3_round_trip_default_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, true, 1, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_default_get_full_object_checksum_fc,\\\\\\\\n    s_test_s3_round_trip_default_get_full_object_checksum_fc)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_full_object_checksum_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 1, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc_helper(struct aws_allocator *allocator, void *ctx, bool via_header) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC64NVME,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC64NVME,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .headers_callback = s_s3_validate_headers_checksum_set,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_multipart_get_fc, s_test_s3_round_trip_multipart_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_multipart_get_fc_helper(allocator, ctx, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_multipart_get_fc_header, s_test_s3_round_trip_multipart_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_multipart_get_fc_helper(allocator, ctx, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test the multipart uploaded object was downloaded with same part size, which will download the object matches all the\\\\\\\\n * parts and validate the parts checksum. */\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header,\\\\\\\\n    enum aws_s3_tester_full_object_checksum full_object_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n    struct aws_byte_cursor object_name;\\\\\\\\n    /* Use different name to avoid collision when tests run concurrently. */\\\\\\\\n    switch (full_object_checksum) {\\\\\\\\n        case AWS_TEST_FOC_CALLBACK:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc_full_object_via_callback.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n        case AWS_TEST_FOC_HEADER:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc_full_object_via_header.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(allocator, &path_buf, object_name));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .full_object_checksum = full_object_checksum,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_multipart_get_fc, s_test_s3_round_trip_mpu_multipart_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_multipart_get_fc_header, s_test_s3_round_trip_mpu_multipart_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, true, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, true, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_CALLBACK);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/empty-file-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 0,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE WITH GET_FIRST_PART ***/\\\\\\\\n    uint64_t small_object_size_hint = 1;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .object_size_hint =\\\\\\\\n            &small_object_size_hint /* pass a object_size_hint > 0 so that the request goes through the getPart flow */,\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE WITH HEAD_OBJECT ***/\\\\\\\\n    get_options.object_size_hint = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_empty_file_with_checksum, s_test_s3_download_empty_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_download_empty_file_with_checksum_helper(allocator, ctx, false);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(test_s3_download_empty_file_with_checksum_header, s_test_s3_download_empty_file_with_checksum_header)\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_download_empty_file_with_checksum_helper(allocator, ctx, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_single_part_file_with_checksum, s_test_s3_download_single_part_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_single_part_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(10),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/single-part-10Mb-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    uint64_t object_size_hint = MB_TO_BYTES(object_size_mb);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .object_size_hint = &object_size_hint,\\\\\\\\n    };\\\\\\\\n    uint64_t small_object_size_hint = MB_TO_BYTES(1);\\\\\\\\n\\\\\\\\n    /* will do headRequest */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(20);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n\\\\\\\\n    /* will do getPart */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /* will do getPart */\\\\\\\\n    /*** GET FILE with part_size = file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(10);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < file_size and wrong object_size_hint ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.object_size_hint = &small_object_size_hint;\\\\\\\\n    /* will do getPart first, cancel it and then rangedGet */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_multipart_file_with_checksum, s_test_s3_download_multipart_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_multipart_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/multipart-10Mb-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    uint64_t object_size_hint = MB_TO_BYTES(object_size_mb);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .object_size_hint = &object_size_hint,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* will do HeadRequest first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(7);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    /* will do HeadObject first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size = first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(5);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    /* will do HeadObject First */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    uint64_t small_object_size_hint = 1;\\\\\\\\n\\\\\\\\n    /*** GET FILE with with wrong object_size_hint ***/\\\\\\\\n    get_options.object_size_hint = &small_object_size_hint;\\\\\\\\n    get_options.finish_callback = NULL;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < first_part_size***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n\\\\\\\\n    /* will do GetPart, cancel the request and then do ranged Gets. */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(7);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n\\\\\\\\n    /* will do GetPart first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size = first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(5);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    /* will do GetPart first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > fileSize ***/\\\\\\\\n    /* TODO: Enable this test once the checksum issue is resolved. Currently, when the S3 GetObject API is called with\\\\\\\\n     * the range 0-contentLength, it returns a checksum of checksums without the -numParts portion. This leads to a\\\\\\\\n     * checksum mismatch error, as it is incorrectly validated as a part checksum. */\\\\\\\\n    /*\\\\\\\\n    client_options.part_size = MB_TO_BYTES(20);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n    */\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_array_list response_checksum_list;\\\\\\\\n    /* Check for all algorithm but the CRC32 */\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_array_list_init_dynamic(&response_checksum_list, allocator, 4, sizeof(enum aws_s3_checksum_algorithm)));\\\\\\\\n    enum aws_s3_checksum_algorithm alg = AWS_SCA_CRC32C;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    alg = AWS_SCA_SHA1;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    alg = AWS_SCA_SHA256;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .validate_checksum_algorithms = &response_checksum_list,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_no_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    /* Push all the algorithms to the list for validation, now we should have the checksum validated. */\\\\\\\\n    alg = AWS_SCA_CRC32;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_array_list_clean_up(&response_checksum_list);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_default_get_fc, s_test_s3_round_trip_mpu_default_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_default_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_default_get_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_no_validate_checksum,\\\\\\\\n        .headers_callback = s_s3_validate_headers_checksum_unset,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor key,\\\\\\\\n    int object_size_mb,\\\\\\\\n    bool unknown_content_length) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(allocator, &path_buf, key));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .skip_content_length = unknown_content_length,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(\\\\\\\\n        MB_TO_BYTES(put_options.put_options.object_size_mb), test_results.progress.total_bytes_transferred);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_with_filepath, s_test_s3_round_trip_with_filepath)\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath\\\\\\\\\\\\\"), 1, false /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_with_filepath, s_test_s3_round_trip_mpu_with_filepath)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_mpu\\\\\\\\\\\\\"),\\\\\\\\n        50,\\\\\\\\n        false /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_with_filepath_no_content_length, s_test_s3_round_trip_with_filepath_no_content_length)\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_no_content_length\\\\\\\\\\\\\"),\\\\\\\\n        1,\\\\\\\\n        true /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_with_filepath_no_content_length,\\\\\\\\n    s_test_s3_round_trip_mpu_with_filepath_no_content_length)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_with_filepath_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_mpu_no_content_length\\\\\\\\\\\\\"),\\\\\\\\n        50,\\\\\\\\n        true /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_chunked_then_unchunked, s_test_s3_chunked_then_unchunked)\\\\\\\\nstatic int s_test_s3_chunked_then_unchunked(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Test to see if signed_body_value modified when signing chunked request */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/chunked_unchunked/test_chunked.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor chunked_object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options chunked_put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = chunked_object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &chunked_put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/chunked_unchunked/test_unchunked.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor unchunked_object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options unchunked_put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_NONE,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = unchunked_object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &unchunked_put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_meta_request_default, s_test_s3_meta_request_default)\\\\\\\\nstatic int s_test_s3_meta_request_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n\\\\\\\\n    /* Pass the request through as a default request so that it goes through as-is. */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    /* Check the size of the metrics should be the same as the number of\\\\\\\\n    requests, which should be 1 */\\\\\\\\n    ASSERT_UINT_EQUALS(1, aws_array_list_length(&meta_request_test_results.synced_data.metrics));\\\\\\\\n    struct aws_s3_request_metrics *metrics = NULL;\\\\\\\\n    aws_array_list_back(&meta_request_test_results.synced_data.metrics, (void **)&metrics);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_error_missing_file, s_test_s3_error_missing_file)\\\\\\\\nstatic int s_test_s3_error_missing_file(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor test_object_path =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/non-existing-file12345.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message =\\\\\\\\n        aws_s3_test_get_object_request_new(allocator, aws_byte_cursor_from_string(host_name), test_object_path);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_response_status == 404);\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.error_response_headers != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_NOT_NULL(meta_request_test_results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(meta_request_test_results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(meta_request_test_results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_test_s3_existing_host_entry_address_resolved_callback(\\\\\\\\n    struct aws_host_resolver *resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    int err_code,\\\\\\\\n    const struct aws_array_list *host_addresses,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)err_code;\\\\\\\\n    (void)host_addresses;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = user_data;\\\\\\\\n    AWS_ASSERT(tester);\\\\\\\\n    aws_s3_tester_notify_signal(tester);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_existing_host_entry, s_test_s3_existing_host_entry)\\\\\\\\nstatic int s_test_s3_existing_host_entry(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_host_resolution_config host_resolver_config;\\\\\\\\n        AWS_ZERO_STRUCT(host_resolver_config);\\\\\\\\n        host_resolver_config.impl = aws_default_dns_resolve;\\\\\\\\n        host_resolver_config.max_ttl = 30;\\\\\\\\n        host_resolver_config.impl_data = NULL;\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_host_resolver_resolve_host(\\\\\\\\n            client_config.client_bootstrap->host_resolver,\\\\\\\\n            host_name,\\\\\\\\n            s_test_s3_existing_host_entry_address_resolved_callback,\\\\\\\\n            &host_resolver_config,\\\\\\\\n            &tester));\\\\\\\\n\\\\\\\\n        aws_s3_tester_wait_for_signal(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_bad_endpoint, s_test_s3_bad_endpoint)\\\\\\\\nstatic int s_test_s3_bad_endpoint(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"test_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    AWS_STATIC_STRING_FROM_LITERAL(invalid_host_name, \\\\\\\\\\\\\"invalid_host_name_totally_absolutely\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Construct a message that points to an invalid host name. Key can be anything. */\\\\\\\\n    struct aws_http_message *message =\\\\\\\\n        aws_s3_test_get_object_request_new(allocator, aws_byte_cursor_from_string(invalid_host_name), test_key);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(&tester, client, &options, &meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        meta_request_test_results.finished_error_code == AWS_IO_DNS_INVALID_NAME ||\\\\\\\\n        meta_request_test_results.finished_error_code == AWS_IO_DNS_QUERY_FAILED);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_raise_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_body_callback_raise_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)body;\\\\\\\\n    (void)range_start;\\\\\\\\n    (void)user_data;\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_fail_headers_callback, s_test_s3_put_object_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_put_object_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_fail_body_callback, s_test_s3_put_object_fail_body_callback)\\\\\\\\nstatic int s_test_s3_put_object_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n\\\\\\\\n        /* Put object currently never invokes the body callback, which means it should not fail. */\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, NULL));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_fail_headers_callback, s_test_s3_get_object_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_get_object_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_fail_body_callback, s_test_s3_get_object_fail_body_callback)\\\\\\\\nstatic int s_test_s3_get_object_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_headers_callback, s_test_s3_default_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_default_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_atomic_var s_test_headers_callback_invoked;\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_check_returns_success(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    /* increments counter to check if callback was invoked exactly once */\\\\\\\\n    aws_atomic_fetch_add(&s_test_headers_callback_invoked, 1);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_check_returns_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    /* increments counter to check if callback was invoked exactly once */\\\\\\\\n    aws_atomic_fetch_add(&s_test_headers_callback_invoked, 1);\\\\\\\\n\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_invoke_headers_callback_on_error, s_test_s3_default_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_default_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_default_invoke_headers_callback_cancels_on_error,\\\\\\\\n    s_test_s3_default_invoke_headers_callback_cancels_on_error)\\\\\\\\nstatic int s_test_s3_default_invoke_headers_callback_cancels_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_invoke_headers_callback_on_error,\\\\\\\\n    s_test_s3_get_object_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_get_object_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_invoke_headers_callback_on_error,\\\\\\\\n    s_test_s3_put_object_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_put_object_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .invalid_request = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INVALID_RESPONSE_STATUS, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation,\\\\\\\\n    s_test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation)\\\\\\\\nstatic int s_test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_UNKNOWN, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_body_callback, s_test_s3_default_fail_body_callback)\\\\\\\\nstatic int s_test_s3_default_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that if a DEFAULt meta-request sets the operation_name, and gets an error response,\\\\\\\\n * then aws_s3_meta_request_result.error_response_operation_name is set. */\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_operation_name, s_test_s3_default_fail_operation_name)\\\\\\\\nstatic int s_test_s3_default_fail_operation_name(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\", aws_string_c_str(meta_request_test_results.error_response_operation_name));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_invalid_request, s_test_s3_put_fail_object_invalid_request)\\\\\\\\nstatic int s_test_s3_put_fail_object_invalid_request(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .invalid_request = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INVALID_RESPONSE_STATUS, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    /* Since 1MB is under part_size, there will be a single PutObject request */\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"PutObject\\\\\\\\\\\\\", aws_string_c_str(meta_request_test_results.error_response_operation_name));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that we fail to create a metarequest when an invalid `send_filepath` is passed in */\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_invalid_send_filepath, s_test_s3_put_fail_object_invalid_send_filepath)\\\\\\\\nstatic int s_test_s3_put_fail_object_invalid_send_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor object_key = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = aws_s3_test_put_object_request_new_without_body(\\\\\\\\n        allocator, &host_name, g_test_body_content_type, object_key, 1024 /*content_length*/, 0 /*flags*/);\\\\\\\\n    ASSERT_NOT_NULL(message);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options meta_request_options = {\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .message = message,\\\\\\\\n        .send_filepath = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"obviously_invalid_file_path\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &meta_request_options);\\\\\\\\n    ASSERT_NULL(meta_request);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_ERROR_FILE_INVALID_PATH, aws_last_error());\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the parallel read stream failed to send read the second part. */\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_bad_parallel_read_stream, s_test_s3_put_fail_object_bad_parallel_read_stream)\\\\\\\\nstatic int s_test_s3_put_fail_object_bad_parallel_read_stream(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    /* Override the parallel input stream new function to create a bad parallel input stream */\\\\\\\\n    client->vtable->parallel_input_stream_new_from_file = aws_parallel_input_stream_new_from_file_failure_tester;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 100,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_UNIMPLEMENTED, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_single_part_fail_object_inputstream_fail_reading,\\\\\\\\n    s_test_s3_put_single_part_fail_object_inputstream_fail_reading)\\\\\\\\nstatic int s_test_s3_put_single_part_fail_object_inputstream_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n                .content_length = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_single_part_fail_object_inputstream_mismatch_content_length,\\\\\\\\n    s_test_s3_put_single_part_fail_object_inputstream_mismatch_content_length)\\\\\\\\nstatic int s_test_s3_put_single_part_fail_object_inputstream_mismatch_content_length(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .content_length = MB_TO_BYTES(2),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_inputstream_fail_reading, s_test_s3_put_fail_object_inputstream_fail_reading)\\\\\\\\nstatic int s_test_s3_put_fail_object_inputstream_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n                .content_length = 10 * 1024 * 1024,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_IO_STREAM_READ_FAILED, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_fail_object_inputstream_mismatch_content_length,\\\\\\\\n    s_test_s3_put_fail_object_inputstream_mismatch_content_length)\\\\\\\\nstatic int s_test_s3_put_fail_object_inputstream_mismatch_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = false,\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .content_length = 10 * 1024 * 1024,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INCORRECT_CONTENT_LENGTH, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_clamp_part_size, s_test_s3_put_object_clamp_part_size)\\\\\\\\nstatic int s_test_s3_put_object_clamp_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n        .max_part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client_config.part_size < g_s3_min_upload_part_size);\\\\\\\\n    ASSERT_TRUE(client_config.max_part_size < g_s3_min_upload_part_size);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    /* Upload should now succeed even when specifying a smaller than allowed part size. */\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(test_results.part_size == g_s3_min_upload_part_size);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_get_expected_user_agent(struct aws_allocator *allocator, struct aws_byte_buf *dest) {\\\\\\\\n    AWS_ASSERT(allocator);\\\\\\\\n    AWS_ASSERT(dest);\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor forward_slash = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/\\\\\\\\\\\\\");\\\\\\\\n    const struct aws_byte_cursor single_space = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\" \\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_init(dest, allocator, 32));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_product_name));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &forward_slash));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_s3_client_version));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &single_space));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_platform));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &forward_slash));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_unknown));\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_add_user_agent_header, s_test_add_user_agent_header)\\\\\\\\nstatic int s_test_add_user_agent_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor single_space = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\" \\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_buf expected_user_agent_value_buf;\\\\\\\\n    s_get_expected_user_agent(allocator, &expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor expected_user_agent_value = aws_byte_cursor_from_buf(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_byte_cursor user_agent_value;\\\\\\\\n        AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n\\\\\\\\n        struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n\\\\\\\\n        aws_s3_add_user_agent_header(allocator, message);\\\\\\\\n\\\\\\\\n        struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(headers != NULL);\\\\\\\\n        ASSERT_SUCCESS(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value));\\\\\\\\n        ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n            user_agent_value.ptr, user_agent_value.len, expected_user_agent_value.ptr, expected_user_agent_value.len);\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        const struct aws_byte_cursor dummy_agent_header_value =\\\\\\\\n            AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_user_agent_product/dummy_user_agent_value\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        struct aws_byte_buf total_expected_user_agent_value_buf;\\\\\\\\n        aws_byte_buf_init(&total_expected_user_agent_value_buf, allocator, 64);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &dummy_agent_header_value);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &single_space);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &expected_user_agent_value);\\\\\\\\n\\\\\\\\n        struct aws_byte_cursor total_expected_user_agent_value =\\\\\\\\n            aws_byte_cursor_from_buf(&total_expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n        struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n        struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n        ASSERT_TRUE(headers != NULL);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_http_headers_add(headers, g_user_agent_header_name, dummy_agent_header_value));\\\\\\\\n\\\\\\\\n        aws_s3_add_user_agent_header(allocator, message);\\\\\\\\n\\\\\\\\n        {\\\\\\\\n            struct aws_byte_cursor user_agent_value;\\\\\\\\n            AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n            ASSERT_SUCCESS(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value));\\\\\\\\n            ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n                user_agent_value.ptr,\\\\\\\\n                user_agent_value.len,\\\\\\\\n                total_expected_user_agent_value.ptr,\\\\\\\\n                total_expected_user_agent_value.len);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_byte_buf_clean_up(&total_expected_user_agent_value_buf);\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&expected_user_agent_value_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_user_agent_meta_request_finished_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *results = meta_request->user_data;\\\\\\\\n    AWS_ASSERT(results != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = results->tester;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf expected_user_agent_value_buf;\\\\\\\\n    s_get_expected_user_agent(meta_request->allocator, &expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor expected_user_agent_value = aws_byte_cursor_from_buf(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = request->send_data.message;\\\\\\\\n    struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor user_agent_value;\\\\\\\\n    AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n\\\\\\\\n    AWS_FATAL_ASSERT(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value) == AWS_OP_SUCCESS);\\\\\\\\n    AWS_FATAL_ASSERT(aws_byte_cursor_eq(&user_agent_value, &expected_user_agent_value));\\\\\\\\n    aws_byte_buf_clean_up(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *original_meta_request_vtable =\\\\\\\\n        aws_s3_tester_get_meta_request_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    original_meta_request_vtable->finished_request(meta_request, request, error_code);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_s3_meta_request *s_s3_meta_request_factory_override_finished_request(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    const struct aws_s3_meta_request_options *options) {\\\\\\\\n    AWS_ASSERT(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = client->shutdown_callback_user_data;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *original_client_vtable =\\\\\\\\n        aws_s3_tester_get_client_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = original_client_vtable->meta_request_factory(client, options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *patched_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(tester, meta_request, NULL);\\\\\\\\n    patched_meta_request_vtable->finished_request = s_s3_test_user_agent_meta_request_finished_request;\\\\\\\\n\\\\\\\\n    return meta_request;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_test_sending_user_agent_create_client(struct aws_s3_tester *tester, struct aws_s3_client **client) {\\\\\\\\n    AWS_ASSERT(tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(tester, &client_options, client));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(tester, *client, NULL);\\\\\\\\n    patched_client_vtable->meta_request_factory = s_s3_meta_request_factory_override_finished_request;\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_auto_ranged_get_sending_user_agent, s_test_s3_auto_ranged_get_sending_user_agent)\\\\\\\\nstatic int s_test_s3_auto_ranged_get_sending_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = g_pre_existing_object_1MB,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_auto_ranged_put_sending_user_agent, s_test_s3_auto_ranged_put_sending_user_agent)\\\\\\\\nstatic int s_test_s3_auto_ranged_put_sending_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .put_options =\\\\\\\\n                {\\\\\\\\n                    .ensure_multipart = true,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_sending_meta_request_user_agent, s_test_s3_default_sending_meta_request_user_agent)\\\\\\\\nstatic int s_test_s3_default_sending_meta_request_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .default_type_options =\\\\\\\\n                {\\\\\\\\n                    .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                    .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n                },\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = g_pre_existing_object_1MB,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct range_requests_test_user_data {\\\\\\\\n    struct aws_http_headers *headers;\\\\\\\\n    struct aws_byte_buf *body_buffer;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic int s_range_requests_headers_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)response_status;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results = user_data;\\\\\\\\n    struct range_requests_test_user_data *test_user_data = test_results->tester->user_data;\\\\\\\\n\\\\\\\\n    if (test_user_data != NULL) {\\\\\\\\n        copy_http_headers(headers, test_user_data->headers);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_range_requests_receive_body_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)range_start;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results = user_data;\\\\\\\\n    struct range_requests_test_user_data *test_user_data = test_results->tester->user_data;\\\\\\\\n\\\\\\\\n    aws_byte_buf_append_dynamic(test_user_data->body_buffer, body);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_range_requests, s_test_s3_range_requests)\\\\\\\\nstatic int s_test_s3_range_requests(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor object_names[] = {\\\\\\\\n        g_pre_existing_object_1MB,\\\\\\\\n        g_pre_existing_object_kms_10MB,\\\\\\\\n        g_pre_existing_object_aes256_10MB,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    enum aws_s3_tester_sse_type object_sse_types[] = {\\\\\\\\n        AWS_S3_TESTER_SSE_NONE,\\\\\\\\n        AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        AWS_S3_TESTER_SSE_AES256,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor ranges[] = {\\\\\\\\n        // No range at all.\\\\\\\\n        {0, NULL},\\\\\\\\n\\\\\\\\n        // Single byte range.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=8-8\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Single byte range (first byte).\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-0\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // First 8K.  8K < client\\'s 16K part size.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-8191\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // First 0.5 MB.  0.5 MB < 1 MB test file.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-524287\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // 0.5 MB - 2 MB range.  This overlaps and goes beyond the 1 MB test file size.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=524288-2097151\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Get everything after the first 0.5 MB\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=524288-\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Last 0.5 MB\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=-524288\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Everything after first 8K\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=8192-\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Last 8K\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=-8192\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* List of headers that should have matching values between the auto_ranged_get and default (which sends the HTTP\\\\\\\\n     * request as-is to S3) meta request.*/\\\\\\\\n    const struct aws_byte_cursor headers_that_should_match[] = {\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"ETag\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Accept-Ranges\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Range\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Type\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Length\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Server\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"x-amz-server-side-encryption\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"x-amz-server-side-encryption-aws-kms-key\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* List of headers that are okay to be in the auto_ranged_get response and not in the default response, or vice\\\\\\\\n     * versa.*/\\\\\\\\n    const struct aws_byte_cursor headers_to_ignore[] = {\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Connection\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    const size_t num_object_names = AWS_ARRAY_SIZE(object_names);\\\\\\\\n    const size_t num_ranges = AWS_ARRAY_SIZE(ranges);\\\\\\\\n\\\\\\\\n    for (size_t object_name_index = 0; object_name_index < num_object_names; ++object_name_index) {\\\\\\\\n        for (size_t range_index = 0; range_index < num_ranges; ++range_index) {\\\\\\\\n\\\\\\\\n            AWS_LOGF_INFO(\\\\\\\\n                AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Testing object name %d and range %d\\\\\\\\\\\\\", (int)object_name_index, (int)range_index);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf range_get_buffer;\\\\\\\\n            aws_byte_buf_init(&range_get_buffer, allocator, 256);\\\\\\\\n            struct aws_http_headers *range_get_headers = aws_http_headers_new(allocator);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf verify_range_get_buffer;\\\\\\\\n            aws_byte_buf_init(&verify_range_get_buffer, allocator, 256);\\\\\\\\n            struct aws_http_headers *verify_range_get_headers = aws_http_headers_new(allocator);\\\\\\\\n\\\\\\\\n            struct aws_s3_tester_meta_request_options options = {\\\\\\\\n                .allocator = allocator,\\\\\\\\n                .client = client,\\\\\\\\n                .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n                .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n                .headers_callback = s_range_requests_headers_callback,\\\\\\\\n                .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n                .get_options =\\\\\\\\n                    {\\\\\\\\n                        .object_path = object_names[object_name_index],\\\\\\\\n                        .object_range = ranges[range_index],\\\\\\\\n                    },\\\\\\\\n                .sse_type = object_sse_types[object_name_index],\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            {\\\\\\\\n                struct range_requests_test_user_data test_user_data = {\\\\\\\\n                    .headers = range_get_headers,\\\\\\\\n                    .body_buffer = &range_get_buffer,\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                tester.user_data = &test_user_data;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            /* Send a default meta request (which just pushes the request directly to S3) with the same options to\\\\\\\\n             * verify the format of each request. */\\\\\\\\n            struct aws_s3_tester_meta_request_options verify_options = {\\\\\\\\n                .allocator = allocator,\\\\\\\\n                .client = client,\\\\\\\\n                .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n                .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n                .headers_callback = s_range_requests_headers_callback,\\\\\\\\n                .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n                .default_type_options =\\\\\\\\n                    {\\\\\\\\n                        .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                        .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n                    },\\\\\\\\n                .get_options =\\\\\\\\n                    {\\\\\\\\n                        .object_path = object_names[object_name_index],\\\\\\\\n                        .object_range = ranges[range_index],\\\\\\\\n                    },\\\\\\\\n                .sse_type = object_sse_types[object_name_index],\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            {\\\\\\\\n                struct range_requests_test_user_data test_user_data = {\\\\\\\\n                    .headers = verify_range_get_headers,\\\\\\\\n                    .body_buffer = &verify_range_get_buffer,\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                tester.user_data = &test_user_data;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &verify_options, NULL));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            /* Compare headers. */\\\\\\\\n            for (size_t i = 0; i < aws_http_headers_count(verify_range_get_headers); ++i) {\\\\\\\\n                struct aws_http_header verify_header;\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get_index(verify_range_get_headers, i, &verify_header));\\\\\\\\n\\\\\\\\n                bool ignore_header = false;\\\\\\\\n\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_to_ignore); ++j) {\\\\\\\\n                    if (aws_byte_cursor_eq_ignore_case(&headers_to_ignore[j], &verify_header.name)) {\\\\\\\\n                        ignore_header = true;\\\\\\\\n                        break;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                if (ignore_header) {\\\\\\\\n                    aws_http_headers_erase(range_get_headers, verify_header.name);\\\\\\\\n                    continue;\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                AWS_LOGF_INFO(\\\\\\\\n                    AWS_LS_S3_GENERAL,\\\\\\\\n                    \\\\\\\\\\\\\"%d,%d Checking for header \\\\\\\\\\\\\" PRInSTR,\\\\\\\\n                    (int)object_name_index,\\\\\\\\n                    (int)range_index,\\\\\\\\n                    AWS_BYTE_CURSOR_PRI(verify_header.name));\\\\\\\\n\\\\\\\\n                struct aws_byte_cursor header_value;\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get(range_get_headers, verify_header.name, &header_value));\\\\\\\\n\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_that_should_match); ++j) {\\\\\\\\n                    if (!aws_byte_cursor_eq_ignore_case(&headers_that_should_match[j], &verify_header.name)) {\\\\\\\\n                        continue;\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    AWS_LOGF_INFO(\\\\\\\\n                        AWS_LS_S3_GENERAL,\\\\\\\\n                        \\\\\\\\\\\\\"%d,%d Header Contents \\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\" vs \\\\\\\\\\\\\" PRInSTR,\\\\\\\\n                        (int)object_name_index,\\\\\\\\n                        (int)range_index,\\\\\\\\n                        AWS_BYTE_CURSOR_PRI(verify_header.value),\\\\\\\\n                        AWS_BYTE_CURSOR_PRI(header_value));\\\\\\\\n\\\\\\\\n                    ASSERT_TRUE(aws_byte_cursor_eq(&verify_header.value, &header_value));\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_erase(range_get_headers, verify_header.name));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            for (size_t i = 0; i < aws_http_headers_count(range_get_headers); ++i) {\\\\\\\\n                struct aws_http_header header;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get_index(range_get_headers, i, &header));\\\\\\\\n                bool ignore_header = false;\\\\\\\\n\\\\\\\\n                /* If the ignore header doesn\\'t exist in the verify_range_get_headers, ignore it here. */\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_to_ignore); ++j) {\\\\\\\\n                    if (aws_byte_cursor_eq_ignore_case(&headers_to_ignore[j], &header.name)) {\\\\\\\\n                        ignore_header = true;\\\\\\\\n                        break;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                if (ignore_header) {\\\\\\\\n                    ASSERT_SUCCESS(aws_http_headers_erase(range_get_headers, header.name));\\\\\\\\n                    continue;\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                AWS_LOGF_INFO(AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Left over header: \\\\\\\\\\\\\" PRInSTR, AWS_BYTE_CURSOR_PRI(header.name));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(aws_http_headers_count(range_get_headers) == 0);\\\\\\\\n\\\\\\\\n            /* Compare Body Contents */\\\\\\\\n            ASSERT_TRUE(aws_byte_buf_eq(&range_get_buffer, &verify_range_get_buffer));\\\\\\\\n\\\\\\\\n            aws_http_headers_release(range_get_headers);\\\\\\\\n            aws_byte_buf_clean_up(&range_get_buffer);\\\\\\\\n\\\\\\\\n            aws_http_headers_release(verify_range_get_headers);\\\\\\\\n            aws_byte_buf_clean_up(&verify_range_get_buffer);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_not_satisfiable_range, s_test_s3_not_satisfiable_range)\\\\\\\\nstatic int s_test_s3_not_satisfiable_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .headers_callback = s_range_requests_headers_callback,\\\\\\\\n        .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=2097151-\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_416_REQUESTED_RANGE_NOT_SATISFIABLE, results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_invalid_start_range_greator_than_end_range, s_test_s3_invalid_start_range_greator_than_end_range)\\\\\\\\nstatic int s_test_s3_invalid_start_range_greator_than_end_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=20-10\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n    ASSERT_INT_EQUALS(results.finished_error_code, AWS_ERROR_S3_INVALID_RANGE_HEADER);\\\\\\\\n    ASSERT_INT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_invalid_empty_file_with_range, s_test_s3_invalid_empty_file_with_range)\\\\\\\\nstatic int s_test_s3_invalid_empty_file_with_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_empty_object,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-0\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_416_REQUESTED_RANGE_NOT_SATISFIABLE, results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_copy_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor source_key,\\\\\\\\n    struct aws_byte_cursor destination_key,\\\\\\\\n    int expected_error_code,\\\\\\\\n    int expected_response_status,\\\\\\\\n    uint64_t expected_size) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    struct aws_byte_buf encoded_path;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n    AWS_ZERO_STRUCT(encoded_path);\\\\\\\\n\\\\\\\\n    aws_byte_buf_init(&encoded_path, allocator, source_key.len);\\\\\\\\n    aws_byte_buf_append_encoding_uri_path(&encoded_path, &source_key);\\\\\\\\n\\\\\\\\n    /* without copy_source_uri */\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    /* with path style copy_source_uri */\\\\\\\\n    char source_url[1024];\\\\\\\\n    snprintf(\\\\\\\\n        source_url,\\\\\\\\n        sizeof(source_url),\\\\\\\\n        \\\\\\\\\\\\\"https://s3.%s.amazonaws.com/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"\\\\\\\\\\\\\",\\\\\\\\n        g_test_s3_region.ptr,\\\\\\\\n        AWS_BYTE_CURSOR_PRI(source_bucket),\\\\\\\\n        AWS_BYTE_BUF_PRI(encoded_path));\\\\\\\\n    copy_source_uri = aws_byte_cursor_from_c_str(source_url);\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    /* with virtual style copy_source_uri */\\\\\\\\n    snprintf(\\\\\\\\n        source_url,\\\\\\\\n        sizeof(source_url),\\\\\\\\n        \\\\\\\\\\\\\"https://\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\".s3.%s.amazonaws.com/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(source_bucket),\\\\\\\\n        g_test_s3_region.ptr,\\\\\\\\n        AWS_BYTE_BUF_PRI(encoded_path));\\\\\\\\n    copy_source_uri = aws_byte_cursor_from_c_str(source_url);\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_byte_buf_clean_up(&encoded_path);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_small_object, s_test_s3_copy_small_object)\\\\\\\\nstatic int s_test_s3_copy_small_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, MB_TO_BYTES(1));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_small_object_special_char, s_test_s3_copy_small_object_special_char)\\\\\\\\nstatic int s_test_s3_copy_small_object_special_char(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB-@\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB_@\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, MB_TO_BYTES(1));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_copy_large_object_special_char, s_test_s3_multipart_copy_large_object_special_char)\\\\\\\\nstatic int s_test_s3_multipart_copy_large_object_special_char(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-2GB-@\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_2GB-@\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, GB_TO_BYTES(2));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_copy_large_object, s_test_s3_multipart_copy_large_object)\\\\\\\\nstatic int s_test_s3_multipart_copy_large_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-2GB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_2GB\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, GB_TO_BYTES(2));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_object_invalid_source_key, s_test_s3_copy_object_invalid_source_key)\\\\\\\\nstatic int s_test_s3_copy_object_invalid_source_key(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"__INVALID__\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/__INVALID__\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        source_key,\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_S3_INVALID_RESPONSE_STATUS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_404_NOT_FOUND,\\\\\\\\n        0 /* expected_size is ignored */);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test a bypass Copy Object meta request using a slash prefix in the x_amz_copy_source header.\\\\\\\\n * S3 supports both bucket/key and /bucket/key\\\\\\\\n * This test validates the fix for the bug described in https://sim.amazon.com/issues/AWSCRT-730\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_copy_source_prefixed_by_slash, s_test_s3_copy_source_prefixed_by_slash)\\\\\\\\nstatic int s_test_s3_copy_source_prefixed_by_slash(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK,\\\\\\\\n        MB_TO_BYTES(1),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_invalid_source_uri, s_test_s3_copy_invalid_source_uri)\\\\\\\\nstatic int s_test_s3_copy_invalid_source_uri(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"http://invalid-uri.com:80:80/path\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_MALFORMED_INPUT_STRING,\\\\\\\\n        0,\\\\\\\\n        MB_TO_BYTES(1),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test multipart Copy Object meta request using a slash prefix in the x_amz_copy_source header.\\\\\\\\n * S3 supports both bucket/key and /bucket/key\\\\\\\\n * This test validates the fix for the bug described in https://sim.amazon.com/issues/AWSCRT-730\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_copy_source_prefixed_by_slash_multipart, s_test_s3_copy_source_prefixed_by_slash_multipart)\\\\\\\\nstatic int s_test_s3_copy_source_prefixed_by_slash_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-256MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_256MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK,\\\\\\\\n        MB_TO_BYTES(256),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_get_object_mrap_helper(struct aws_allocator *allocator, bool multipart) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_signing_config_aws signing_config = tester.default_signing_config;\\\\\\\\n    /* Use Sigv4A for signing */\\\\\\\\n    signing_config.algorithm = AWS_SIGNING_ALGORITHM_V4_ASYMMETRIC;\\\\\\\\n    /* Use * for region to sign */\\\\\\\\n    signing_config.region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = multipart ? 64 * 1024 : 20 * 1024 * 1024,\\\\\\\\n        .region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\"),\\\\\\\\n        .signing_config = &signing_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0 /*flag*/));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .mrap_test = true,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test single-part get object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_less_than_part_size_mrap, s_test_s3_get_object_less_than_part_size_mrap)\\\\\\\\nstatic int s_test_s3_get_object_less_than_part_size_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_get_object_mrap_helper(allocator, false /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test multi-part get object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multipart_mrap, s_test_s3_get_object_multipart_mrap)\\\\\\\\nstatic int s_test_s3_get_object_multipart_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_get_object_mrap_helper(allocator, true /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_put_object_mrap_helper(struct aws_allocator *allocator, bool multipart) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_signing_config_aws signing_config = tester.default_signing_config;\\\\\\\\n    /* Use Sigv4A for signing */\\\\\\\\n    signing_config.algorithm = AWS_SIGNING_ALGORITHM_V4_ASYMMETRIC;\\\\\\\\n    /* Use * for region to sign */\\\\\\\\n    signing_config.region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n        .region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\"),\\\\\\\\n        .signing_config = &signing_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0 /*flag*/));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .mrap_test = true,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = multipart ? 10 : 1,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test single-part put object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_less_than_part_size_mrap, s_test_s3_put_object_less_than_part_size_mrap)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_put_object_mrap_helper(allocator, false /*multipart*/);\\\\\\\\n}\\\\\\\\n/* Test multi-part put object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multipart_mrap, s_test_s3_put_object_multipart_mrap)\\\\\\\\nstatic int s_test_s3_put_object_multipart_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_put_object_mrap_helper(allocator, true /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_http_message *s_put_object_request_new(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor key,\\\\\\\\n    struct aws_byte_cursor endpoint,\\\\\\\\n    struct aws_input_stream *body_stream,\\\\\\\\n    uint64_t content_length) {\\\\\\\\n\\\\\\\\n    AWS_PRECONDITION(allocator);\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n\\\\\\\\n    if (message == NULL) {\\\\\\\\n        return NULL;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if (aws_http_message_set_request_path(message, key)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_http_header host_header = {\\\\\\\\n        .name = g_host_header_name,\\\\\\\\n        .value = endpoint,\\\\\\\\n    };\\\\\\\\n    if (aws_http_message_add_header(message, host_header)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    char content_length_c_str[1024];\\\\\\\\n    snprintf(content_length_c_str, sizeof(content_length_c_str), \\\\\\\\\\\\\"%\\\\\\\\\\\\\" PRIu64, content_length);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_length_header = {\\\\\\\\n        .name = g_content_length_header_name,\\\\\\\\n        .value = aws_byte_cursor_from_c_str(content_length_c_str),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    if (aws_http_message_add_header(message, content_length_header)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if (aws_http_message_set_request_method(message, aws_http_method_put)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_set_body_stream(message, body_stream);\\\\\\\\n\\\\\\\\n    return message;\\\\\\\\n\\\\\\\\nerror_clean_up_message:\\\\\\\\n\\\\\\\\n    if (message != NULL) {\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n        message = NULL;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return NULL;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct put_object_pause_resume_test_data {\\\\\\\\n    struct aws_mutex mutex;\\\\\\\\n    struct aws_condition_variable c_var;\\\\\\\\n\\\\\\\\n    /* execution of the test meta request completed */\\\\\\\\n    bool execution_completed;\\\\\\\\n\\\\\\\\n    /* accumulator of amount of bytes uploaded */\\\\\\\\n    struct aws_atomic_var total_bytes_uploaded;\\\\\\\\n\\\\\\\\n    /* the offset where upload should be paused */\\\\\\\\n    struct aws_atomic_var request_pause_offset;\\\\\\\\n\\\\\\\\n    struct aws_atomic_var pause_requested;\\\\\\\\n\\\\\\\\n    struct aws_atomic_var pause_result;\\\\\\\\n\\\\\\\\n    /* the persistable state of the paused request */\\\\\\\\n    struct aws_atomic_var persistable_state_ptr;\\\\\\\\n\\\\\\\\n    int meta_request_error_code;\\\\\\\\n    int response_status_code;\\\\\\\\n\\\\\\\\n    /* (Optional) content_length to send. If not set, use the length of the input stream. */\\\\\\\\n    uint64_t content_length;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic void s_put_pause_resume_meta_request_finish(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *meta_request_result,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    struct aws_s3_tester *tester = user_data;\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = tester->user_data;\\\\\\\\n\\\\\\\\n    /* if error response body is available, dump it to test result to help investigation of failed tests */\\\\\\\\n    if (meta_request_result->error_response_body != NULL && meta_request_result->error_response_body->len > 0) {\\\\\\\\n        AWS_LOGF_ERROR(\\\\\\\\n            AWS_LS_S3_GENERAL,\\\\\\\\n            \\\\\\\\\\\\\"Response error body: %.*s\\\\\\\\\\\\\",\\\\\\\\n            (int)meta_request_result->error_response_body->len,\\\\\\\\n            meta_request_result->error_response_body->buffer);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_mutex_lock(&test_data->mutex);\\\\\\\\n    test_data->meta_request_error_code = meta_request_result->error_code;\\\\\\\\n    test_data->response_status_code = meta_request_result->response_status;\\\\\\\\n    test_data->execution_completed = true;\\\\\\\\n    aws_mutex_unlock(&test_data->mutex);\\\\\\\\n    aws_condition_variable_notify_one(&test_data->c_var);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic bool s_put_pause_resume_test_completion_predicate(void *arg) {\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = arg;\\\\\\\\n    return test_data->execution_completed;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Patched version of aws_s3_meta_request_vtable->finished_request() for pause/resume tests.\\\\\\\\n * It can pause the meta-request immediately after a part completes.\\\\\\\\n * We use a patched vtable, instead of the progress_callback, because\\\\\\\\n * the progress_callback fires on another thread, which might be too late to\\\\\\\\n * prevent more parts from being sent. */\\\\\\\\nstatic void s_meta_request_finished_request_patched_for_pause_resume_tests(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    struct aws_s3_tester *tester = meta_request->user_data;\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = tester->user_data;\\\\\\\\n    AWS_ASSERT(test_data);\\\\\\\\n\\\\\\\\n    if ((error_code == AWS_ERROR_SUCCESS) && (meta_request->type == AWS_S3_META_REQUEST_TYPE_PUT_OBJECT) &&\\\\\\\\n        (request->request_tag == AWS_S3_AUTO_RANGED_PUT_REQUEST_TAG_PART)) {\\\\\\\\n\\\\\\\\n        if (!request->is_noop) {\\\\\\\\n            /* If the request is noop, we are not really uploading the part */\\\\\\\\n            aws_atomic_fetch_add(&test_data->total_bytes_uploaded, request->request_body.len);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        size_t total_bytes_uploaded = aws_atomic_load_int(&test_data->total_bytes_uploaded);\\\\\\\\n        uint64_t offset_to_pause = aws_atomic_load_int(&test_data->request_pause_offset);\\\\\\\\n\\\\\\\\n        if (total_bytes_uploaded >= offset_to_pause) {\\\\\\\\n            /* offset of the upload at which we should pause was reached. let\\'s pause the upload */\\\\\\\\n            /* if the meta request has already been paused previously, do nothing. */\\\\\\\\n            size_t expected = false;\\\\\\\\n            bool request_pause = aws_atomic_compare_exchange_int(&test_data->pause_requested, &expected, true);\\\\\\\\n            if (request_pause) {\\\\\\\\n                struct aws_s3_meta_request_resume_token *resume_token = NULL;\\\\\\\\n                int pause_result = aws_s3_meta_request_pause(meta_request, &resume_token);\\\\\\\\n                struct aws_byte_cursor upload_id = aws_s3_meta_request_resume_token_upload_id(resume_token);\\\\\\\\n                /* Make Sure we have upload ID */\\\\\\\\n                AWS_FATAL_ASSERT(aws_byte_cursor_eq_c_str(&upload_id, \\\\\\\\\\\\\"\\\\\\\\\\\\\") == false);\\\\\\\\n                aws_atomic_store_int(&test_data->pause_result, pause_result);\\\\\\\\n                aws_atomic_store_ptr(&test_data->persistable_state_ptr, resume_token);\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Continue with original vtable function... */\\\\\\\\n    struct aws_s3_meta_request_vtable *original_meta_request_vtable =\\\\\\\\n        aws_s3_tester_get_meta_request_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    original_meta_request_vtable->finished_request(meta_request, request, error_code);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_s3_meta_request *s_meta_request_factory_patch_for_pause_resume_tests(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    const struct aws_s3_meta_request_options *options) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(client != NULL);\\\\\\\\n    struct aws_s3_tester *tester = client->shutdown_callback_user_data;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *original_client_vtable =\\\\\\\\n        aws_s3_tester_get_client_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = original_client_vtable->meta_request_factory(client, options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *patched_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(tester, meta_request, NULL);\\\\\\\\n    patched_meta_request_vtable->finished_request = s_meta_request_finished_request_patched_for_pause_resume_tests;\\\\\\\\n\\\\\\\\n    return meta_request;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* total length of the object to simulate for upload */\\\\\\\\nstatic const size_t s_pause_resume_object_length_128MB = 128 * 1024 * 1024;\\\\\\\\n\\\\\\\\n/* this runs when a RESUMED upload is about to successfully complete */\\\\\\\\nstatic int s_pause_resume_upload_review_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_upload_review *review,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)user_data;\\\\\\\\n    struct aws_allocator *allocator = meta_request->allocator;\\\\\\\\n\\\\\\\\n    /* A bit hacky, but stream the same data that the test always uploads, and ensure the checksums match */\\\\\\\\n\\\\\\\\n    struct aws_input_stream *reread_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    for (size_t part_index = 0; part_index < review->part_count; ++part_index) {\\\\\\\\n        const struct aws_s3_upload_part_review *part_review = &review->part_array[part_index];\\\\\\\\n        struct aws_byte_buf reread_part_buf;\\\\\\\\n        ASSERT_TRUE(part_review->size <= SIZE_MAX);\\\\\\\\n        aws_byte_buf_init(&reread_part_buf, allocator, (size_t)part_review->size);\\\\\\\\n        ASSERT_SUCCESS(aws_input_stream_read(reread_stream, &reread_part_buf));\\\\\\\\n\\\\\\\\n        /* part sizes should match */\\\\\\\\n        ASSERT_UINT_EQUALS(part_review->size, reread_part_buf.len);\\\\\\\\n\\\\\\\\n        if (review->checksum_algorithm != AWS_SCA_NONE) {\\\\\\\\n            struct aws_byte_cursor reread_part_cursor = aws_byte_cursor_from_buf(&reread_part_buf);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf checksum_buf;\\\\\\\\n            aws_byte_buf_init(&checksum_buf, allocator, 128);\\\\\\\\n            ASSERT_SUCCESS(\\\\\\\\n                aws_checksum_compute(allocator, review->checksum_algorithm, &reread_part_cursor, &checksum_buf));\\\\\\\\n            struct aws_byte_cursor checksum_cursor = aws_byte_cursor_from_buf(&checksum_buf);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf encoded_checksum_buf;\\\\\\\\n            aws_byte_buf_init(&encoded_checksum_buf, allocator, 128);\\\\\\\\n\\\\\\\\n            ASSERT_SUCCESS(aws_base64_encode(&checksum_cursor, &encoded_checksum_buf));\\\\\\\\n\\\\\\\\n            /* part checksums should match */\\\\\\\\n            ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n                encoded_checksum_buf.buffer,\\\\\\\\n                encoded_checksum_buf.len,\\\\\\\\n                part_review->checksum.ptr,\\\\\\\\n                part_review->checksum.len);\\\\\\\\n\\\\\\\\n            aws_byte_buf_clean_up(&checksum_buf);\\\\\\\\n            aws_byte_buf_clean_up(&encoded_checksum_buf);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_byte_buf_clean_up(&reread_part_buf);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_input_stream_release(reread_stream);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_pause_resume_receive_body_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)range_start;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    // TODO: this is a bit hacky, as it will try to compare every partial get result we receive to the input stream.\\\\\\\\n    // Something better?\\\\\\\\n\\\\\\\\n    struct aws_input_stream *input_stream =\\\\\\\\n        aws_s3_test_input_stream_new(meta_request->allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf buf;\\\\\\\\n    aws_byte_buf_init(&buf, meta_request->allocator, (size_t)range_start);\\\\\\\\n    aws_input_stream_read(input_stream, &buf);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&buf);\\\\\\\\n    aws_byte_buf_init(&buf, meta_request->allocator, body->len);\\\\\\\\n    aws_input_stream_read(input_stream, &buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor input_cur = aws_byte_cursor_from_buf(&buf);\\\\\\\\n\\\\\\\\n    bool body_matches_expected = aws_byte_cursor_eq(&input_cur, body);\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(input_stream);\\\\\\\\n    aws_byte_buf_clean_up(&buf);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_matches_expected);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_pause_resume_helper(\\\\\\\\n    struct aws_s3_tester *tester,\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    struct put_object_pause_resume_test_data *test_data,\\\\\\\\n    struct aws_byte_cursor destination_key,\\\\\\\\n    struct aws_input_stream *upload_body_stream,\\\\\\\\n    struct aws_s3_meta_request_resume_token *resume_state,\\\\\\\\n    enum aws_s3_checksum_algorithm checksum_algorithm,\\\\\\\\n    int expected_error_code,\\\\\\\\n    int expected_response_status) {\\\\\\\\n\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    if (resume_state == NULL) {\\\\\\\\n        /* If we\\'re going to cancel this operation, limit the client to 1 HTTP connection.\\\\\\\\n         * That way, we don\\'t end up \\\\\\\\\\\\\"cancelling\\\\\\\\\\\\\" but all the parts actually\\\\\\\\n         * succeed anyway on other connections */\\\\\\\\n        client_config.max_active_connections_override = 1;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(tester, client, NULL);\\\\\\\\n    patched_client_vtable->meta_request_factory = s_meta_request_factory_patch_for_pause_resume_tests;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    /* creates a PutObject request */\\\\\\\\n    int64_t content_length = test_data->content_length;\\\\\\\\n    if (content_length == 0) {\\\\\\\\n        /* If not set, use the length of the input stream */\\\\\\\\n        aws_input_stream_get_length(upload_body_stream, &content_length);\\\\\\\\n    }\\\\\\\\n    struct aws_http_message *message = s_put_object_request_new(\\\\\\\\n        allocator, destination_key, aws_byte_cursor_from_c_str(endpoint), upload_body_stream, content_length);\\\\\\\\n\\\\\\\\n    test_data->c_var = (struct aws_condition_variable)AWS_CONDITION_VARIABLE_INIT;\\\\\\\\n    aws_mutex_init(&test_data->mutex);\\\\\\\\n    test_data->execution_completed = false;\\\\\\\\n\\\\\\\\n    tester->user_data = test_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_checksum_config checksum_config = {\\\\\\\\n        .checksum_algorithm = checksum_algorithm,\\\\\\\\n        .location = checksum_algorithm == AWS_SCA_NONE ? AWS_SCL_NONE : AWS_SCL_TRAILER,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options meta_request_options = {\\\\\\\\n        .user_data = tester,\\\\\\\\n        .body_callback = NULL,\\\\\\\\n        .signing_config = client_config.signing_config,\\\\\\\\n        .finish_callback = s_put_pause_resume_meta_request_finish,\\\\\\\\n        .headers_callback = NULL,\\\\\\\\n        .upload_review_callback = s_pause_resume_upload_review_callback,\\\\\\\\n        .message = message,\\\\\\\\n        .shutdown_callback = NULL,\\\\\\\\n        .resume_token = NULL,\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_config = &checksum_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    if (resume_state) {\\\\\\\\n        meta_request_options.resume_token = resume_state;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &meta_request_options);\\\\\\\\n    ASSERT_NOT_NULL(meta_request);\\\\\\\\n\\\\\\\\n    /* wait completion of the meta request */\\\\\\\\n    aws_mutex_lock(&test_data->mutex);\\\\\\\\n    aws_condition_variable_wait_pred(\\\\\\\\n        &test_data->c_var, &test_data->mutex, s_put_pause_resume_test_completion_predicate, test_data);\\\\\\\\n    aws_mutex_unlock(&test_data->mutex);\\\\\\\\n\\\\\\\\n    /* assert error_code and response_status_code */\\\\\\\\n    ASSERT_INT_EQUALS(expected_error_code, test_data->meta_request_error_code);\\\\\\\\n    ASSERT_INT_EQUALS(expected_response_status, test_data->response_status_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_mutex_clean_up(&test_data->mutex);\\\\\\\\n    aws_http_message_destroy(message);\\\\\\\\n\\\\\\\\n    /* release this client with its crazy patched vtables */\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_wait_for_client_shutdown(tester);\\\\\\\\n    tester->bound_to_client = false;\\\\\\\\n\\\\\\\\n    if (expected_error_code == AWS_ERROR_SUCCESS) {\\\\\\\\n        /* get the file and verify it matches what we uploaded */\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .body_callback = s_pause_resume_receive_body_callback,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = destination_key,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_test_results results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(tester, &options, &results));\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_happy_path, s_test_s3_put_pause_resume_happy_path)\\\\\\\\nstatic int s_test_s3_put_pause_resume_happy_path(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded < s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_all_parts_done, s_test_s3_put_pause_resume_all_parts_done)\\\\\\\\nstatic int s_test_s3_put_pause_resume_all_parts_done(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_all_parts_done.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 128 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_NONE,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    AWS_LOGF_INFO(AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Persistable state %p\\\\\\\\\\\\\", persistable_state);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_NONE,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_INT_EQUALS(0, bytes_uploaded);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_resume_data, s_test_s3_put_pause_resume_invalid_resume_data)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_resume_data(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_resume_data.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_s3_test_input_stream_new_with_value_type(\\\\\\\\n        allocator, s_pause_resume_object_length_128MB, TEST_STREAM_VALUE_2);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_RESUMED_PART_CHECKSUM_MISMATCH,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded < s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_resume_stream, s_test_s3_put_pause_resume_invalid_resume_stream)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_resume_stream(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_bad_resume_stream.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_release(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* a bad input stream to resume from */\\\\\\\\n    struct aws_input_stream_tester_options stream_options = {\\\\\\\\n        .autogen_length = s_pause_resume_object_length_128MB,\\\\\\\\n        .fail_on_nth_read = 1,\\\\\\\\n        .fail_with_error_code = AWS_IO_STREAM_READ_FAILED,\\\\\\\\n    };\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_input_stream_new_tester(allocator, &stream_options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    /* Each failed resume will delete the MPU */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_IO_STREAM_READ_FAILED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* resume didn\\'t read any bytes because the bad input stream failed to read. */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded == 0);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_release(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_content_length, s_test_s3_put_pause_resume_invalid_content_length)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_bad_resume_stream.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n    test_data.content_length = s_pause_resume_object_length_128MB;\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_release(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* a small input stream to resume with */\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_s3_test_input_stream_new(allocator, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    /* Each failed resume will delete the MPU */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_INCORRECT_CONTENT_LENGTH,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* resume didn\\'t read any bytes because the bad input stream failed to read. */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded == 0);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_release(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Most basic test of the upload_review_callback */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review, s_test_s3_upload_review)\\\\\\\\nstatic int s_test_s3_upload_review(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_CRC32.txt\\\\\\\\\\\\\"),\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(2, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(8), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(10) - MB_TO_BYTES(8), test_results.upload_review.part_sizes_array[1]);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_SCA_CRC32, test_results.upload_review.checksum_algorithm);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"9J8ZNA==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"BNjxzQ==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[1]));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test upload_review_callback when Content-Length is not declared */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_no_content_length, s_test_s3_upload_review_no_content_length)\\\\\\\\nstatic int s_test_s3_upload_review_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_1MB_CRC32.txt\\\\\\\\\\\\\"),\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"4hP4ig==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_upload_review_raise_canceled_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_upload_review *review,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)review;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    return aws_raise_error(AWS_ERROR_S3_CANCELED);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that if upload_review_callback raises an error, then the upload is canceled. */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_rejection, s_test_s3_upload_review_rejection)\\\\\\\\nstatic int s_test_s3_upload_review_rejection(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_rejection.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    /* Send meta-request that will raise an error from the review_upload_callback */\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .upload_review_callback = s_upload_review_raise_canceled_error,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* Check that meta-request failed with the error raised by the upload_review_callback */\\\\\\\\n    ASSERT_INT_EQUALS(AWS_ERROR_S3_CANCELED, test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    /*\\\\\\\\n     * Now check that the upload did not complete on the server either\\\\\\\\n     * (server should have received AbortMultipartUpload).\\\\\\\\n     * Check by attempting to GET the object, which should fail with 404 NOT FOUND.\\\\\\\\n     */\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &test_results));\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_404_NOT_FOUND, test_results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(test_results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(test_results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(test_results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that an MPU can be done with checksum location = NONE as long as an upload review callback\\\\\\\\n * is used, and the resulting object doesn\\'t have checksums uploaded. */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_checksum_location_none, s_test_s3_upload_review_checksum_location_none)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(2, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(5), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(5), test_results.upload_review.part_sizes_array[1]);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_SCA_CRC32, test_results.upload_review.checksum_algorithm);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"7/xUXw==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"PCOjcw==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[1]));\\\\\\\\n\\\\\\\\n    /* S3 will store the crc64 checksum for the whole object, and we can still have validate the checksum, but the algo\\\\\\\\n     * be validated will be crc64, instead of the crc32 we get from the client. */\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC64NVME,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_checksum_location_none_async, s_test_s3_upload_review_checksum_location_none_async)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none_async(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Trying to reach the noop case of async read */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_upload_review_checksum_location_none_async_noop_part,\\\\\\\\n    s_test_s3_upload_review_checksum_location_none_async_noop_part)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none_async_noop_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n                .eof_requires_extra_read = true, /* don\\'t report EOF until it tries to read 2nd part */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_http_stream *s_http_connection_make_request_patch(\\\\\\\\n    struct aws_http_connection *client_connection,\\\\\\\\n    const struct aws_http_make_request_options *options) {\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = options->request;\\\\\\\\n    struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n    struct aws_byte_cursor out_value;\\\\\\\\n    int e = aws_http_headers_get(headers, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"Content-Length\\\\\\\\\\\\\"), &out_value);\\\\\\\\n    AWS_FATAL_ASSERT(e == AWS_OP_ERR); // Assert that the header is not present\\\\\\\\n    AWS_FATAL_ASSERT(aws_last_error() == AWS_ERROR_HTTP_HEADER_NOT_FOUND);\\\\\\\\n\\\\\\\\n    return aws_http_connection_make_request(client_connection, options);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_get_without_content_length, s_test_s3_default_get_without_content_length)\\\\\\\\nstatic int s_test_s3_default_get_without_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    /* Send default type */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.message = message;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct aws_string *test_helper(struct aws_allocator *allocator) {\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n    return host_name;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_get, aws_test_s3_default_get)\\\\\\\\nstatic int aws_test_s3_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_string *hsot_name = test_helper(allocator);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(hsot_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    /* Send default type */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.message = message;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\",\\\\n  \\\\\"encoding\\\\\": \\\\\"base64\\\\\",\\\\n  \\\\\"_links\\\\\": {\\\\n    \\\\\"self\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests/s3_data_plane_tests.c?ref=dummy-delete-me\\\\\",\\\\n    \\\\\"git\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/git/blobs/dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n    \\\\\"html\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\"\\\\n  }\\\\n}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Let me now query the knowledge base about the aws-c-s3 library to provide context for my review:\"},{\"type\":\"tool_use\",\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"input\":{\"knowledge_base_id\":\"8BRIG4RFWU\",\"query\":\"What is the aws-c-s3 library? What are its main features and purpose?\"},\"id\":\"toolu_bdrk_011HfFJVYeHDSBzpvq9qcvMJ\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_011HfFJVYeHDSBzpvq9qcvMJ\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"## AWS C S3 The AWS-C-S3 library is an asynchronous AWS S3 client focused on maximizing throughput and network utilization. ### Key features: - **Automatic Request Splitting**: Improves throughput by automatically splitting the request into part-sized chunks and performing parallel uploads/downloads of these chunks over multiple connections. There\\'s a cap on the throughput of single S3 connection, the only way to go faster is multiple parallel connections. - **Automatic Retries**: Increases resilience by retrying individual failed chunks of a file transfer, eliminating the need to restart transfers from scratch after an intermittent error. - **DNS Load Balancing**: DNS resolver continuously harvests Amazon S3 IP addresses. When load is spread across the S3 fleet, overall throughput more reliable than if all connections are going to a single IP. - **Advanced Network Management**: The client incorporates automatic request parallelization, effective timeouts and retries, and efficient connection reuse. This approach helps to maximize throughput and network utilization, and to avoid network overloads. - **Thread Pools and Async I/O**: Avoids bottlenecks associated with single-thread processing. - **Parallel Reads**: When uploading a large file from disk, reads from multiple parts of the file in parallel.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.68293357}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"};  enum aws_s3_subject {     AWS_LS_S3_GENERAL = AWS_LOG_SUBJECT_BEGIN_RANGE(AWS_C_S3_PACKAGE_ID),     AWS_LS_S3_CLIENT,     AWS_LS_S3_CLIENT_STATS,     AWS_LS_S3_REQUEST,     AWS_LS_S3_META_REQUEST,     AWS_LS_S3_ENDPOINT,     AWS_LS_S3_LAST = AWS_LOG_SUBJECT_END_RANGE(AWS_C_S3_PACKAGE_ID) };  struct aws_s3_platform_info;  #ifdef _MSC_VER #    pragma warning(push) #    pragma warning(disable : 4626) /* assignment operator was implicitly defined as deleted */ #    pragma warning(disable : 5027) /* move assignment operator was implicitly defined as deleted */ #endif  struct aws_s3_platform_info {     /* name of the instance-type: example c5n.18xlarge */     struct aws_byte_cursor instance_type;     /* max throughput for this instance type, in gigabits per second */     double max_throughput_gbps;     /* The current build of this library specifically knows an optimal configuration for this      * platform */     bool has_recommended_configuration; };  #ifdef _MSC_VER #    pragma warning(pop) #endif  AWS_EXTERN_C_BEGIN  /**  * Initializes internal datastructures used by aws-c-s3.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/include/aws/s3/s3.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.55248797}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"type;     }     return AWS_S3_REQUEST_TYPE_UNKNOWN; }  static bool s_library_initialized = false; static struct aws_allocator *s_library_allocator = NULL; static struct aws_s3_platform_info_loader *s_loader;  void aws_s3_library_init(struct aws_allocator *allocator) {     if (s_library_initialized) {         return;     }      if (allocator) {         s_library_allocator = allocator;     } else {         s_library_allocator = aws_default_allocator();     }      aws_auth_library_init(s_library_allocator);     aws_http_library_init(s_library_allocator);     aws_checksums_library_init(s_library_allocator);      aws_register_error_info(&s_error_list);     aws_register_log_subject_info_list(&s_s3_log_subject_list);     s_loader = aws_s3_platform_info_loader_new(allocator);     AWS_FATAL_ASSERT(s_loader);     s_s3_request_type_info_init(allocator);      s_library_initialized = true; }  const struct aws_s3_platform_info *aws_s3_get_current_platform_info(void) {     return aws_s3_get_platform_info_for_current_environment(s_loader); }  struct aws_byte_cursor aws_s3_get_current_platform_ec2_intance_type(bool cached_only) {     return aws_s3_get_ec2_instance_type(s_loader, cached_only); }  struct aws_array_list aws_s3_get_platforms_with_recommended_config(void) {     return aws_s3_get_recommended_platforms(s_loader); }\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/source/s3.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.54078794}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/byte_buf.h> #include <aws/common/clock.h> #include <aws/common/common.h> #include <aws/common/environment.h> #include <aws/common/ref_count.h> #include <aws/http/request_response.h> #include <aws/io/channel_bootstrap.h> #include <aws/io/event_loop.h> #include <aws/io/host_resolver.h> #include <aws/io/stream.h> #include <aws/io/tls_channel_handler.h> #include <aws/testing/aws_test_harness.h> #include <inttypes.h> #include <stdio.h>  /* Ensure the library can go through the init/cleanup cycle multiple times */ AWS_TEST_CASE(test_s3_library_init_cleanup_init_cleanup, s_test_s3_library_init_cleanup_init_cleanup) static int s_test_s3_library_init_cleanup_init_cleanup(struct aws_allocator *allocator, void *ctx) {     (void)ctx;      aws_s3_library_init(allocator);     aws_s3_library_clean_up();      aws_s3_library_init(allocator);\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_util_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5358852}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_auto_ranged_get.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_auto_ranged_put.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_buffer_pool.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_copy_object.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_default_meta_request.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_parallel_input_stream.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_request_messages.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3express_credentials_provider_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3express_credentials_provider.h\\\\\\\\\\\\\"  #include <aws/auth/credentials.h> #include <aws/common/assert.h> #include <aws/common/atomics.h> #include <aws/common/clock.h> #include <aws/common/device_random.h> #include <aws/common/json.h> #include <aws/common/priority_queue.h> #include <aws/common/string.h> #include <aws/common/system_info.h> #include <aws/http/connection.h> #include <aws/http/connection_manager.h> #include <\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/source/s3_client.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5308164}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"## AWS C Common [![GitHub](https://img.shields.io/github/license/awslabs/aws-c-common.svg)](https://github.com/awslabs/aws-c-common/blob/main/LICENSE) Core c99 package for AWS SDK for C. Includes cross-platform primitives, configuration, data structures, and error handling. ## License This library is licensed under the Apache 2.0 License. ## Usage ### Building aws-c-common uses CMake for setting up build environments. This library has no non-kernel dependencies so the build is quite simple. For example: git clone git@github.com:awslabs/aws-c-common.git aws-c-common mkdir aws-c-common-build cd aws-c-common-build cmake ../aws-c-common make -j 12 make test sudo make install Keep in mind that CMake supports multiple build systems, so for each platform you can pass your own build system as the `-G` option. For example: cmake -GNinja ../aws-c-common ninja build ninja test sudo ninja install Or on windows, cmake -G \\\\\\\\\\\\\"Visual Studio 14 2015 Win64\\\\\\\\\\\\\" ..\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.52190685}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_platform_info.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_request.h\\\\\\\\\\\\\" #include <aws/auth/credentials.h> #include <aws/common/clock.h> #include <aws/common/encoding.h> #include <aws/common/string.h> #include <aws/common/xml_parser.h> #include <aws/http/request_response.h> #include <aws/s3/s3_client.h> #include <inttypes.h>  #ifdef _MSC_VER /* sscanf warning (not currently scanning for strings) */ #    pragma warning(disable : 4996) #endif  const struct aws_byte_cursor g_s3_client_version = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(AWS_S3_CLIENT_VERSION); const struct aws_byte_cursor g_s3_service_name = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"s3\\\\\\\\\\\\\"); const struct aws_byte_cursor g_s3express_service_name = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"s3express\\\\\\\\\\\\\"); const struct aws_byte_cursor g_host_header_name = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Host\\\\\\\\\\\\\"); const struct aws_byte_cursor g_range_header_name =\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/source/s3_util.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5187064}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"include(GNUInstallDirs)  file(GLOB AWS_S3_ROOT_HEADERS         \\\\\\\\\\\\\"include/aws/s3/*.h\\\\\\\\\\\\\"         )  file(GLOB AWS_S3_PRIVATE_HEADERS         \\\\\\\\\\\\\"include/aws/s3/private/*.h\\\\\\\\\\\\\"         )  file(GLOB AWS_S3_ROOT_SRC         \\\\\\\\\\\\\"source/*.c\\\\\\\\\\\\\"         ) file(GLOB AWS_S3_ENDPOINT_RESOLVER_SRC         \\\\\\\\\\\\\"source/s3_endpoint_resolver/*.c\\\\\\\\\\\\\" )  if (WIN32)     if (MSVC)         source_group(\\\\\\\\\\\\\"Header Files\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\aws\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\s3\\\\\\\\\\\\\" FILES ${AWS_S3_HEADERS})         source_group(\\\\\\\\\\\\\"Source Files\\\\\\\\\\\\\" FILES ${AWS_S3_SRC})     endif () endif()  file(GLOB S3_HEADERS         ${AWS_S3_ROOT_HEADERS}         ${AWS_S3_PRIVATE_HEADERS}         ${AWS_S3_EXTERNAL_HEADERS}         )  file(GLOB S3_SRC         ${AWS_S3_ROOT_SRC}         ) if (AWS_ENABLE_S3_ENDPOINT_RESOLVER)     list(APPEND S3_SRC ${AWS_S3_ENDPOINT_RESOLVER_SRC}) endif()  add_library(${PROJECT_NAME} ${S3_HEADERS} ${S3_SRC}) aws_set_common_properties(${PROJECT_NAME}) aws_prepare_symbol_visibility_args(${PROJECT_NAME} \\\\\\\\\\\\\"AWS_S3\\\\\\\\\\\\\") aws_check_headers(${PROJECT_NAME} ${AWS_S3_ROOT_HEADERS})  aws_add_sanitizers(${PROJECT_NAME})  # We are not ABI stable yet set_target_properties(${PROJECT_NAME} PROPERTIES VERSION\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/CMakeLists.txt\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5181896}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"* platform */     bool has_recommended_configuration; };  #ifdef _MSC_VER #    pragma warning(pop) #endif  AWS_EXTERN_C_BEGIN  /**  * Initializes internal datastructures used by aws-c-s3.  * Must be called before using any functionality in aws-c-s3.  */ AWS_S3_API void aws_s3_library_init(struct aws_allocator *allocator);  /**  * Shuts down the internal datastructures used by aws-c-s3.  */ AWS_S3_API void aws_s3_library_clean_up(void);  /*  * Returns the aws_s3_platform_info for current platform  * NOTE: THIS API IS EXPERIMENTAL AND UNSTABLE  */ AWS_S3_API const struct aws_s3_platform_info *aws_s3_get_current_platform_info(void);  /*  * Returns the ec2 instance_type for current platform if possible  * NOTE: THIS API IS EXPERIMENTAL AND UNSTABLE  */ AWS_S3_API struct aws_byte_cursor aws_s3_get_current_platform_ec2_intance_type(bool cached_only);  /*  * Retrieves a list of EC2 instance types with recommended configuration.  * Returns aws_array_list<aws_byte_cursor>. The caller is responsible for cleaning up the array list.  */ AWS_S3_API struct aws_array_list aws_s3_get_platforms_with_recommended_config(void);  AWS_EXTERN_C_END AWS_POP_SANE_WARNING_LEVEL  #endif /* AWS_S3_H */\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/include/aws/s3/s3.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5181247}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include <aws/common/condition_variable.h> #include <aws/common/mutex.h> #include <aws/s3/s3.h> #include <aws/s3/s3_client.h>  struct app_ctx {     struct aws_allocator *allocator;     struct aws_s3_client *client;     struct aws_credentials_provider *credentials_provider;     struct aws_client_bootstrap *client_bootstrap;     struct aws_logger logger;     struct aws_mutex mutex;     struct aws_condition_variable c_var;     bool execution_completed;     struct aws_signing_config_aws signing_config;     const char *region;     enum aws_log_level log_level;     bool help_requested;     void *sub_command_data; };\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/samples/s3/app_ctx.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.515063}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Let me check the specific PR changes:\"},{\"type\":\"tool_use\",\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"input\":{\"knowledge_base_id\":\"8BRIG4RFWU\",\"query\":\"What does the AWS_TEST_CASE macro do in the aws-c-s3 testing framework?\"},\"id\":\"toolu_bdrk_01S1XtDQyP1NAdXmKdA3K2dk\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01S1XtDQyP1NAdXmKdA3K2dk\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"\\\\\\\\\\\\\\\\     };                                                                                                                 \\\\\\\\\\\\\\\\     int name(int argc, char *argv[]) {                                                                                 \\\\\\\\\\\\\\\\         (void)argc;                                                                                                    \\\\\\\\\\\\\\\\         (void)argv;                                                                                                    \\\\\\\\\\\\\\\\         return s_aws_run_test_case(&name##_test);                                                                      \\\\\\\\\\\\\\\\     }  #define AWS_TEST_CASE(name, fn) AWS_TEST_CASE_SUPRESSION(name, fn, 0) #define AWS_TEST_CASE_FIXTURE(name, b, fn, af, c) AWS_TEST_CASE_FIXTURE_SUPPRESSION(name, b, fn, af, c, 0)  #endif /* AWS_TESTING_AWS_TEST_HARNESS_H */\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/include/aws/testing/aws_test_harness.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.6014975}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. # SPDX-License-Identifier: Apache-2.0.  include(AwsCFlags) include(AwsSanitizers)  option(ENABLE_NET_TESTS \\\\\\\\\\\\\"Run tests requiring an internet connection.\\\\\\\\\\\\\" ON)  # Maintain a global list of AWS_TEST_CASES define_property(GLOBAL PROPERTY AWS_TEST_CASES BRIEF_DOCS \\\\\\\\\\\\\"Test Cases\\\\\\\\\\\\\" FULL_DOCS \\\\\\\\\\\\\"Test Cases\\\\\\\\\\\\\") set(AWS_TEST_CASES \\\\\\\\\\\\\"\\\\\\\\\\\\\" CACHE INTERNAL \\\\\\\\\\\\\"Test cases valid for this configuration\\\\\\\\\\\\\")  # The return value for the skipped test cases. Refer to the return code defined in aws_test_harness.h: # #define SKIP (103) set(SKIP_RETURN_CODE_VALUE 103)  # Registers a test case by name (the first argument to the AWS_TEST_CASE macro in aws_test_harness.h) macro(add_test_case name)     list(APPEND TEST_CASES \\\\\\\\\\\\\"${name}\\\\\\\\\\\\\")     list(APPEND AWS_TEST_CASES \\\\\\\\\\\\\"${name}\\\\\\\\\\\\\")     set_property(GLOBAL PROPERTY AWS_TEST_CASES ${AWS_TEST_CASES}) endmacro()  # Like add_test_case, but for tests that require a working internet connection. macro(add_net_test_case name)     if (ENABLE_NET_TESTS)         list(APPEND TEST_CASES \\\\\\\\\\\\\"${name}\\\\\\\\\\\\\")         list(APPEND AWS_TEST_CASES \\\\\\\\\\\\\"${name}\\\\\\\\\\\\\")         set_property(GLOBAL PROPERTY AWS_TEST_CASES ${AWS_TEST_CASES})     endif() endmacro()  # Generate a test\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/cmake/AwsTestHarness.cmake\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.580473}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"\\\\\\\\\\\\\");     if (!g_test_filedes) {         perror(\\\\\\\\\\\\\"***INTERNAL ERROR*** Failed to open temporary file\\\\\\\\\\\\\");         abort();     }      side_effect_ctr = 0; }  int check_failure_output(const char *expected) {     fclose(g_test_filedes);     g_test_filedes = NULL;      FILE *readfd = aws_fopen(g_test_filename, \\\\\\\\\\\\\"r\\\\\\\\\\\\\");      static char tmpbuf[256];     char *rv = fgets(tmpbuf, sizeof(tmpbuf), readfd);     fclose(readfd);      if (!expected) {         return rv == NULL;     }     if (!rv) {         return 0;     }     return !strncmp(tmpbuf, expected, strlen(expected)); }  int main(int argc, char **argv) {     int index = 0;      if (argc < 2) {         return 1;     }      g_test_filename = argv[1];      // Suppress unused function warnings     (void)s_aws_run_test_case;      // Sanity checks for our own test macros      reset();     if (test_asserts(&index) !\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/tests/assert_test.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5456025}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3express_credentials_provider_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3express_credentials_provider.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/atomics.h> #include <aws/common/clock.h> #include <aws/common/encoding.h> #include <aws/common/lru_cache.h> #include <aws/io/stream.h> #include <aws/io/uri.h> #include <aws/testing/aws_test_harness.h> #include <inttypes.h>  #define TEST_CASE(NAME)                                                                                                \\\\\\\\\\\\\\\\     AWS_TEST_CASE(NAME, s_test_##NAME);                                                                                \\\\\\\\\\\\\\\\     static int s_test_##NAME(struct aws_allocator *allocator, void *ctx)  #define DEFINE_HEADER(NAME, VALUE)                                                                                     \\\\\\\\\\\\\\\\     {                                                                                                                  \\\\\\\\\\\\\\\\         .name = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(NAME),                                                           \\\\\\\\\\\\\\\\         .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(VALUE),                                                         \\\\\\\\\\\\\\\\     }  struct aws_s3express_client_tester {     struct aws_allocator *allocator;     struct aws_hash_table saver_cache;     struct aws_atomic_var provider_requests_made; };  static struct aws_s3express_client_tester\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_s3express_client_test.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5418295}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include <aws/http/connection.h> #include <aws/http/private/h1_connection.h> #include <aws/http/private/request_response_impl.h> #include <aws/http/request_response.h> #include <aws/http/server.h>  #include <aws/common/clock.h> #include <aws/common/condition_variable.h> #include <aws/common/log_writer.h> #include <aws/common/uuid.h> #include <aws/io/channel_bootstrap.h> #include <aws/io/logging.h> #include <aws/io/socket.h> #include <aws/io/stream.h> #include <aws/io/tls_channel_handler.h> #include <aws/testing/aws_test_harness.h>  #include <aws/testing/io_testing_channel.h>  #ifdef _MSC_VER #    pragma warning(disable : 4204) /* non-constant aggregate initializer */ #endif  #define TEST_CASE(NAME)                                                                                                \\\\\\\\\\\\\\\\     AWS_TEST_CASE(NAME, s_test_##NAME);                                                                                \\\\\\\\\\\\\\\\     static int s_test_##NAME(struct aws_allocator *allocator, void *ctx)  struct tester_request {     struct aws_http_stream *request_handler;      /* All cursors in tester_request point into here */     struct aws_byte_buf storage;      struct aws_byte_cursor method;     struct aws_byte_cursor uri;     struct\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-http/tests/test_h1_server.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.53430676}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */ #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\"  #include <aws/checksums/crc.h> #include <aws/common/byte_order.h> #include <aws/common/clock.h> #include <aws/common/device_random.h> #include <aws/common/encoding.h> #include <aws/s3/private/s3_util.h> #include <aws/testing/aws_test_harness.h>  #define TIMEOUT_NANOS ((uint64_t)AWS_TIMESTAMP_NANOS * 10) /* 10secs */ #define PART_SIZE MB_TO_BYTES(5)  struct asyncwrite_tester {     struct aws_allocator *allocator;     struct aws_s3_tester s3_tester;     struct aws_s3_client *client;     struct aws_s3_meta_request *meta_request;     struct aws_s3_meta_request_test_results test_results;     struct aws_byte_buf source_buf; };  static int s_asyncwrite_tester_init(     struct asyncwrite_tester *tester,     struct aws_allocator *allocator,     size_t object_size) {      AWS_ZERO_STRUCT(*tester);     tester->allocator = allocator;      ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester->s3_tester));      /* Create S3 client */     struct aws_s3_client_config client_config\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_asyncwrite_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.53388757}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\".)                                                         \\\\\\\\\\\\\\\\     ASSERT_CURSOR_VALUE_CSTRING_EQUALS(cursor, aws_string_c_str(string));  typedef int(aws_test_before_fn)(struct aws_allocator *allocator, void *ctx); typedef int(aws_test_run_fn)(struct aws_allocator *allocator, void *ctx); typedef int(aws_test_after_fn)(struct aws_allocator *allocator, int setup_result, void *ctx);  struct aws_test_harness {     aws_test_before_fn *on_before;     aws_test_run_fn *run;     aws_test_after_fn *on_after;     void *ctx;     const char *test_name;     int suppress_memcheck; };  #if defined(_WIN32) #    include <windows.h> static LONG WINAPI s_test_print_stack_trace(struct _EXCEPTION_POINTERS *exception_pointers) { #    if !defined(AWS_HEADER_CHECKER)     aws_backtrace_print(stderr, exception_pointers); #    endif     return EXCEPTION_EXECUTE_HANDLER; } #elif defined(AWS_HAVE_EXECINFO) #    include <signal.h> static void s_print_stack_trace(int sig, siginfo_t *sig_info, void *user_data) {     (void)sig;     (void)sig_info;     (void)user_data; #    if !\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/include/aws/testing/aws_test_harness.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.53384525}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"#ifndef AWS_TESTING_AWS_TEST_HARNESS_H #define AWS_TESTING_AWS_TEST_HARNESS_H /**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include <aws/common/common.h> #include <aws/common/error.h> #include <aws/common/logging.h> #include <aws/common/mutex.h> #include <aws/common/system_info.h>  #include <stdarg.h> #include <stdio.h> #include <stdlib.h> #include <string.h>  /**  * The return code for skipped tests. Use the return code if the test should be skipped.  */ #define AWS_OP_SKIP (-2)  #ifndef AWS_UNSTABLE_TESTING_API #    error The AWS Test Fixture is designed only for use by AWS owned libraries for the AWS C99 SDK. You are welcome to use it,   \\\\\\\\\\\\\\\\ but you should be aware we make no promises on the stability of this API.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/include/aws/testing/aws_test_harness.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5328942}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"#ifndef AWS_S3_TESTER_H #define AWS_S3_TESTER_H  /**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_request_messages.h\\\\\\\\\\\\\" #include <aws/s3/private/s3_auto_ranged_put.h> #include <aws/s3/private/s3_client_impl.h> #include <aws/s3/private/s3_meta_request_impl.h> #include <aws/s3/s3.h> #include <aws/s3/s3_client.h> #include <aws/s3/s3express_credentials_provider.h>  #include <aws/common/common.h> #include <aws/common/condition_variable.h> #include <aws/common/file.h> #include <aws/common/logging.h> #include <aws/common/mutex.h> #include <aws/common/string.h> #include <aws/testing/async_stream_tester.h>  struct aws_client_bootstrap; struct aws_credentials_provider; struct aws_event_loop_group; struct aws_host_resolver; struct aws_input_stream;  enum AWS_S3_TESTER_BIND_CLIENT_FLAGS {     AWS_S3_TESTER_BIND_CLIENT_REGION = 0x00000001,     AWS_S3_TESTER_BIND_CLIENT_SIGNING = 0x00000002, };  enum AWS_S3_TESTER_SEND_META_REQUEST_FLAGS {     AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS =\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_tester.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5311468}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"Each library should begin its error and log subject values at the beginning of its range and follow in sequence (don\\'t skip codes). Upon adding an AWS maintained library, a new enum range must be approved and added to the above table. ### Testing We have a high bar for test coverage, and PRs fixing bugs or introducing new functionality need to have tests before they will be accepted. A couple of tips: #### Aws Test Harness We provide a test harness for writing unit tests. This includes an allocator that will fail your test if you have any memory leaks, as well as some `ASSERT` macros. To write a test: * Create a *.c test file in the tests directory of the project. * Implement one or more tests with the signature `int test_case_name(struct aws_allocator *, void *ctx)` * Use the `AWS_TEST_CASE` macro to declare the test. * Include your test in the `tests/main.c` file. * Include your test in the `tests/CMakeLists.txt` file. ### Coding Style * No Tabs. * Indent is 4 spaces. * K & R style for braces. * Space after if, before the `(`. * `else` and `else if` stay on the same line as the closing brace. Example: if (condition) { do_something(); } else { do_something_else(); } * Avoid C99 features in header files.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.52958417}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Based on my analysis, here\\'s what I need to do:\\\\n\\\\n1. Review PR #519 which adds a new test case to `tests/s3_data_plane_tests.c`\\\\n2. Understand what the test is trying to achieve\\\\n3. Provide comments on the code quality, documentation, and adherence to standards\\\\n4. Format those comments with appropriate prefixes as per the comments style guide\\\\n\\\\nLet me create a proper code review now:\"},{\"type\":\"tool_use\",\"name\":\"filesystem-create_directory\",\"input\":{\"path\":\"./new_comments_s3_PR519\"},\"id\":\"toolu_bdrk_01HV73RQ2rGzisqRf7CV8afC\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01HV73RQ2rGzisqRf7CV8afC\",\"content\":[{\"type\":\"text\",\"text\":\"Successfully created directory ./new_comments_s3_PR519\"}],\"is_error\":false}]}],\"stop_sequences\":null,\"system\":\"Given a github pull request.         The code in the pull request is very related to the knowledge base, fetch the details of the code base you want to learn about the code from the knowledge base.             Use 8BRIG4RFWU as Knowledge Base ID and aws profile as bedrock, region us-east-1                But if the code is just added by the pull request, then the knowledge base will not help         and follow the guidance in /Users/dengket/project/hackthon/fast-agent/crt_c_reviewer/summarization/comments_styles.md to be how you will make comments then make your comments             as details as you can for each specific lines about the documentation on the pull request,                 save your comments about the specific line or lines with the number of the lines to a folder naming followed by ./new_comments_s3_PR<the PR number> with name related to the Pull request like PR454_Comments_Docs.md.                     And then, generates the comments only if needed and keep the positive comments out for the specific line or lines as the input for create_pull_request_review,                         save it to a file to the same folder with naming like `input_PR454_comments_docs.json`, but don\\'t really submit the comments\",\"tools\":[{\"name\":\"github-create_or_update_file\",\"description\":\"Create or update a single file in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"path\":{\"type\":\"string\",\"description\":\"Path where to create/update the file\"},\"content\":{\"type\":\"string\",\"description\":\"Content of the file\"},\"message\":{\"type\":\"string\",\"description\":\"Commit message\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to create/update the file in\"},\"sha\":{\"type\":\"string\",\"description\":\"SHA of the file being replaced (required when updating existing files)\"}},\"required\":[\"owner\",\"repo\",\"path\",\"content\",\"message\",\"branch\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_repositories\",\"description\":\"Search for GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"query\":{\"type\":\"string\",\"description\":\"Search query (see GitHub search syntax)\"},\"page\":{\"type\":\"number\",\"description\":\"Page number for pagination (default: 1)\"},\"perPage\":{\"type\":\"number\",\"description\":\"Number of results per page (default: 30, max: 100)\"}},\"required\":[\"query\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_repository\",\"description\":\"Create a new GitHub repository in your account\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\",\"description\":\"Repository name\"},\"description\":{\"type\":\"string\",\"description\":\"Repository description\"},\"private\":{\"type\":\"boolean\",\"description\":\"Whether the repository should be private\"},\"autoInit\":{\"type\":\"boolean\",\"description\":\"Initialize with README.md\"}},\"required\":[\"name\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_file_contents\",\"description\":\"Get the contents of a file or directory from a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"path\":{\"type\":\"string\",\"description\":\"Path to the file or directory\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to get contents from\"}},\"required\":[\"owner\",\"repo\",\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-push_files\",\"description\":\"Push multiple files to a GitHub repository in a single commit\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to push to (e.g., \\'main\\' or \\'master\\')\"},\"files\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"content\":{\"type\":\"string\"}},\"required\":[\"path\",\"content\"],\"additionalProperties\":false},\"description\":\"Array of files to push\"},\"message\":{\"type\":\"string\",\"description\":\"Commit message\"}},\"required\":[\"owner\",\"repo\",\"branch\",\"files\",\"message\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_issue\",\"description\":\"Create a new issue in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"body\":{\"type\":\"string\"},\"assignees\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"milestone\":{\"type\":\"number\"},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"owner\",\"repo\",\"title\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_pull_request\",\"description\":\"Create a new pull request in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"title\":{\"type\":\"string\",\"description\":\"Pull request title\"},\"body\":{\"type\":\"string\",\"description\":\"Pull request body/description\"},\"head\":{\"type\":\"string\",\"description\":\"The name of the branch where your changes are implemented\"},\"base\":{\"type\":\"string\",\"description\":\"The name of the branch you want the changes pulled into\"},\"draft\":{\"type\":\"boolean\",\"description\":\"Whether to create the pull request as a draft\"},\"maintainer_can_modify\":{\"type\":\"boolean\",\"description\":\"Whether maintainers can modify the pull request\"}},\"required\":[\"owner\",\"repo\",\"title\",\"head\",\"base\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-fork_repository\",\"description\":\"Fork a GitHub repository to your account or specified organization\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"organization\":{\"type\":\"string\",\"description\":\"Optional: organization to fork to (defaults to your personal account)\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_branch\",\"description\":\"Create a new branch in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"branch\":{\"type\":\"string\",\"description\":\"Name for the new branch\"},\"from_branch\":{\"type\":\"string\",\"description\":\"Optional: source branch to create from (defaults to the repository\\'s default branch)\"}},\"required\":[\"owner\",\"repo\",\"branch\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_commits\",\"description\":\"Get list of commits of a branch in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"sha\":{\"type\":\"string\"},\"page\":{\"type\":\"number\"},\"perPage\":{\"type\":\"number\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_issues\",\"description\":\"List issues in a GitHub repository with filtering options\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"direction\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"page\":{\"type\":\"number\"},\"per_page\":{\"type\":\"number\"},\"since\":{\"type\":\"string\"},\"sort\":{\"type\":\"string\",\"enum\":[\"created\",\"updated\",\"comments\"]},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\",\"all\"]}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-update_issue\",\"description\":\"Update an existing issue in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"},\"title\":{\"type\":\"string\"},\"body\":{\"type\":\"string\"},\"assignees\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"milestone\":{\"type\":\"number\"},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\"]}},\"required\":[\"owner\",\"repo\",\"issue_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-add_issue_comment\",\"description\":\"Add a comment to an existing issue\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"},\"body\":{\"type\":\"string\"}},\"required\":[\"owner\",\"repo\",\"issue_number\",\"body\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_code\",\"description\":\"Search for code across GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_issues\",\"description\":\"Search for issues and pull requests across GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100},\"sort\":{\"type\":\"string\",\"enum\":[\"comments\",\"reactions\",\"reactions-+1\",\"reactions--1\",\"reactions-smile\",\"reactions-thinking_face\",\"reactions-heart\",\"reactions-tada\",\"interactions\",\"created\",\"updated\"]}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_users\",\"description\":\"Search for users on GitHub\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100},\"sort\":{\"type\":\"string\",\"enum\":[\"followers\",\"repositories\",\"joined\"]}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_issue\",\"description\":\"Get details of a specific issue in a GitHub repository.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"}},\"required\":[\"owner\",\"repo\",\"issue_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request\",\"description\":\"Get details of a specific pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_pull_requests\",\"description\":\"List and filter repository pull requests\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\",\"all\"],\"description\":\"State of the pull requests to return\"},\"head\":{\"type\":\"string\",\"description\":\"Filter by head user or head organization and branch name\"},\"base\":{\"type\":\"string\",\"description\":\"Filter by base branch name\"},\"sort\":{\"type\":\"string\",\"enum\":[\"created\",\"updated\",\"popularity\",\"long-running\"],\"description\":\"What to sort results by\"},\"direction\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"],\"description\":\"The direction of the sort\"},\"per_page\":{\"type\":\"number\",\"description\":\"Results per page (max 100)\"},\"page\":{\"type\":\"number\",\"description\":\"Page number of the results\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_pull_request_review\",\"description\":\"Create a review on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"commit_id\":{\"type\":\"string\",\"description\":\"The SHA of the commit that needs a review\"},\"body\":{\"type\":\"string\",\"description\":\"The body text of the review\"},\"event\":{\"type\":\"string\",\"enum\":[\"APPROVE\",\"REQUEST_CHANGES\",\"COMMENT\"],\"description\":\"The review action to perform\"},\"comments\":{\"type\":\"array\",\"items\":{\"anyOf\":[{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\",\"description\":\"The relative path to the file being commented on\"},\"position\":{\"type\":\"number\",\"description\":\"The position in the diff where you want to add a review comment\"},\"body\":{\"type\":\"string\",\"description\":\"Text of the review comment\"}},\"required\":[\"path\",\"position\",\"body\"],\"additionalProperties\":false},{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\",\"description\":\"The relative path to the file being commented on\"},\"line\":{\"type\":\"number\",\"description\":\"The line number in the file where you want to add a review comment\"},\"body\":{\"type\":\"string\",\"description\":\"Text of the review comment\"}},\"required\":[\"path\",\"line\",\"body\"],\"additionalProperties\":false}]},\"description\":\"Comments to post as part of the review (specify either position or line, not both)\"}},\"required\":[\"owner\",\"repo\",\"pull_number\",\"body\",\"event\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-merge_pull_request\",\"description\":\"Merge a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"commit_title\":{\"type\":\"string\",\"description\":\"Title for the automatic commit message\"},\"commit_message\":{\"type\":\"string\",\"description\":\"Extra detail to append to automatic commit message\"},\"merge_method\":{\"type\":\"string\",\"enum\":[\"merge\",\"squash\",\"rebase\"],\"description\":\"Merge method to use\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_files\",\"description\":\"Get the list of files changed in a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_status\",\"description\":\"Get the combined status of all status checks for a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-update_pull_request_branch\",\"description\":\"Update a pull request branch with the latest changes from the base branch\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"expected_head_sha\":{\"type\":\"string\",\"description\":\"The expected SHA of the pull request\\'s HEAD ref\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_comments\",\"description\":\"Get the review comments on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_reviews\",\"description\":\"Get the reviews on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-read_file\",\"description\":\"Read the complete contents of a file from the file system. Handles various text encodings and provides detailed error messages if the file cannot be read. Use this tool when you need to examine the contents of a single file. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-read_multiple_files\",\"description\":\"Read the contents of multiple files simultaneously. This is more efficient than reading files one by one when you need to analyze or compare multiple files. Each file\\'s content is returned with its path as a reference. Failed reads for individual files won\\'t stop the entire operation. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"paths\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"paths\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-write_file\",\"description\":\"Create a new file or completely overwrite an existing file with new content. Use with caution as it will overwrite existing files without warning. Handles text content with proper encoding. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"content\":{\"type\":\"string\"}},\"required\":[\"path\",\"content\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-edit_file\",\"description\":\"Make line-based edits to a text file. Each edit replaces exact line sequences with new content. Returns a git-style diff showing the changes made. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"edits\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"oldText\":{\"type\":\"string\",\"description\":\"Text to search for - must match exactly\"},\"newText\":{\"type\":\"string\",\"description\":\"Text to replace with\"}},\"required\":[\"oldText\",\"newText\"],\"additionalProperties\":false}},\"dryRun\":{\"type\":\"boolean\",\"default\":false,\"description\":\"Preview changes using git-style diff format\"}},\"required\":[\"path\",\"edits\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-create_directory\",\"description\":\"Create a new directory or ensure a directory exists. Can create multiple nested directories in one operation. If the directory already exists, this operation will succeed silently. Perfect for setting up directory structures for projects or ensuring required paths exist. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-list_directory\",\"description\":\"Get a detailed listing of all files and directories in a specified path. Results clearly distinguish between files and directories with [FILE] and [DIR] prefixes. This tool is essential for understanding directory structure and finding specific files within a directory. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-directory_tree\",\"description\":\"Get a recursive tree view of files and directories as a JSON structure. Each entry includes \\'name\\', \\'type\\' (file/directory), and \\'children\\' for directories. Files have no children array, while directories always have a children array (which may be empty). The output is formatted with 2-space indentation for readability. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-move_file\",\"description\":\"Move or rename files and directories. Can move files between directories and rename them in a single operation. If the destination exists, the operation will fail. Works across different directories and can be used for simple renaming within the same directory. Both source and destination must be within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"source\":{\"type\":\"string\"},\"destination\":{\"type\":\"string\"}},\"required\":[\"source\",\"destination\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-search_files\",\"description\":\"Recursively search for files and directories matching a pattern. Searches through all subdirectories from the starting path. The search is case-insensitive and matches partial names. Returns full paths to all matching items. Great for finding files when you don\\'t know their exact location. Only searches within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"pattern\":{\"type\":\"string\"},\"excludePatterns\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"default\":[]}},\"required\":[\"path\",\"pattern\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-get_file_info\",\"description\":\"Retrieve detailed metadata about a file or directory. Returns comprehensive information including size, creation time, last modified time, permissions, and type. This tool is perfect for understanding file characteristics without reading the actual content. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-list_allowed_directories\",\"description\":\"Returns the list of directories that this server is allowed to access. Use this to understand which directories are available before trying to access files.\",\"input_schema\":{\"type\":\"object\",\"properties\":{},\"required\":[]}},{\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"description\":\"Query an Amazon Bedrock Knowledge Base using natural language.\\\\n\\\\n    ## Usage Requirements\\\\n    - You MUST first use the `resource://knowledgebases` resource to get valid knowledge base IDs\\\\n    - You can query different knowledge bases or make multiple queries to the same knowledge base\\\\n\\\\n    ## Query Tips\\\\n    - Use clear, specific natural language queries for best results\\\\n    - You can use this tool MULTIPLE TIMES with different queries to gather comprehensive information\\\\n    - Break complex questions into multiple focused queries\\\\n    - Consider querying for factual information and explanations separately\\\\n\\\\n    ## Tool output format\\\\n    The response contains multiple JSON objects (one per line), each representing a retrieved document with:\\\\n    - content: The text content of the document\\\\n    - location: The source location of the document\\\\n    - score: The relevance score of the document\\\\n\\\\n\\\\n    ## Interpretation Best Practices\\\\n    1. Extract and combine key information from multiple results\\\\n    2. Consider the source and relevance score when evaluating information\\\\n    3. Use follow-up queries to clarify ambiguous or incomplete information\\\\n    4. If the response is not relevant, try a different query, knowledge base, and/or data source\\\\n    5. After a few attempts, ask the user for clarification or a different query.\\\\n    \",\"input_schema\":{\"properties\":{\"query\":{\"description\":\"A natural language query to search the knowledge base with\",\"title\":\"Query\",\"type\":\"string\"},\"knowledge_base_id\":{\"description\":\"The knowledge base ID to query. It must be a valid ID from the resource://knowledgebases MCP resource\",\"title\":\"Knowledge Base Id\",\"type\":\"string\"},\"number_of_results\":{\"default\":10,\"description\":\"The number of results to return. Use smaller values for focused results and larger values for broader coverage.\",\"title\":\"Number Of Results\",\"type\":\"integer\"},\"reranking\":{\"default\":false,\"description\":\"Whether to rerank the results. Useful for improving relevance and sorting. Can be globally configured with BEDROCK_KB_RERANKING_ENABLED environment variable.\",\"title\":\"Reranking\",\"type\":\"boolean\"},\"reranking_model_name\":{\"default\":\"AMAZON\",\"description\":\"The name of the reranking model to use. Options: \\'COHERE\\', \\'AMAZON\\'\",\"enum\":[\"COHERE\",\"AMAZON\"],\"title\":\"Reranking Model Name\",\"type\":\"string\"},\"data_source_ids\":{\"anyOf\":[{\"items\":{\"type\":\"string\"},\"type\":\"array\"},{\"type\":\"null\"}],\"default\":null,\"description\":\"The data source IDs to filter the knowledge base by. It must be a list of valid data source IDs from the resource://knowledgebases MCP resource\",\"title\":\"Data Source Ids\"}},\"required\":[\"query\",\"knowledge_base_id\"],\"title\":\"query_knowledge_bases_toolArguments\",\"type\":\"object\"}}],\"anthropic_version\":\"bedrock-2023-05-31\"}'"},"message":"Error code: 429 - {'message': 'Too many tokens, please wait before trying again.'}","body":{"message":"Too many tokens, please wait before trying again."},"response":"<httpx.Response [429] https://bedrock-runtime.us-west-2.amazonaws.com/model/us.anthropic.claude-3-7-sonnet-20250219-v1:0/invoke>","status_code":429,"request_id":null}]}}
{"level":"ERROR","timestamp":"2025-05-15T11:02:02.599172","namespace":"mcp_agent.llm.augmented_llm","message":"Error: Error code: 429 - {'message': 'Too many tokens, please wait before trying again.'}","data":{"data":[{"request":{"method":"POST","url":{"_uri_reference":["https","","bedrock-runtime.us-west-2.amazonaws.com",null,"/model/us.anthropic.claude-3-7-sonnet-20250219-v1:0/invoke",null,null]},"headers":["connection","host","accept-encoding","x-stainless-timeout","accept","content-type","user-agent","x-stainless-lang","x-stainless-package-version","x-stainless-os","x-stainless-arch","x-stainless-runtime","x-stainless-runtime-version","x-stainless-retry-count","x-stainless-read-timeout","content-length","x-amz-date","x-amz-security-token","authorization"],"extensions":{"timeout":{"connect":5.0,"read":600,"write":"600","pool":"600"}},"stream":[{"capitalize":"<callable: capitalize>","center":"<callable: center>","count":"<callable: count>","decode":"<callable: decode>","endswith":"<callable: endswith>","expandtabs":"<callable: expandtabs>","find":"<callable: find>","fromhex":"<callable: fromhex>","hex":"<callable: hex>","index":"<callable: index>","isalnum":"<callable: isalnum>","isalpha":"<callable: isalpha>","isascii":"<callable: isascii>","isdigit":"<callable: isdigit>","islower":"<callable: islower>","isspace":"<callable: isspace>","istitle":"<callable: istitle>","isupper":"<callable: isupper>","join":"<callable: join>","ljust":"<callable: ljust>","lower":"<callable: lower>","lstrip":"<callable: lstrip>","maketrans":"<callable: maketrans>","partition":"<callable: partition>","removeprefix":"<callable: removeprefix>","removesuffix":"<callable: removesuffix>","replace":"<callable: replace>","rfind":"<callable: rfind>","rindex":"<callable: rindex>","rjust":"<callable: rjust>","rpartition":"<callable: rpartition>","rsplit":"<callable: rsplit>","rstrip":"<callable: rstrip>","split":"<callable: split>","splitlines":"<callable: splitlines>","startswith":"<callable: startswith>","strip":"<callable: strip>","swapcase":"<callable: swapcase>","title":"<callable: title>","translate":"<callable: translate>","upper":"<callable: upper>","zfill":"<callable: zfill>"}],"_content":"b'{\"max_tokens\":4096,\"messages\":[{\"role\":\"user\",\"content\":[{\"type\":\"text\",\"text\":\"please review https://github.com/awslabs/aws-c-s3/pull/519\"}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"I\\'ll help you review this pull request. Let\\'s start by fetching the details of PR #519 from the AWS C S3 repository.\"},{\"type\":\"tool_use\",\"name\":\"github-get_pull_request\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"pull_number\":519},\"id\":\"toolu_bdrk_015qaUVnZo84mxbE9XJwYPEp\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_015qaUVnZo84mxbE9XJwYPEp\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\n  \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/pulls/519\\\\\",\\\\n  \\\\\"id\\\\\": 2520395028,\\\\n  \\\\\"node_id\\\\\": \\\\\"PR_kwDOEJB4Sc6WOi0U\\\\\",\\\\n  \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519\\\\\",\\\\n  \\\\\"diff_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519.diff\\\\\",\\\\n  \\\\\"patch_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/pull/519.patch\\\\\",\\\\n  \\\\\"issue_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/issues/519\\\\\",\\\\n  \\\\\"number\\\\\": 519,\\\\n  \\\\\"state\\\\\": \\\\\"open\\\\\",\\\\n  \\\\\"locked\\\\\": false,\\\\n  \\\\\"title\\\\\": \\\\\"dummy test\\\\\",\\\\n  \\\\\"user\\\\\": {\\\\n    \\\\\"login\\\\\": \\\\\"TingDaoK\\\\\",\\\\n    \\\\\"id\\\\\": 26829806,\\\\n    \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/26829806?v=4\\\\\",\\\\n    \\\\\"url\\\\\": \\\\\"https://api.github.com/users/TingDaoK\\\\\",\\\\n    \\\\\"html_url\\\\\": \\\\\"https://github.com/TingDaoK\\\\\"\\\\n  },\\\\n  \\\\\"body\\\\\": \\\\\"*Issue #, if available:*\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n*Description of changes:*\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.\\\\\\\\r\\\\\\\\n\\\\\",\\\\n  \\\\\"created_at\\\\\": \\\\\"2025-05-14T21:35:46Z\\\\\",\\\\n  \\\\\"updated_at\\\\\": \\\\\"2025-05-14T23:38:00Z\\\\\",\\\\n  \\\\\"closed_at\\\\\": null,\\\\n  \\\\\"merged_at\\\\\": null,\\\\n  \\\\\"merge_commit_sha\\\\\": \\\\\"b8fc1c78ceeba7906b6ac56483199a3faaf5e9cd\\\\\",\\\\n  \\\\\"assignee\\\\\": null,\\\\n  \\\\\"assignees\\\\\": [],\\\\n  \\\\\"requested_reviewers\\\\\": [],\\\\n  \\\\\"labels\\\\\": [],\\\\n  \\\\\"head\\\\\": {\\\\n    \\\\\"label\\\\\": \\\\\"awslabs:dummy-delete-me\\\\\",\\\\n    \\\\\"ref\\\\\": \\\\\"dummy-delete-me\\\\\",\\\\n    \\\\\"sha\\\\\": \\\\\"e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6\\\\\",\\\\n    \\\\\"user\\\\\": {\\\\n      \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n      \\\\\"id\\\\\": 3299148,\\\\n      \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\"\\\\n    },\\\\n    \\\\\"repo\\\\\": {\\\\n      \\\\\"id\\\\\": 277903433,\\\\n      \\\\\"node_id\\\\\": \\\\\"MDEwOlJlcG9zaXRvcnkyNzc5MDM0MzM=\\\\\",\\\\n      \\\\\"name\\\\\": \\\\\"aws-c-s3\\\\\",\\\\n      \\\\\"full_name\\\\\": \\\\\"awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"private\\\\\": false,\\\\n      \\\\\"owner\\\\\": {\\\\n        \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n        \\\\\"id\\\\\": 3299148,\\\\n        \\\\\"node_id\\\\\": \\\\\"MDEyOk9yZ2FuaXphdGlvbjMyOTkxNDg=\\\\\",\\\\n        \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n        \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n        \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\",\\\\n        \\\\\"type\\\\\": \\\\\"Organization\\\\\"\\\\n      },\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"description\\\\\": \\\\\"C99 library implementation for communicating with the S3 service, designed for maximizing throughput on high bandwidth EC2 instances.\\\\\",\\\\n      \\\\\"fork\\\\\": false,\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"created_at\\\\\": \\\\\"2020-07-07T19:21:45Z\\\\\",\\\\n      \\\\\"updated_at\\\\\": \\\\\"2025-05-15T17:15:47Z\\\\\",\\\\n      \\\\\"pushed_at\\\\\": \\\\\"2025-05-15T17:16:08Z\\\\\",\\\\n      \\\\\"git_url\\\\\": \\\\\"git://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"ssh_url\\\\\": \\\\\"git@github.com:awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"clone_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"default_branch\\\\\": \\\\\"main\\\\\"\\\\n    }\\\\n  },\\\\n  \\\\\"base\\\\\": {\\\\n    \\\\\"label\\\\\": \\\\\"awslabs:main\\\\\",\\\\n    \\\\\"ref\\\\\": \\\\\"main\\\\\",\\\\n    \\\\\"sha\\\\\": \\\\\"7d2d4b3070109c882ff78e8719f60597c7ba0472\\\\\",\\\\n    \\\\\"user\\\\\": {\\\\n      \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n      \\\\\"id\\\\\": 3299148,\\\\n      \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\"\\\\n    },\\\\n    \\\\\"repo\\\\\": {\\\\n      \\\\\"id\\\\\": 277903433,\\\\n      \\\\\"node_id\\\\\": \\\\\"MDEwOlJlcG9zaXRvcnkyNzc5MDM0MzM=\\\\\",\\\\n      \\\\\"name\\\\\": \\\\\"aws-c-s3\\\\\",\\\\n      \\\\\"full_name\\\\\": \\\\\"awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"private\\\\\": false,\\\\n      \\\\\"owner\\\\\": {\\\\n        \\\\\"login\\\\\": \\\\\"awslabs\\\\\",\\\\n        \\\\\"id\\\\\": 3299148,\\\\n        \\\\\"node_id\\\\\": \\\\\"MDEyOk9yZ2FuaXphdGlvbjMyOTkxNDg=\\\\\",\\\\n        \\\\\"avatar_url\\\\\": \\\\\"https://avatars.githubusercontent.com/u/3299148?v=4\\\\\",\\\\n        \\\\\"url\\\\\": \\\\\"https://api.github.com/users/awslabs\\\\\",\\\\n        \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs\\\\\",\\\\n        \\\\\"type\\\\\": \\\\\"Organization\\\\\"\\\\n      },\\\\n      \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"description\\\\\": \\\\\"C99 library implementation for communicating with the S3 service, designed for maximizing throughput on high bandwidth EC2 instances.\\\\\",\\\\n      \\\\\"fork\\\\\": false,\\\\n      \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3\\\\\",\\\\n      \\\\\"created_at\\\\\": \\\\\"2020-07-07T19:21:45Z\\\\\",\\\\n      \\\\\"updated_at\\\\\": \\\\\"2025-05-15T17:15:47Z\\\\\",\\\\n      \\\\\"pushed_at\\\\\": \\\\\"2025-05-15T17:16:08Z\\\\\",\\\\n      \\\\\"git_url\\\\\": \\\\\"git://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"ssh_url\\\\\": \\\\\"git@github.com:awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"clone_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3.git\\\\\",\\\\n      \\\\\"default_branch\\\\\": \\\\\"main\\\\\"\\\\n    }\\\\n  }\\\\n}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now, let\\'s look at the files changed in this PR to understand what we need to review:\"},{\"type\":\"tool_use\",\"name\":\"github-get_pull_request_files\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"pull_number\":519},\"id\":\"toolu_bdrk_01JpxMc5FmTiLm5xPRQ4LNwf\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01JpxMc5FmTiLm5xPRQ4LNwf\",\"content\":[{\"type\":\"text\",\"text\":\"[\\\\n  {\\\\n    \\\\\"sha\\\\\": \\\\\"dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n    \\\\\"filename\\\\\": \\\\\"tests/s3_data_plane_tests.c\\\\\",\\\\n    \\\\\"status\\\\\": \\\\\"modified\\\\\",\\\\n    \\\\\"additions\\\\\": 49,\\\\n    \\\\\"deletions\\\\\": 0,\\\\n    \\\\\"changes\\\\\": 49,\\\\n    \\\\\"blob_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6/tests%2Fs3_data_plane_tests.c\\\\\",\\\\n    \\\\\"raw_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/raw/e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6/tests%2Fs3_data_plane_tests.c\\\\\",\\\\n    \\\\\"contents_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests%2Fs3_data_plane_tests.c?ref=e64c5613d04d3cdfd8613ab7f82e7d698e3de2f6\\\\\",\\\\n    \\\\\"patch\\\\\": \\\\\"@@ -8114,3 +8114,52 @@ static int s_test_s3_default_get_without_content_length(struct aws_allocator *al\\\\\\\\n \\\\\\\\n     return AWS_OP_SUCCESS;\\\\\\\\n }\\\\\\\\n+\\\\\\\\n+struct aws_string *test_helper(struct aws_allocator *allocator) {\\\\\\\\n+    struct aws_string *host_name =\\\\\\\\n+        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n+    return host_name;\\\\\\\\n+}\\\\\\\\n+\\\\\\\\n+AWS_TEST_CASE(test_s3_default_get, aws_test_s3_default_get)\\\\\\\\n+static int aws_test_s3_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n+    (void)ctx;\\\\\\\\n+\\\\\\\\n+    struct aws_s3_tester tester;\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n+\\\\\\\\n+    struct aws_s3_client *client = NULL;\\\\\\\\n+    struct aws_s3_tester_client_options client_options;\\\\\\\\n+    AWS_ZERO_STRUCT(client_options);\\\\\\\\n+\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n+    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n+    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n+\\\\\\\\n+    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n+    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n+\\\\\\\\n+    struct aws_string *hsot_name = test_helper(allocator);\\\\\\\\n+\\\\\\\\n+    /* Put together a simple S3 Get Object request. */\\\\\\\\n+    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n+        allocator, aws_byte_cursor_from_string(hsot_name), g_pre_existing_object_1MB);\\\\\\\\n+\\\\\\\\n+    struct aws_s3_meta_request_options options;\\\\\\\\n+    AWS_ZERO_STRUCT(options);\\\\\\\\n+    /* Send default type */\\\\\\\\n+    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n+    options.message = message;\\\\\\\\n+    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n+\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n+        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n+    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n+\\\\\\\\n+    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n+    aws_http_message_release(message);\\\\\\\\n+    aws_s3_client_release(client);\\\\\\\\n+    aws_s3_tester_clean_up(&tester);\\\\\\\\n+\\\\\\\\n+    return AWS_OP_SUCCESS;\\\\\\\\n+}\\\\\"\\\\n  }\\\\n]\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now that I have the PR details, let me get the file content to understand the full context:\"},{\"type\":\"tool_use\",\"name\":\"github-get_file_contents\",\"input\":{\"owner\":\"awslabs\",\"repo\":\"aws-c-s3\",\"path\":\"tests/s3_data_plane_tests.c\",\"branch\":\"dummy-delete-me\"},\"id\":\"toolu_bdrk_01SWyFdrGyKZS7U45XuoQCz7\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01SWyFdrGyKZS7U45XuoQCz7\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\n  \\\\\"name\\\\\": \\\\\"s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"path\\\\\": \\\\\"tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"sha\\\\\": \\\\\"dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n  \\\\\"size\\\\\": 319574,\\\\n  \\\\\"url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests/s3_data_plane_tests.c?ref=dummy-delete-me\\\\\",\\\\n  \\\\\"html_url\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"git_url\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/git/blobs/dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n  \\\\\"download_url\\\\\": \\\\\"https://raw.githubusercontent.com/awslabs/aws-c-s3/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\",\\\\n  \\\\\"type\\\\\": \\\\\"file\\\\\",\\\\n  \\\\\"content\\\\\": \\\\\"/**\\\\\\\\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\\\\\\\\n * SPDX-License-Identifier: Apache-2.0.\\\\\\\\n */\\\\\\\\n\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_checksums.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\"\\\\\\\\n#include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\"\\\\\\\\n#include <aws/common/byte_buf.h>\\\\\\\\n#include <aws/common/clock.h>\\\\\\\\n#include <aws/common/common.h>\\\\\\\\n#include <aws/common/encoding.h>\\\\\\\\n#include <aws/common/environment.h>\\\\\\\\n#include <aws/common/ref_count.h>\\\\\\\\n#include <aws/http/request_response.h>\\\\\\\\n#include <aws/http/status_code.h>\\\\\\\\n#include <aws/io/channel_bootstrap.h>\\\\\\\\n#include <aws/io/event_loop.h>\\\\\\\\n#include <aws/io/host_resolver.h>\\\\\\\\n#include <aws/io/stream.h>\\\\\\\\n#include <aws/io/tls_channel_handler.h>\\\\\\\\n#include <aws/io/uri.h>\\\\\\\\n#include <aws/testing/aws_test_harness.h>\\\\\\\\n#include <aws/testing/stream_tester.h>\\\\\\\\n#include <inttypes.h>\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_create_destroy, s_test_s3_client_create_destroy)\\\\\\\\nstatic int s_test_s3_client_create_destroy(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_create_error, s_test_s3_client_create_error)\\\\\\\\nstatic int s_test_s3_client_create_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    struct aws_http_proxy_options proxy_options = {\\\\\\\\n        .connection_type = AWS_HPCT_HTTP_LEGACY,\\\\\\\\n        .host = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"localhost\\\\\\\\\\\\\"),\\\\\\\\n        .port = 8899,\\\\\\\\n    };\\\\\\\\n    client_config.proxy_options = &proxy_options;\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_client_create_error_with_invalid_memory_limit_config,\\\\\\\\n    s_test_s3_client_create_error_with_invalid_memory_limit_config)\\\\\\\\nstatic int s_test_s3_client_create_error_with_invalid_memory_limit_config(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    client_config.memory_limit_in_bytes = 100;\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n    client_config.memory_limit_in_bytes = GB_TO_BYTES(1);\\\\\\\\n    client_config.max_part_size = GB_TO_BYTES(2);\\\\\\\\n    client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_client_create_error_with_invalid_network_interface,\\\\\\\\n    s_test_s3_client_create_error_with_invalid_network_interface)\\\\\\\\nstatic int s_test_s3_client_create_error_with_invalid_network_interface(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor *interface_names_array = aws_mem_calloc(allocator, 1, sizeof(struct aws_byte_cursor));\\\\\\\\n    interface_names_array[0] = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"invalid-nic\\\\\\\\\\\\\");\\\\\\\\n    client_config.network_interface_names_array = interface_names_array;\\\\\\\\n    client_config.num_network_interface_names = 1;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_mem_release(allocator, interface_names_array);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_monitoring_options_override, s_test_s3_client_monitoring_options_override)\\\\\\\\nstatic int s_test_s3_client_monitoring_options_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_http_connection_monitoring_options monitoring_options = {.minimum_throughput_bytes_per_second = 3000};\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.monitoring_options = &monitoring_options};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        client->monitoring_options.minimum_throughput_bytes_per_second ==\\\\\\\\n        client_config.monitoring_options->minimum_throughput_bytes_per_second);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_proxy_ev_settings_override, s_test_s3_client_proxy_ev_settings_override)\\\\\\\\nstatic int s_test_s3_client_proxy_ev_settings_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_tls_connection_options tls_conn_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_conn_options);\\\\\\\\n\\\\\\\\n    struct proxy_env_var_settings proxy_ev_settings = {\\\\\\\\n        .env_var_type = AWS_HPEV_ENABLE,\\\\\\\\n        .tls_options = &tls_conn_options,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.proxy_ev_settings = &proxy_ev_settings};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->proxy_ev_settings->env_var_type == client_config.proxy_ev_settings->env_var_type);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_tcp_keep_alive_options_override, s_test_s3_client_tcp_keep_alive_options_override)\\\\\\\\nstatic int s_test_s3_client_tcp_keep_alive_options_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tcp_keep_alive_options keep_alive_options = {.keep_alive_interval_sec = 20};\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {.tcp_keep_alive_options = &keep_alive_options};\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        client->tcp_keep_alive_options->keep_alive_interval_sec ==\\\\\\\\n        client_config.tcp_keep_alive_options->keep_alive_interval_sec);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_max_active_connections_override, s_test_s3_client_max_active_connections_override)\\\\\\\\nstatic int s_test_s3_client_max_active_connections_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .max_active_connections_override = 10,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->max_active_connections_override == client_config.max_active_connections_override);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_byo_crypto_no_options, s_test_s3_client_byo_crypto_no_options)\\\\\\\\nstatic int s_test_s3_client_byo_crypto_no_options(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .tls_mode = AWS_MR_TLS_ENABLED,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_last_error() == AWS_ERROR_INVALID_ARGUMENT);\\\\\\\\n    ASSERT_TRUE(client == NULL);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_byo_crypto_with_options, s_test_s3_client_byo_crypto_with_options)\\\\\\\\nstatic int s_test_s3_client_byo_crypto_with_options(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_conn_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_conn_options);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0));\\\\\\\\n\\\\\\\\n    client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n    client_config.tls_connection_options = &tls_conn_options;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nsize_t s_test_max_active_connections_host_count = 0;\\\\\\\\n\\\\\\\\nsize_t s_test_get_max_active_connections_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    return s_test_max_active_connections_host_count;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_client_get_max_active_connections, s_test_s3_client_get_max_active_connections)\\\\\\\\nstatic int s_test_s3_client_get_max_active_connections(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)allocator;\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_client_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_client_bootstrap);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    *((uint32_t *)&mock_client->max_active_connections_override) = 0;\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = 100;\\\\\\\\n    mock_client->client_bootstrap = &mock_client_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_get_max_active_connections_host_address_count;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_requests[AWS_S3_META_REQUEST_TYPE_MAX];\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n        /* Setup test data. */\\\\\\\\n        mock_meta_requests[i] = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n        mock_meta_requests[i]->type = i;\\\\\\\\n        mock_meta_requests[i]->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    s_test_max_active_connections_host_count = 2;\\\\\\\\n\\\\\\\\n    /* Behavior should not be affected by max_active_connections_override since it is 0, and should just be in relation\\\\\\\\n     * to ideal-connection-count. */\\\\\\\\n    {\\\\\\\\n        ASSERT_TRUE(aws_s3_client_get_max_active_connections(mock_client, NULL) == mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->ideal_connection_count);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Max active connections override should now cap the calculated amount of active connections. */\\\\\\\\n    {\\\\\\\\n        *((uint32_t *)&mock_client->max_active_connections_override) = 3;\\\\\\\\n\\\\\\\\n        /* Assert that override is low enough to have effect */\\\\\\\\n        ASSERT_TRUE(mock_client->max_active_connections_override < mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(\\\\\\\\n            aws_s3_client_get_max_active_connections(mock_client, NULL) ==\\\\\\\\n            mock_client->max_active_connections_override);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(mock_client->max_active_connections_override < mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->max_active_connections_override);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Max active connections override should be ignored since the calculated amount of max connections is less. */\\\\\\\\n    {\\\\\\\\n        *((uint32_t *)&mock_client->max_active_connections_override) = 100000;\\\\\\\\n\\\\\\\\n        /* Assert that override is NOT low enough to have effect */\\\\\\\\n        ASSERT_TRUE(mock_client->max_active_connections_override > mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(aws_s3_client_get_max_active_connections(mock_client, NULL) == mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n        for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n            ASSERT_TRUE(mock_client->max_active_connections_override > mock_client->ideal_connection_count);\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(\\\\\\\\n                aws_s3_client_get_max_active_connections(mock_client, mock_meta_requests[i]) ==\\\\\\\\n                mock_client->ideal_connection_count);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_S3_META_REQUEST_TYPE_MAX; ++i) {\\\\\\\\n        mock_meta_requests[i] = aws_s3_meta_request_release(mock_meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_request_create_destroy, s_test_s3_request_create_destroy)\\\\\\\\nstatic int s_test_s3_request_create_destroy(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const int request_tag = 1234;\\\\\\\\n    const enum aws_s3_request_type request_type = AWS_S3_REQUEST_TYPE_LIST_PARTS;\\\\\\\\n    const uint32_t part_number = 5678;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n    meta_request->client = aws_s3_client_acquire(client);\\\\\\\\n\\\\\\\\n    struct aws_http_message *request_message = aws_s3_tester_dummy_http_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(request_message != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n        meta_request, request_tag, request_type, part_number, AWS_S3_REQUEST_FLAG_RECORD_RESPONSE_HEADERS);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->meta_request == meta_request);\\\\\\\\n    ASSERT_TRUE(request->part_number == part_number);\\\\\\\\n    ASSERT_TRUE(request->request_tag == request_tag);\\\\\\\\n    ASSERT_TRUE(request->request_type == request_type);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"ListParts\\\\\\\\\\\\\", aws_string_c_str(request->operation_name));\\\\\\\\n    ASSERT_TRUE(request->record_response_headers == true);\\\\\\\\n\\\\\\\\n    aws_s3_request_setup_send_data(request, request_message);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->send_data.message != NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers == NULL);\\\\\\\\n\\\\\\\\n    request->send_data.response_headers = aws_http_headers_new(allocator);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers != NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.metrics != NULL);\\\\\\\\n    request->send_data.metrics = aws_s3_request_metrics_release(request->send_data.metrics);\\\\\\\\n\\\\\\\\n    aws_s3_request_clean_up_send_data(request);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(request->send_data.message == NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_headers == NULL);\\\\\\\\n    ASSERT_TRUE(request->send_data.response_status == 0);\\\\\\\\n\\\\\\\\n    aws_s3_request_release(request);\\\\\\\\n    aws_http_message_release(request_message);\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct s3_test_body_streaming_user_data {\\\\\\\\n    struct aws_s3_tester *tester;\\\\\\\\n    struct aws_allocator *allocator;\\\\\\\\n    uint64_t expected_range_start;\\\\\\\\n    uint64_t received_body_size;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic int s_s3_meta_request_test_body_streaming_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)body;\\\\\\\\n    (void)range_start;\\\\\\\\n\\\\\\\\n    struct s3_test_body_streaming_user_data *body_streaming_user_data = user_data;\\\\\\\\n\\\\\\\\n    body_streaming_user_data->received_body_size += body->len;\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_streaming_user_data->expected_range_start == range_start);\\\\\\\\n    body_streaming_user_data->expected_range_start += body->len;\\\\\\\\n\\\\\\\\n    aws_s3_tester_inc_counter1(body_streaming_user_data->tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test the meta request body streaming functionality. */\\\\\\\\nAWS_TEST_CASE(test_s3_meta_request_body_streaming, s_test_s3_meta_request_body_streaming)\\\\\\\\nstatic int s_test_s3_meta_request_body_streaming(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const uint32_t part_range0_start = 1;\\\\\\\\n    const uint32_t part_range0_end = part_range0_start + 4;\\\\\\\\n\\\\\\\\n    const uint32_t part_range1_start = part_range0_end + 1;\\\\\\\\n    const uint32_t part_range1_end = part_range1_start + 4;\\\\\\\\n\\\\\\\\n    const size_t request_response_body_size = 16;\\\\\\\\n\\\\\\\\n    const uint64_t total_object_size = (uint64_t)part_range1_end * request_response_body_size;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf response_body_source_buffer;\\\\\\\\n    aws_byte_buf_init(&response_body_source_buffer, allocator, request_response_body_size);\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor test_byte_cursor = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"0\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < request_response_body_size; ++i) {\\\\\\\\n        aws_byte_buf_append(&response_body_source_buffer, &test_byte_cursor);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct s3_test_body_streaming_user_data body_streaming_user_data = {\\\\\\\\n        .tester = &tester,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_event_loop_group *event_loop_group = aws_event_loop_group_new_default(allocator, 0, NULL);\\\\\\\\n    meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    meta_request->user_data = &body_streaming_user_data;\\\\\\\\n    *((size_t *)&meta_request->part_size) = request_response_body_size;\\\\\\\\n    meta_request->body_callback = s_s3_meta_request_test_body_streaming_callback;\\\\\\\\n    meta_request->io_event_loop = aws_event_loop_group_get_next_loop(event_loop_group);\\\\\\\\n\\\\\\\\n    /* Queue the first range of parts in order. Each part should be flushed one-by-one. */\\\\\\\\n    {\\\\\\\\n        for (uint32_t part_number = part_range0_start; part_number <= part_range0_end; ++part_number) {\\\\\\\\n            struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n                meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_number, 0 /*flags*/);\\\\\\\\n\\\\\\\\n            aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n                0ULL,\\\\\\\\n                total_object_size - 1,\\\\\\\\n                request_response_body_size /*part_size*/,\\\\\\\\n                (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n                part_number,\\\\\\\\n                &request->part_range_start,\\\\\\\\n                &request->part_range_end);\\\\\\\\n\\\\\\\\n            aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n            aws_s3_tester_set_counter1_desired(&tester, part_number);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n            ASSERT_TRUE(aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == 0);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_tester_wait_for_counters(&tester);\\\\\\\\n\\\\\\\\n            aws_s3_request_release(request);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_set_counter1_desired(&tester, part_range1_end);\\\\\\\\n\\\\\\\\n    /* Queue parts for second range, but skip over the first part.*/\\\\\\\\n    {\\\\\\\\n        uint32_t num_parts_queued = 0;\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(part_range1_start != part_range1_end);\\\\\\\\n\\\\\\\\n        for (uint32_t part_number = part_range1_start + 1; part_number <= part_range1_end; ++part_number) {\\\\\\\\n            struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n                meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_number, 0 /*flags*/);\\\\\\\\n\\\\\\\\n            aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n                0ULL,\\\\\\\\n                total_object_size - 1,\\\\\\\\n                request_response_body_size /*part_size*/,\\\\\\\\n                (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n                part_number,\\\\\\\\n                &request->part_range_start,\\\\\\\\n                &request->part_range_end);\\\\\\\\n\\\\\\\\n            aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n            aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n            aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n            aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n            aws_s3_request_release(request);\\\\\\\\n            ++num_parts_queued;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        ASSERT_TRUE(\\\\\\\\n            aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == num_parts_queued);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Stream the last part of the body, which should flush the priority queue. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request = aws_s3_request_new(\\\\\\\\n            meta_request, 0 /*request_tag*/, AWS_S3_REQUEST_TYPE_GET_OBJECT, part_range1_start, 0 /*flags*/);\\\\\\\\n\\\\\\\\n        aws_s3_calculate_auto_ranged_get_part_range(\\\\\\\\n            0ULL,\\\\\\\\n            total_object_size - 1,\\\\\\\\n            request_response_body_size /*part_size*/,\\\\\\\\n            (uint64_t)request_response_body_size /*first_part_size*/,\\\\\\\\n            part_range1_start,\\\\\\\\n            &request->part_range_start,\\\\\\\\n            &request->part_range_end);\\\\\\\\n\\\\\\\\n        aws_byte_buf_init_copy(&request->send_data.response_body, allocator, &response_body_source_buffer);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        aws_s3_meta_request_stream_response_body_synced(meta_request, request);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_lock_synced_data(meta_request);\\\\\\\\n        ASSERT_TRUE(aws_priority_queue_size(&meta_request->synced_data.pending_body_streaming_requests) == 0);\\\\\\\\n        aws_s3_meta_request_unlock_synced_data(meta_request);\\\\\\\\n\\\\\\\\n        aws_s3_request_release(request);\\\\\\\\n\\\\\\\\n        aws_s3_tester_wait_for_counters(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_streaming_user_data.received_body_size == (request_response_body_size * part_range1_end));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_event_loop_group_release(event_loop_group);\\\\\\\\n    aws_byte_buf_clean_up(&response_body_source_buffer);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test aws_s3_client_queue_requests_threaded and aws_s3_client_dequeue_request_threaded */\\\\\\\\nAWS_TEST_CASE(test_s3_client_queue_requests, s_test_s3_client_queue_requests)\\\\\\\\nstatic int s_test_s3_client_queue_requests(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *pivot_request = aws_s3_request_new(mock_meta_request, 0, 0, 0, 0);\\\\\\\\n\\\\\\\\n    struct aws_linked_list pivot_request_list;\\\\\\\\n    aws_linked_list_init(&pivot_request_list);\\\\\\\\n\\\\\\\\n    struct aws_s3_request *requests[] = {\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n        aws_s3_request_new(mock_meta_request, 0, 0, 0, 0),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    const uint32_t num_requests = AWS_ARRAY_SIZE(requests);\\\\\\\\n\\\\\\\\n    struct aws_linked_list request_list;\\\\\\\\n    aws_linked_list_init(&request_list);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        aws_linked_list_push_back(&pivot_request_list, &pivot_request->node);\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &pivot_request_list, false);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 1);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n            aws_linked_list_push_back(&request_list, &requests[i]->node);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Move the requests to the back of the queue. */\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &request_list, false);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&request_list));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests + 1));\\\\\\\\n    ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        /* The first request should be the pivot request since the other requests were pushed to the back. */\\\\\\\\n        struct aws_s3_request *first_request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n        ASSERT_TRUE(first_request == pivot_request);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == num_requests);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        struct aws_s3_request *request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(request == requests[i]);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests - (i + 1)));\\\\\\\\n\\\\\\\\n        if (i < num_requests - 1) {\\\\\\\\n            ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        aws_linked_list_push_back(&pivot_request_list, &pivot_request->node);\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &pivot_request_list, false);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 1);\\\\\\\\n        ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n            aws_linked_list_push_back(&request_list, &requests[i]->node);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Move the requests to the front of the queue. */\\\\\\\\n        aws_s3_client_queue_requests_threaded(mock_client, &request_list, true);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&request_list));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == (num_requests + 1));\\\\\\\\n    ASSERT_TRUE(!aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        struct aws_s3_request *request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(request == requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        /* The last request should be the pivot request since the other requests were pushed to the front. */\\\\\\\\n        struct aws_s3_request *last_request = aws_s3_client_dequeue_request_threaded(mock_client);\\\\\\\\n        ASSERT_TRUE(last_request == pivot_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n    ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n\\\\\\\\n    for (uint32_t i = 0; i < num_requests; ++i) {\\\\\\\\n        aws_s3_request_release(requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_request_release(pivot_request);\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct test_work_meta_request_update_user_data {\\\\\\\\n    bool has_work_remaining;\\\\\\\\n    uint32_t num_prepares;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic bool s_s3_test_work_meta_request_update(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    uint32_t flags,\\\\\\\\n    struct aws_s3_request **out_request) {\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data *user_data = meta_request->user_data;\\\\\\\\n\\\\\\\\n    if (out_request) {\\\\\\\\n        if (user_data->has_work_remaining) {\\\\\\\\n            *out_request = aws_s3_request_new(meta_request, 0, 0, 0, 0);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return user_data->has_work_remaining;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_work_meta_request_schedule_prepare_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    aws_s3_meta_request_prepare_request_callback_fn *callback,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)request;\\\\\\\\n    (void)callback;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data *test_user_data = meta_request->user_data;\\\\\\\\n    ++test_user_data->num_prepares;\\\\\\\\n\\\\\\\\n    aws_s3_request_release(request);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic size_t s_test_s3_update_meta_request_trigger_prepare_host_address_count = 0;\\\\\\\\n\\\\\\\\nstatic size_t s_test_s3_update_meta_request_trigger_prepare_get_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n    return s_test_s3_update_meta_request_trigger_prepare_host_address_count;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_validate_prepared_requests(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    size_t expected_num_being_prepared,\\\\\\\\n    struct aws_s3_meta_request *meta_request_with_work,\\\\\\\\n    struct aws_s3_meta_request *meta_request_without_work) {\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client->threaded_data.request_queue_size == 0);\\\\\\\\n    ASSERT_TRUE(aws_linked_list_empty(&client->threaded_data.request_queue));\\\\\\\\n    ASSERT_TRUE(client->threaded_data.num_requests_being_prepared == expected_num_being_prepared);\\\\\\\\n    ASSERT_TRUE(aws_atomic_load_int(&client->stats.num_requests_in_flight) == expected_num_being_prepared);\\\\\\\\n\\\\\\\\n    uint32_t num_meta_requests_in_list = 0;\\\\\\\\n    bool meta_request_with_work_found = false;\\\\\\\\n\\\\\\\\n    for (struct aws_linked_list_node *node = aws_linked_list_begin(&client->threaded_data.meta_requests);\\\\\\\\n         node != aws_linked_list_end(&client->threaded_data.meta_requests);\\\\\\\\n         node = aws_linked_list_next(node)) {\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request *meta_request =\\\\\\\\n            AWS_CONTAINER_OF(node, struct aws_s3_meta_request, client_process_work_threaded_data);\\\\\\\\n\\\\\\\\n        if (meta_request == meta_request_with_work) {\\\\\\\\n            meta_request_with_work_found = true;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_request != meta_request_without_work);\\\\\\\\n\\\\\\\\n        ++num_meta_requests_in_list;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_with_work_found);\\\\\\\\n    ASSERT_TRUE(num_meta_requests_in_list == 1);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the client will prepare requests correctly. */\\\\\\\\nAWS_TEST_CASE(test_s3_update_meta_requests_trigger_prepare, s_test_s3_update_meta_requests_trigger_prepare)\\\\\\\\nstatic int s_test_s3_update_meta_requests_trigger_prepare(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_bootstrap);\\\\\\\\n\\\\\\\\n    const uint32_t ideal_connection_count = 100;\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    mock_client->client_bootstrap = &mock_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_s3_update_meta_request_trigger_prepare_get_host_address_count;\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = ideal_connection_count;\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.meta_requests);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request_without_work = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request_without_work->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    mock_meta_request_without_work->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n\\\\\\\\n    struct test_work_meta_request_update_user_data mock_meta_request_without_work_data = {\\\\\\\\n        .has_work_remaining = false,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    mock_meta_request_without_work->user_data = &mock_meta_request_without_work_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *meta_request_without_work_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request_without_work, NULL);\\\\\\\\n    meta_request_without_work_vtable->update = s_s3_test_work_meta_request_update;\\\\\\\\n    meta_request_without_work_vtable->schedule_prepare_request = s_s3_test_work_meta_request_schedule_prepare_request;\\\\\\\\n\\\\\\\\n    /* Intentionally push this meta request first to test that it\\'s properly removed from the list. */\\\\\\\\n    aws_linked_list_push_back(\\\\\\\\n        &mock_client->threaded_data.meta_requests,\\\\\\\\n        &mock_meta_request_without_work->client_process_work_threaded_data.node);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_acquire(mock_meta_request_without_work);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request_with_work = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request_with_work->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    struct test_work_meta_request_update_user_data mock_meta_request_with_work_data = {\\\\\\\\n        .has_work_remaining = true,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    mock_meta_request_with_work->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n    mock_meta_request_with_work->user_data = &mock_meta_request_with_work_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *mock_meta_request_with_work_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request_with_work, NULL);\\\\\\\\n    mock_meta_request_with_work_vtable->update = s_s3_test_work_meta_request_update;\\\\\\\\n    mock_meta_request_with_work_vtable->schedule_prepare_request = s_s3_test_work_meta_request_schedule_prepare_request;\\\\\\\\n\\\\\\\\n    aws_linked_list_push_back(\\\\\\\\n        &mock_client->threaded_data.meta_requests,\\\\\\\\n        &mock_meta_request_with_work->client_process_work_threaded_data.node);\\\\\\\\n    aws_s3_meta_request_acquire(mock_meta_request_with_work);\\\\\\\\n\\\\\\\\n    /* With no known addresses, the amount of requests that can be prepared should be lower. */\\\\\\\\n    {\\\\\\\\n        s_test_s3_update_meta_request_trigger_prepare_host_address_count = 0;\\\\\\\\n        aws_s3_client_update_meta_requests_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(s_validate_prepared_requests(\\\\\\\\n            mock_client, g_min_num_connections, mock_meta_request_with_work, mock_meta_request_without_work));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* When the number of known addresses is 1+, the max number of requests should be reached. */\\\\\\\\n    {\\\\\\\\n        const uint32_t max_requests_prepare = aws_s3_client_get_max_requests_prepare(mock_client);\\\\\\\\n\\\\\\\\n        s_test_s3_update_meta_request_trigger_prepare_host_address_count = 1;\\\\\\\\n        aws_s3_client_update_meta_requests_threaded(mock_client);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(s_validate_prepared_requests(\\\\\\\\n            mock_client, max_requests_prepare, mock_meta_request_with_work, mock_meta_request_without_work));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    while (!aws_linked_list_empty(&mock_client->threaded_data.meta_requests)) {\\\\\\\\n        struct aws_linked_list_node *meta_request_node =\\\\\\\\n            aws_linked_list_pop_front(&mock_client->threaded_data.meta_requests);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request *meta_request =\\\\\\\\n            AWS_CONTAINER_OF(meta_request_node, struct aws_s3_meta_request, client_process_work_threaded_data);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_release(meta_request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request_without_work);\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request_with_work);\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct s3_test_update_connections_finish_result_user_data {\\\\\\\\n    struct aws_s3_request *finished_request;\\\\\\\\n    struct aws_s3_request *create_connection_request;\\\\\\\\n\\\\\\\\n    uint32_t finished_request_call_counter;\\\\\\\\n    uint32_t create_connection_request_call_counter;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic void s_s3_test_meta_request_has_finish_result_finished_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    AWS_ASSERT(request);\\\\\\\\n    (void)error_code;\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data *user_data = meta_request->user_data;\\\\\\\\n    user_data->finished_request = request;\\\\\\\\n    ++user_data->finished_request_call_counter;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_meta_request_has_finish_result_client_create_connection_for_request(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    struct aws_s3_request *request) {\\\\\\\\n    (void)client;\\\\\\\\n    (void)request;\\\\\\\\n    AWS_ASSERT(client);\\\\\\\\n    AWS_ASSERT(request);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = request->meta_request;\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data *user_data = meta_request->user_data;\\\\\\\\n    user_data->create_connection_request = request;\\\\\\\\n    ++user_data->create_connection_request_call_counter;\\\\\\\\n}\\\\\\\\n\\\\\\\\nsize_t s_test_update_conns_finish_result_host_address_count(\\\\\\\\n    struct aws_host_resolver *host_resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    uint32_t flags) {\\\\\\\\n    (void)host_resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)flags;\\\\\\\\n\\\\\\\\n    return 1;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the client will correctly discard requests for meta requests that are trying to finish. */\\\\\\\\nAWS_TEST_CASE(test_s3_client_update_connections_finish_result, s_test_s3_client_update_connections_finish_result)\\\\\\\\nstatic int s_test_s3_client_update_connections_finish_result(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    aws_s3_tester_init(allocator, &tester);\\\\\\\\n\\\\\\\\n    struct aws_client_bootstrap mock_client_bootstrap;\\\\\\\\n    AWS_ZERO_STRUCT(mock_client_bootstrap);\\\\\\\\n\\\\\\\\n    struct aws_s3_client *mock_client = aws_s3_tester_mock_client_new(&tester);\\\\\\\\n    mock_client->client_bootstrap = &mock_client_bootstrap;\\\\\\\\n    mock_client->vtable->get_host_address_count = s_test_update_conns_finish_result_host_address_count;\\\\\\\\n    mock_client->vtable->create_connection_for_request =\\\\\\\\n        s_s3_test_meta_request_has_finish_result_client_create_connection_for_request;\\\\\\\\n\\\\\\\\n    *((uint32_t *)&mock_client->ideal_connection_count) = 1;\\\\\\\\n\\\\\\\\n    aws_linked_list_init(&mock_client->threaded_data.request_queue);\\\\\\\\n\\\\\\\\n    struct s3_test_update_connections_finish_result_user_data test_update_connections_finish_result_user_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_update_connections_finish_result_user_data);\\\\\\\\n\\\\\\\\n    /* Put together a mock meta request that is finished. */\\\\\\\\n    struct aws_s3_meta_request *mock_meta_request = aws_s3_tester_mock_meta_request_new(&tester);\\\\\\\\n    mock_meta_request->client = aws_s3_client_acquire(mock_client);\\\\\\\\n    mock_meta_request->synced_data.finish_result_set = true;\\\\\\\\n    mock_meta_request->user_data = &test_update_connections_finish_result_user_data;\\\\\\\\n    mock_meta_request->endpoint = aws_s3_tester_mock_endpoint_new(&tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *mock_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(&tester, mock_meta_request, NULL);\\\\\\\\n    mock_meta_request_vtable->finished_request = s_s3_test_meta_request_has_finish_result_finished_request;\\\\\\\\n\\\\\\\\n    /* Verify that the request does not get sent because the meta request has finish-result. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request = aws_s3_request_new(mock_meta_request, 0, 0, 0, 0);\\\\\\\\n        aws_linked_list_push_back(&mock_client->threaded_data.request_queue, &request->node);\\\\\\\\n        ++mock_client->threaded_data.request_queue_size;\\\\\\\\n\\\\\\\\n        aws_s3_client_update_connections_threaded(mock_client);\\\\\\\\n\\\\\\\\n        /* Request should still have been dequeued, but immediately passed to the meta request finish function. */\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n        ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request == request);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request_call_counter == 1);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request == NULL);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request_call_counter == 0);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    AWS_ZERO_STRUCT(test_update_connections_finish_result_user_data);\\\\\\\\n\\\\\\\\n    /* Verify that a request with the \\'always send\\' flag still gets sent when the meta request has a finish-result. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_request *request =\\\\\\\\n            aws_s3_request_new(mock_meta_request, 0, 0, 0, AWS_S3_REQUEST_FLAG_ALWAYS_SEND);\\\\\\\\n        aws_linked_list_push_back(&mock_client->threaded_data.request_queue, &request->node);\\\\\\\\n        ++mock_client->threaded_data.request_queue_size;\\\\\\\\n\\\\\\\\n        aws_s3_client_update_connections_threaded(mock_client);\\\\\\\\n\\\\\\\\n        /* Request should have been dequeued, and then sent on a connection. */\\\\\\\\n        ASSERT_TRUE(mock_client->threaded_data.request_queue_size == 0);\\\\\\\\n        ASSERT_TRUE(aws_linked_list_empty(&mock_client->threaded_data.request_queue));\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request == NULL);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.finished_request_call_counter == 0);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request == request);\\\\\\\\n        ASSERT_TRUE(test_update_connections_finish_result_user_data.create_connection_request_call_counter == 1);\\\\\\\\n\\\\\\\\n        aws_s3_request_release(request);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(mock_meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(mock_client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_get_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    enum aws_s3_client_tls_usage tls_usage,\\\\\\\\n    uint32_t extra_meta_request_flag,\\\\\\\\n    struct aws_byte_cursor s3_path) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_connection_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_connection_options);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    struct aws_tls_ctx_options tls_context_options;\\\\\\\\n    aws_tls_ctx_options_init_default_client(&tls_context_options, allocator);\\\\\\\\n\\\\\\\\n    struct aws_tls_ctx *context = aws_tls_client_ctx_new(allocator, &tls_context_options);\\\\\\\\n    aws_tls_connection_options_init_from_ctx(&tls_connection_options, context);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    struct aws_string *endpoint =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n    struct aws_byte_cursor endpoint_cursor = aws_byte_cursor_from_string(endpoint);\\\\\\\\n\\\\\\\\n    tls_connection_options.server_name = aws_string_new_from_cursor(allocator, &endpoint_cursor);\\\\\\\\n\\\\\\\\n    switch (tls_usage) {\\\\\\\\n        case AWS_S3_TLS_ENABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n            client_config.tls_connection_options = &tls_connection_options;\\\\\\\\n            break;\\\\\\\\n        case AWS_S3_TLS_DISABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_DISABLED;\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS | extra_meta_request_flag;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_get_object_meta_request(&tester, client, s3_path, flags, NULL));\\\\\\\\n\\\\\\\\n    aws_string_destroy(endpoint);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    aws_tls_ctx_release(context);\\\\\\\\n    aws_tls_connection_options_clean_up(&tls_connection_options);\\\\\\\\n    aws_tls_ctx_options_clean_up(&tls_context_options);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_disabled, s_test_s3_get_object_tls_disabled)\\\\\\\\nstatic int s_test_s3_get_object_tls_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_DISABLED, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_enabled, s_test_s3_get_object_tls_enabled)\\\\\\\\nstatic int s_test_s3_get_object_tls_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_ENABLED, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_tls_default, s_test_s3_get_object_tls_default)\\\\\\\\nstatic int s_test_s3_get_object_tls_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_get_object_helper(allocator, AWS_S3_TLS_DEFAULT, 0, g_pre_existing_object_1MB));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_no_signing, s_test_s3_no_signing)\\\\\\\\nstatic int s_test_s3_no_signing(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_signing_override, s_test_s3_signing_override)\\\\\\\\nstatic int s_test_s3_signing_override(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    /* Getting without signing should fail since the client has no signing set up. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request.*/\\\\\\\\n        struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request(&tester, client, &options, &meta_request_test_results, 0));\\\\\\\\n        ASSERT_TRUE(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0) != AWS_OP_SUCCESS);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Getting with signing should succeed if we set up signing on the meta request. */\\\\\\\\n    {\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n        options.signing_config = &tester.default_signing_config;\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request. */\\\\\\\\n        struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n            &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_less_than_part_size, s_test_s3_get_object_less_than_part_size)\\\\\\\\nstatic int s_test_s3_get_object_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_get_object_meta_request(\\\\\\\\n        &tester, client, g_pre_existing_object_1MB, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_with_part_remainder, s_test_s3_put_object_with_part_remainder)\\\\\\\\nstatic int s_test_s3_put_object_with_part_remainder(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Object size meant to be one megabyte larger than the part size of the client. */\\\\\\\\n                .object_size_mb = 6,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multiple, s_test_s3_get_object_multiple)\\\\\\\\nstatic int s_test_s3_get_object_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_requests[4];\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results[4];\\\\\\\\n    size_t num_meta_requests = AWS_ARRAY_SIZE(meta_requests);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(num_meta_requests == AWS_ARRAY_SIZE(meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        /* Put together a simple S3 Get Object request. */\\\\\\\\n        struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n            allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results[i], allocator);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n        options.message = message;\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results[i]));\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Get Object request. */\\\\\\\\n        meta_requests[i] = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_requests[i] != NULL);\\\\\\\\n\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        meta_requests[i] = aws_s3_meta_request_release(meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < num_meta_requests; ++i) {\\\\\\\\n        aws_s3_tester_validate_get_object_results(&meta_request_test_results[i], 0);\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multiple_serial, s_test_s3_get_object_multiple_serial)\\\\\\\\nstatic int s_test_s3_get_object_multiple_serial(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-10MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < 4; ++i) {\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Sleep for some time to wait for the cleanup task to run */\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(7, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    /* BEGIN CRITICAL SECTION */\\\\\\\\n    aws_s3_client_lock_synced_data(client);\\\\\\\\n\\\\\\\\n    AWS_ASSERT(client->synced_data.num_endpoints_allocated == 0);\\\\\\\\n\\\\\\\\n    aws_s3_client_unlock_synced_data(client);\\\\\\\\n    /* END CRITICAL SECTION */\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path, s_test_s3_get_object_file_path)\\\\\\\\nstatic int s_test_s3_get_object_file_path(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_create_new, s_test_s3_get_object_file_path_create_new)\\\\\\\\nstatic int s_test_s3_get_object_file_path_create_new(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_CREATE_NEW,\\\\\\\\n                .pre_exist_file_length = 10,\\\\\\\\n                .recv_file_delete_on_failure = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_RECV_FILE_ALREADY_EXISTS, aws_last_error());\\\\\\\\n\\\\\\\\n    /* The request failed without invoking the finish callback. Reset the finish and shutdown count */\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_shutdown_count);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n    tester.synced_data.desired_meta_request_shutdown_count = 0;\\\\\\\\n    tester.synced_data.desired_meta_request_finish_count = 0;\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    get_options.validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS;\\\\\\\\n    get_options.get_options.pre_exist_file_length = 0;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_append, s_test_s3_get_object_file_path_append)\\\\\\\\nstatic int s_test_s3_get_object_file_path_append(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    uint64_t pre_exist_file_length = 10;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_CREATE_OR_APPEND,\\\\\\\\n                .pre_exist_file_length = pre_exist_file_length,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(pre_exist_file_length + MB_TO_BYTES(1), meta_request_test_results.received_file_size);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), meta_request_test_results.progress.total_bytes_transferred);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_file_path_to_position, s_test_s3_get_object_file_path_to_position)\\\\\\\\nstatic int s_test_s3_get_object_file_path_to_position(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    uint64_t pre_exist_file_length = 10;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .recv_file_option = AWS_S3_RECV_FILE_WRITE_TO_POSITION,\\\\\\\\n                .pre_exist_file_length = 0,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_RECV_FILE_NOT_FOUND, aws_last_error());\\\\\\\\n\\\\\\\\n    /* The request failed without invoking the finish callback. Reset the finish and shutdown count */\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_shutdown_count);\\\\\\\\n    ASSERT_UINT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n    tester.synced_data.desired_meta_request_shutdown_count = 0;\\\\\\\\n    tester.synced_data.desired_meta_request_finish_count = 0;\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    get_options.validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS;\\\\\\\\n    get_options.get_options.pre_exist_file_length = pre_exist_file_length;\\\\\\\\n    get_options.get_options.recv_file_position = 20;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(\\\\\\\\n        get_options.get_options.recv_file_position + MB_TO_BYTES(1), meta_request_test_results.received_file_size);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), meta_request_test_results.progress.total_bytes_transferred);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_empty_object, s_test_s3_get_object_empty_default)\\\\\\\\nstatic int s_test_s3_get_object_empty_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    return (s_test_s3_get_object_helper(allocator, AWS_S3_TLS_ENABLED, 0, g_pre_existing_empty_object));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_sse_kms, s_test_s3_get_object_sse_kms)\\\\\\\\nstatic int s_test_s3_get_object_sse_kms(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Keep TLS enabled for SSE related download, or it will fail. */\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, AWS_S3_TESTER_SEND_META_REQUEST_SSE_KMS, g_pre_existing_object_kms_10MB);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_sse_aes256, s_test_s3_get_object_sse_aes256)\\\\\\\\nstatic int s_test_s3_get_object_sse_aes256(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Keep TLS enabled for SSE related download, or it will fail. */\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, AWS_S3_TESTER_SEND_META_REQUEST_SSE_AES256, g_pre_existing_object_aes256_10MB);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Assert that GetObject can download an object whose body is XML identical to an \\\\\\\\\\\\\"async error\\\\\\\\\\\\\" aka \\\\\\\\\\\\\"200 error\\\\\\\\\\\\\":\\\\\\\\n * <?xml version=\\\\\\\\\\\\\"1.0\\\\\\\\\\\\\" encoding=\\\\\\\\\\\\\"UTF-8\\\\\\\\\\\\\"?>\\\\\\\\\\\\\\\\n<Error><Code>InternalError</Code>... */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_looks_like_async_error_xml, s_test_s3_get_object_looks_like_async_error_xml)\\\\\\\\nstatic int s_test_s3_get_object_looks_like_async_error_xml(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    return s_test_s3_get_object_helper(\\\\\\\\n        allocator, AWS_S3_TLS_ENABLED, 0 /*extra_meta_request_flag*/, g_pre_existing_object_async_error_xml);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Same as above, but send the \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\" via AWS_S3_META_REQUEST_TYPE_DEFAULT\\\\\\\\n * (instead of the typical AWS_S3_META_REQUEST_TYPE_GET_OBJECT) */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_default_get_object_looks_like_async_error_xml,\\\\\\\\n    s_test_s3_default_get_object_looks_like_async_error_xml)\\\\\\\\nstatic int s_test_s3_default_get_object_looks_like_async_error_xml(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_async_error_xml,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test read-backpressure functionality by repeatedly:\\\\\\\\n * - letting the download stall\\\\\\\\n * - incrementing the read window\\\\\\\\n * - repeat...\\\\\\\\n */\\\\\\\\nstatic int s_apply_backpressure_until_meta_request_finish(\\\\\\\\n    struct aws_s3_tester *tester,\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results,\\\\\\\\n    size_t part_size,\\\\\\\\n    size_t window_initial_size,\\\\\\\\n    uint64_t window_increment_size) {\\\\\\\\n\\\\\\\\n    /* Remember the last time something happened (we received download data, or incremented read window) */\\\\\\\\n    uint64_t last_time_something_happened;\\\\\\\\n    ASSERT_SUCCESS(aws_sys_clock_get_ticks(&last_time_something_happened));\\\\\\\\n\\\\\\\\n    /* To ensure that backpressure is working, we wait a bit after download stalls\\\\\\\\n     * before incrementing the read window again.\\\\\\\\n     * This number also controls the max time we wait for bytes to start arriving\\\\\\\\n     * after incrementing the window.\\\\\\\\n     * If the magic number is too high the test will be slow,\\\\\\\\n     * if it\\'s too low the test will fail on slow networks */\\\\\\\\n    const uint64_t wait_duration_with_nothing_happening =\\\\\\\\n        aws_timestamp_convert(3, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL);\\\\\\\\n\\\\\\\\n    uint64_t accumulated_window_increments = window_initial_size;\\\\\\\\n    uint64_t accumulated_data_size = 0;\\\\\\\\n\\\\\\\\n    while (true) {\\\\\\\\n        /* Check if meta-request is done (don\\'t exit yet, we want to check some numbers first...) */\\\\\\\\n        aws_s3_tester_lock_synced_data(tester);\\\\\\\\n        bool done = tester->synced_data.meta_requests_finished != 0;\\\\\\\\n        aws_s3_tester_unlock_synced_data(tester);\\\\\\\\n\\\\\\\\n        /* Check how much data we\\'ve received */\\\\\\\\n        size_t received_body_size_delta = aws_atomic_exchange_int(&test_results->received_body_size_delta, 0);\\\\\\\\n        accumulated_data_size += (uint64_t)received_body_size_delta;\\\\\\\\n\\\\\\\\n        /* Check that we haven\\'t received more data than the window allows.\\\\\\\\n         * TODO: Stop allowing \\\\\\\\\\\\\"hacky wiggle room\\\\\\\\\\\\\". The current implementation\\\\\\\\n         *       may push more bytes to the user (up to 1 part) than they\\'ve asked for. */\\\\\\\\n        uint64_t hacky_wiggle_room = part_size;\\\\\\\\n        uint64_t max_data_allowed = accumulated_window_increments + hacky_wiggle_room;\\\\\\\\n        ASSERT_TRUE(accumulated_data_size <= max_data_allowed, \\\\\\\\\\\\\"Received more data than the read window allows\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        /* If we\\'re done, we\\'re done */\\\\\\\\n        if (done) {\\\\\\\\n            break;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Figure out how long it\\'s been since we last received data */\\\\\\\\n        uint64_t current_time;\\\\\\\\n        ASSERT_SUCCESS(aws_sys_clock_get_ticks(&current_time));\\\\\\\\n\\\\\\\\n        if (received_body_size_delta != 0) {\\\\\\\\n            last_time_something_happened = current_time;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        uint64_t duration_since_something_happened = current_time - last_time_something_happened;\\\\\\\\n\\\\\\\\n        /* If it seems like data has stopped flowing... */\\\\\\\\n        if (duration_since_something_happened >= wait_duration_with_nothing_happening) {\\\\\\\\n\\\\\\\\n            /* Assert that data stopped flowing because the window reached 0. */\\\\\\\\n            uint64_t current_window = aws_sub_u64_saturating(accumulated_window_increments, accumulated_data_size);\\\\\\\\n            ASSERT_INT_EQUALS(0, current_window, \\\\\\\\\\\\\"Data stopped flowing but read window isn\\'t 0 yet.\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n            /* Open the window a bit (this resets the \\\\\\\\\\\\\"something happened\\\\\\\\\\\\\" timer */\\\\\\\\n            accumulated_window_increments += window_increment_size;\\\\\\\\n            aws_s3_meta_request_increment_read_window(meta_request, window_increment_size);\\\\\\\\n\\\\\\\\n            last_time_something_happened = current_time;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /* Sleep a moment, and loop again... */\\\\\\\\n        aws_thread_current_sleep(aws_timestamp_convert(100, AWS_TIMESTAMP_MILLIS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_get_object_backpressure_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    size_t part_size,\\\\\\\\n    size_t window_initial_size,\\\\\\\\n    uint64_t window_increment_size,\\\\\\\\n    bool file_on_disk) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = part_size,\\\\\\\\n        .enable_read_backpressure = true,\\\\\\\\n        .initial_read_window = window_initial_size,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options = {\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .message = message,\\\\\\\\n    };\\\\\\\\n    struct aws_string *filepath_str = NULL;\\\\\\\\n    if (file_on_disk) {\\\\\\\\n        filepath_str = aws_s3_tester_create_file(allocator, g_pre_existing_object_1MB, NULL);\\\\\\\\n        options.recv_filepath = aws_byte_cursor_from_string(filepath_str);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Increment read window bit by bit until all data is downloaded */\\\\\\\\n    ASSERT_SUCCESS(s_apply_backpressure_until_meta_request_finish(\\\\\\\\n        &tester, meta_request, &meta_request_test_results, part_size, window_initial_size, window_increment_size));\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    /* Regression test:\\\\\\\\n     * Ensure that it\\'s safe to call increment-window even after the meta-request has finished */\\\\\\\\n    aws_s3_meta_request_increment_read_window(meta_request, 1024);\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    if (filepath_str) {\\\\\\\\n        aws_file_delete(filepath_str);\\\\\\\\n        aws_string_destroy(filepath_str);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_small_increments, s_test_s3_get_object_backpressure_small_increments)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_small_increments(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments smaller than part-size.\\\\\\\\n     * Only 1 part at a time should be in flight */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_big_increments, s_test_s3_get_object_backpressure_big_increments)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_big_increments(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments larger than part-size.\\\\\\\\n     * Multiple parts should be in flight at a time */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 8;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size * 3;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_backpressure_initial_size_zero, s_test_s3_get_object_backpressure_initial_size_zero)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_initial_size_zero(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test with initial window size of zero */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 0;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_small_increments_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_small_increments_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_small_increments_recv_filepath(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    /* Test increments smaller than part-size.\\\\\\\\n     * Only 1 part at a time should be in flight */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_big_increments_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_big_increments_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_big_increments_recv_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    /* Test increments larger than part-size.\\\\\\\\n     * Multiple parts should be in flight at a time */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 8;\\\\\\\\n    size_t window_initial_size = 1024;\\\\\\\\n    uint64_t window_increment_size = part_size * 3;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_backpressure_initial_size_zero_recv_filepath,\\\\\\\\n    s_test_s3_get_object_backpressure_initial_size_zero_recv_filepath)\\\\\\\\nstatic int s_test_s3_get_object_backpressure_initial_size_zero_recv_filepath(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    /* Test with initial window size of zero */\\\\\\\\n    (void)ctx;\\\\\\\\n    size_t file_size = 1 * 1024 * 1024; /* Test downloads 1MB file */\\\\\\\\n    size_t part_size = file_size / 4;\\\\\\\\n    size_t window_initial_size = 0;\\\\\\\\n    uint64_t window_increment_size = part_size / 2;\\\\\\\\n    return s_test_s3_get_object_backpressure_helper(\\\\\\\\n        allocator, part_size, window_initial_size, window_increment_size, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_part, s_test_s3_get_object_part)\\\\\\\\nstatic int s_test_s3_get_object_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/get_object_part_test\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /* GET FILE */\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_NO_VALIDATE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .part_number = 2,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_SUCCESS, meta_request_test_results.finished_error_code);\\\\\\\\n    /* Only one request was made to get the second part of the object */\\\\\\\\n    ASSERT_UINT_EQUALS(1, aws_array_list_length(&meta_request_test_results.synced_data.metrics));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    enum aws_s3_client_tls_usage tls_usage,\\\\\\\\n    uint32_t extra_meta_request_flag) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_tls_connection_options tls_connection_options;\\\\\\\\n    AWS_ZERO_STRUCT(tls_connection_options);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    struct aws_tls_ctx_options tls_context_options;\\\\\\\\n    aws_tls_ctx_options_init_default_client(&tls_context_options, allocator);\\\\\\\\n\\\\\\\\n    struct aws_tls_ctx *context = aws_tls_client_ctx_new(allocator, &tls_context_options);\\\\\\\\n    aws_tls_connection_options_init_from_ctx(&tls_connection_options, context);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    struct aws_string *endpoint =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n    struct aws_byte_cursor endpoint_cursor = aws_byte_cursor_from_string(endpoint);\\\\\\\\n\\\\\\\\n    tls_connection_options.server_name = aws_string_new_from_cursor(allocator, &endpoint_cursor);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    switch (tls_usage) {\\\\\\\\n        case AWS_S3_TLS_ENABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_ENABLED;\\\\\\\\n            client_config.tls_connection_options = &tls_connection_options;\\\\\\\\n            break;\\\\\\\\n        case AWS_S3_TLS_DISABLED:\\\\\\\\n            client_config.tls_mode = AWS_MR_TLS_DISABLED;\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_put_object_meta_request(\\\\\\\\n        &tester, client, 10, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS | extra_meta_request_flag, NULL));\\\\\\\\n\\\\\\\\n    aws_string_destroy(endpoint);\\\\\\\\n\\\\\\\\n#ifndef BYO_CRYPTO\\\\\\\\n    aws_tls_ctx_release(context);\\\\\\\\n    aws_tls_connection_options_clean_up(&tls_connection_options);\\\\\\\\n    aws_tls_ctx_options_clean_up(&tls_context_options);\\\\\\\\n#endif\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_disabled, s_test_s3_put_object_tls_disabled)\\\\\\\\nstatic int s_test_s3_put_object_tls_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DISABLED, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_enabled, s_test_s3_put_object_tls_enabled)\\\\\\\\nstatic int s_test_s3_put_object_tls_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_ENABLED, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_tls_default, s_test_s3_put_object_tls_default)\\\\\\\\nstatic int s_test_s3_put_object_tls_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DEFAULT, 0));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_put_object_with_acl, s_test_s3_multipart_put_object_with_acl)\\\\\\\\nstatic int s_test_s3_multipart_put_object_with_acl(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_helper(allocator, AWS_S3_TLS_DEFAULT, AWS_S3_TESTER_SEND_META_REQUEST_PUT_ACL));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_multiple_helper(struct aws_allocator *allocator, bool file_on_disk) {\\\\\\\\n\\\\\\\\n    enum s_numbers { NUM_REQUESTS = 5 };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_requests[NUM_REQUESTS];\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results[NUM_REQUESTS];\\\\\\\\n    struct aws_http_message *messages[NUM_REQUESTS];\\\\\\\\n    struct aws_input_stream *input_streams[NUM_REQUESTS];\\\\\\\\n    struct aws_byte_buf input_stream_buffers[NUM_REQUESTS];\\\\\\\\n    struct aws_string *filepath_str[NUM_REQUESTS];\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    size_t content_length = MB_TO_BYTES(10);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_s3_meta_request_test_results_init(&meta_request_test_results[i], allocator);\\\\\\\\n        char object_path_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n        snprintf(\\\\\\\\n            object_path_buffer,\\\\\\\\n            sizeof(object_path_buffer),\\\\\\\\n            \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-10MB-%zu.txt\\\\\\\\\\\\\",\\\\\\\\n            AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n            i);\\\\\\\\n        AWS_ZERO_STRUCT(input_stream_buffers[i]);\\\\\\\\n        aws_s3_create_test_buffer(allocator, content_length, &input_stream_buffers[i]);\\\\\\\\n        struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&input_stream_buffers[i]);\\\\\\\\n        input_streams[i] = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n        struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(object_path_buffer);\\\\\\\\n        struct aws_byte_cursor host_cur = aws_byte_cursor_from_string(host_name);\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_options options;\\\\\\\\n        AWS_ZERO_STRUCT(options);\\\\\\\\n        options.type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT;\\\\\\\\n        if (file_on_disk) {\\\\\\\\n            filepath_str[i] = aws_s3_tester_create_file(allocator, test_object_path, input_streams[i]);\\\\\\\\n            messages[i] = aws_s3_test_put_object_request_new_without_body(\\\\\\\\n                allocator, &host_cur, g_test_body_content_type, test_object_path, content_length, 0 /*flags*/);\\\\\\\\n            options.send_filepath = aws_byte_cursor_from_string(filepath_str[i]);\\\\\\\\n        } else {\\\\\\\\n            filepath_str[i] = NULL;\\\\\\\\n            messages[i] = aws_s3_test_put_object_request_new(\\\\\\\\n                allocator, &host_cur, test_object_path, g_test_body_content_type, input_streams[i], 0);\\\\\\\\n        }\\\\\\\\n        options.message = messages[i];\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results[i]));\\\\\\\\n\\\\\\\\n        /* Trigger accelerating of our Put Object request. */\\\\\\\\n        meta_requests[i] = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(meta_requests[i] != NULL);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        meta_requests[i] = aws_s3_meta_request_release(meta_requests[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_s3_tester_validate_get_object_results(&meta_request_test_results[i], 0);\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&meta_request_test_results[i]);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < NUM_REQUESTS; ++i) {\\\\\\\\n        aws_http_message_release(messages[i]);\\\\\\\\n        aws_input_stream_release(input_streams[i]);\\\\\\\\n        aws_byte_buf_clean_up(&input_stream_buffers[i]);\\\\\\\\n        if (filepath_str[i]) {\\\\\\\\n            ASSERT_SUCCESS(aws_file_delete(filepath_str[i]));\\\\\\\\n            aws_string_destroy(filepath_str[i]);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multiple, s_test_s3_put_object_multiple)\\\\\\\\nstatic int s_test_s3_put_object_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_put_object_multiple_helper(allocator, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multiple_with_filepath, s_test_s3_put_object_multiple_with_filepath)\\\\\\\\nstatic int s_test_s3_put_object_multiple_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_put_object_multiple_helper(allocator, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_less_than_part_size, s_test_s3_put_object_less_than_part_size)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_buffer_pool_trim, s_test_s3_put_object_buffer_pool_trim)\\\\\\\\nstatic int s_test_s3_put_object_buffer_pool_trim(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 8 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 32,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    struct aws_s3_buffer_pool_usage_stats usage_before = aws_s3_buffer_pool_get_usage(client->buffer_pool);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(0 != usage_before.primary_num_blocks);\\\\\\\\n\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(6, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    struct aws_s3_buffer_pool_usage_stats usage_after = aws_s3_buffer_pool_get_usage(client->buffer_pool);\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(0, usage_after.primary_num_blocks);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_less_than_part_size_with_content_encoding,\\\\\\\\n    s_test_s3_put_object_less_than_part_size_with_content_encoding)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size_with_content_encoding(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor content_encoding_cursor = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"gzip\\\\\\\\\\\\\");\\\\\\\\n    uint32_t object_size_mb = 1;\\\\\\\\n    char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n    snprintf(\\\\\\\\n        object_path_sprintf_buffer,\\\\\\\\n        sizeof(object_path_sprintf_buffer),\\\\\\\\n        \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-content-encoding-%uMB.txt\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n        object_size_mb);\\\\\\\\n    struct aws_byte_cursor object_path_cursor = aws_byte_cursor_from_c_str(object_path_sprintf_buffer);\\\\\\\\n\\\\\\\\n    /*** put file with encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_SHA256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path_cursor,\\\\\\\\n                .content_encoding = content_encoding_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** get file and validate encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results get_object_result;\\\\\\\\n    aws_s3_meta_request_test_results_init(&get_object_result, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &get_object_result));\\\\\\\\n    struct aws_byte_cursor content_encoding_header_cursor;\\\\\\\\n    ASSERT_SUCCESS(aws_http_headers_get(\\\\\\\\n        get_object_result.response_headers, g_content_encoding_header_name, &content_encoding_header_cursor));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq(&content_encoding_cursor, &content_encoding_header_cursor));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&get_object_result);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_mpu_with_content_encoding, s_test_s3_put_object_mpu_with_content_encoding)\\\\\\\\nstatic int s_test_s3_put_object_mpu_with_content_encoding(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor content_encoding_cursor = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"gzip\\\\\\\\\\\\\");\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n    char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n    snprintf(\\\\\\\\n        object_path_sprintf_buffer,\\\\\\\\n        sizeof(object_path_sprintf_buffer),\\\\\\\\n        \\\\\\\\\\\\\"\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"-content-encoding-%uMB.txt\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(g_put_object_prefix),\\\\\\\\n        object_size_mb);\\\\\\\\n    struct aws_byte_cursor object_path_cursor = aws_byte_cursor_from_c_str(object_path_sprintf_buffer);\\\\\\\\n\\\\\\\\n    /*** put file with encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_SHA256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path_cursor,\\\\\\\\n                .content_encoding = content_encoding_cursor,\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** get file and validate encoding ***/\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path_cursor,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results get_object_result;\\\\\\\\n    aws_s3_meta_request_test_results_init(&get_object_result, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &get_object_result));\\\\\\\\n    struct aws_byte_cursor content_encoding_header_cursor;\\\\\\\\n    ASSERT_SUCCESS(aws_http_headers_get(\\\\\\\\n        get_object_result.response_headers, g_content_encoding_header_name, &content_encoding_header_cursor));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq(&content_encoding_cursor, &content_encoding_header_cursor));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&get_object_result);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multipart_threshold, s_test_s3_put_object_multipart_threshold)\\\\\\\\nstatic int s_test_s3_put_object_multipart_threshold(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n        .multipart_upload_threshold = MB_TO_BYTES(15),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    /* First smaller than the part size */\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 5,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a single part upload, and have 0 as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(0, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    /* Second smaller than threshold and larger than part size */\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    put_options.put_options.object_size_mb = 10;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a single part upload, and have 0 as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(0, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    /* Third larger than threshold*/\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    put_options.put_options.object_size_mb = 20;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in multi-part upload, and have the real part size */\\\\\\\\n    ASSERT_UINT_EQUALS(client_config.part_size, meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_threshold_less_than_part_size,\\\\\\\\n    s_test_s3_put_object_multipart_threshold_less_than_part_size)\\\\\\\\nstatic int s_test_s3_put_object_multipart_threshold_less_than_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n        .multipart_upload_threshold = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    /* First smaller than the part size */\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 6,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    /* Result in a one part of multipart upload, and have the content length as part size */\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(put_options.put_options.object_size_mb), meta_request_test_results.part_size);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_empty_object, s_test_s3_put_object_empty_object)\\\\\\\\nstatic int s_test_s3_put_object_empty_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 0,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s3_no_content_length_test_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    uint32_t object_size_in_mb,\\\\\\\\n    bool use_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = use_checksum ? AWS_SCA_CRC32 : AWS_SCA_NONE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_in_mb,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_no_content_length, s_test_s3_put_object_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 19, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_single_part_no_content_length, s_test_s3_put_object_single_part_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_single_part_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 5, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_zero_size_no_content_length, s_test_s3_put_object_zero_size_no_content_length)\\\\\\\\nstatic int s_test_s3_put_object_zero_size_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 0, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_large_object_no_content_length_with_checksum,\\\\\\\\n    s_test_s3_put_large_object_no_content_length_with_checksum)\\\\\\\\nstatic int s_test_s3_put_large_object_no_content_length_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    ASSERT_SUCCESS(s3_no_content_length_test_helper(allocator, ctx, 128, true));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Once upon a time, we have a bug that without content-length, we will schedule more requests to prepare than needed.\\\\\\\\n * And those extra request will be cleaned up, however, the client level count of `num_requests_being_prepared` will\\\\\\\\n * still keep record for those.\\\\\\\\n *\\\\\\\\n * To reproduce, we create bunch of requests with less than a part body. And then sleep for a while to let dns resolve\\\\\\\\n * purge all records. (Otherwise, we will always have one valid request to be available to send.) to trigger not going\\\\\\\\n * full speed code. And we will hang.\\\\\\\\n *\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_no_content_length_multiple, s_test_s3_put_object_no_content_length_multiple)\\\\\\\\nstatic int s_test_s3_put_object_no_content_length_multiple(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    aws_s3_set_dns_ttl(55);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    for (int i = 0; i < 6; i++) {\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    }\\\\\\\\n    /* Sleep more than the DNS ttl to purge all records. */\\\\\\\\n    aws_thread_current_sleep(aws_timestamp_convert(60, AWS_TIMESTAMP_SECS, AWS_TIMESTAMP_NANOS, NULL));\\\\\\\\n\\\\\\\\n    /* After sleep for a while, make another meta request */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream when we\\'re not doing multipart upload */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_singlepart, s_test_s3_put_object_async_singlepart)\\\\\\\\nstatic int s_test_s3_put_object_async_singlepart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 4,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream in multipart upload */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_multipart, s_test_s3_put_object_async_multipart)\\\\\\\\nstatic int s_test_s3_put_object_async_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 16,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, but the aws_async_input_stream_read() calls all complete synchronously */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_read_completes_synchronously,\\\\\\\\n    s_test_s3_put_object_async_read_completes_synchronously)\\\\\\\\nstatic int s_test_s3_put_object_async_read_completes_synchronously(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .async_read_strategy = AWS_ASYNC_READ_COMPLETES_IMMEDIATELY,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, where it takes multiple read() calls to fill each part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_small_reads, s_test_s3_put_object_async_small_reads)\\\\\\\\nstatic int s_test_s3_put_object_async_small_reads(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .max_bytes_per_read = KB_TO_BYTES(1001), /* something that doesn\\'t evenly divide into 8MB parts */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test synchronous input-stream, where it takes multiple read() calls to fill each part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_small_reads, s_test_s3_put_object_small_reads)\\\\\\\\nstatic int s_test_s3_put_object_small_reads(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .max_bytes_per_read = KB_TO_BYTES(1001), /* something that doesn\\'t evenly divide into 8MB parts */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that doesn\\'t end exactly on a part boundary */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_no_content_length_partial_part,\\\\\\\\n    s_test_s3_put_object_async_no_content_length_partial_part)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_partial_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 3,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that fills exactly 1 part */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_no_content_length_1part, s_test_s3_put_object_async_no_content_length_1part)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_1part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 8,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that doesn\\'t realize\\\\\\\\n * it\\'s at EOF until it tries to read the 2nd part and gets 0 bytes */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_async_no_content_length_empty_part2,\\\\\\\\n    s_test_s3_put_object_async_no_content_length_empty_part2)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_empty_part2(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 8,             /* read 1 part\\'s worth of data */\\\\\\\\n                .eof_requires_extra_read = true, /* don\\'t report EOF until it tries to read 2nd part */\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test async-input-stream, with undeclared Content-Length, that fills multiple parts */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_no_content_length_2parts, s_test_s3_put_object_async_no_content_length_2parts)\\\\\\\\nstatic int s_test_s3_put_object_async_no_content_length_2parts(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 16,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_async_fail_reading, s_test_s3_put_object_async_fail_reading)\\\\\\\\nstatic int s_test_s3_put_object_async_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(AWS_IO_STREAM_READ_FAILED, test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_validate_if_none_match_failure_response(struct aws_s3_meta_request_test_results *test_results) {\\\\\\\\n\\\\\\\\n    /**\\\\\\\\n     * response body should be like:\\\\\\\\n     * <Error>\\\\\\\\n     * <Code>PreconditionFailed</Code>\\\\\\\\n     * <Message>At least one of the pre-conditions you specified did not hold</Message>\\\\\\\\n     * <Condition>If-None-Match</Condition>\\\\\\\\n     * <RequestId></RequestId>\\\\\\\\n     * <HostId></HostId>\\\\\\\\n     * </Error>\\\\\\\\n     */\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor xml_doc = aws_byte_cursor_from_buf(&test_results->error_response_body);\\\\\\\\n    struct aws_byte_cursor error_code_string = {0};\\\\\\\\n    struct aws_byte_cursor condition_string = {0};\\\\\\\\n\\\\\\\\n    const char *error_code_path[] = {\\\\\\\\\\\\\"Error\\\\\\\\\\\\\", \\\\\\\\\\\\\"Code\\\\\\\\\\\\\", NULL};\\\\\\\\n    ASSERT_SUCCESS(aws_xml_get_body_at_path(test_results->allocator, xml_doc, error_code_path, &error_code_string));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq_c_str(&error_code_string, \\\\\\\\\\\\\"PreconditionFailed\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    const char *condition_path[] = {\\\\\\\\\\\\\"Error\\\\\\\\\\\\\", \\\\\\\\\\\\\"Condition\\\\\\\\\\\\\", NULL};\\\\\\\\n    ASSERT_SUCCESS(aws_xml_get_body_at_path(test_results->allocator, xml_doc, condition_path, &condition_string));\\\\\\\\n    ASSERT_TRUE(aws_byte_cursor_eq_c_str(&condition_string, \\\\\\\\\\\\\"If-None-Match\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_if_none_match, s_test_s3_put_object_if_none_match)\\\\\\\\nstatic int s_test_s3_put_object_if_none_match(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n    struct aws_byte_cursor if_none_match_all = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Use pre_exist object so that the request should fail with the expected failure message. */\\\\\\\\n                .object_path_override = g_pre_existing_object_1MB,\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .if_none_match_header = if_none_match_all,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_HTTP_STATUS_CODE_412_PRECONDITION_FAILED, test_results.finished_response_status);\\\\\\\\n    ASSERT_SUCCESS(s_test_validate_if_none_match_failure_response(&test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_mpu_if_none_match, s_test_s3_put_object_mpu_if_none_match)\\\\\\\\nstatic int s_test_s3_put_object_mpu_if_none_match(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n    struct aws_byte_cursor if_none_match_all = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                /* Use pre_exist object so that the request should fail with the expected failure message. */\\\\\\\\n                .object_path_override = g_pre_existing_object_10MB,\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .if_none_match_header = if_none_match_all,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /** Complete MPU can fail with 200 error */\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        AWS_HTTP_STATUS_CODE_412_PRECONDITION_FAILED == test_results.finished_response_status ||\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK == test_results.finished_response_status);\\\\\\\\n    ASSERT_SUCCESS(s_test_validate_if_none_match_failure_response(&test_results));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_kms, s_test_s3_put_object_sse_kms)\\\\\\\\nstatic int s_test_s3_put_object_sse_kms(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_kms_multipart, s_test_s3_put_object_sse_kms_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_kms_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_aes256, s_test_s3_put_object_sse_aes256)\\\\\\\\nstatic int s_test_s3_put_object_sse_aes256(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 20 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_aes256_multipart, s_test_s3_put_object_sse_aes256_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_aes256_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_sse_c_aes256_multipart, s_test_s3_put_object_sse_c_aes256_multipart)\\\\\\\\nstatic int s_test_s3_put_object_sse_c_aes256_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    (void)allocator;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        tester.allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_sse_c.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_C_AES256,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_sse_c_aes256_multipart_with_checksum,\\\\\\\\n    s_test_s3_put_object_sse_c_aes256_multipart_with_checksum)\\\\\\\\nstatic int s_test_s3_put_object_sse_c_aes256_multipart_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        tester.allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_sse_c_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .sse_type = AWS_S3_TESTER_SSE_C_AES256,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_object_content_md5_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    bool multipart_upload,\\\\\\\\n    uint32_t flags,\\\\\\\\n    enum aws_s3_meta_request_compute_content_md5 compute_content_md5) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    size_t part_size = 5 * 1024 * 1024;\\\\\\\\n    if (!multipart_upload) {\\\\\\\\n        /* content_length < part_size */\\\\\\\\n        part_size = 15 * 1024 * 1024;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = part_size,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    client_config.compute_content_md5 = compute_content_md5;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_put_object_meta_request(&tester, client, 10, flags, NULL));\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_no_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_no_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_no_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_no_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_no_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_no_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_correct_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_correct_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_correct_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_correct_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_correct_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_correct_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_incorrect_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_singlepart_incorrect_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_incorrect_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_singlepart_incorrect_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_singlepart_incorrect_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_singlepart_incorrect_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, false, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_no_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_no_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_no_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_no_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_no_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_no_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags = AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_correct_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_correct_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_correct_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_correct_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_correct_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_correct_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_CORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_incorrect_content_md5_enabled,\\\\\\\\n    s_test_s3_put_object_multipart_incorrect_content_md5_enabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_incorrect_content_md5_enabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_ENABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_multipart_incorrect_content_md5_disabled,\\\\\\\\n    s_test_s3_put_object_multipart_incorrect_content_md5_disabled)\\\\\\\\nstatic int s_test_s3_put_object_multipart_incorrect_content_md5_disabled(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    uint32_t flags =\\\\\\\\n        AWS_S3_TESTER_SEND_META_REQUEST_WITH_INCORRECT_CONTENT_MD5 | AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS;\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_object_content_md5_helper(allocator, true, flags, AWS_MR_CONTENT_MD5_DISABLED));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_upload_part_message_helper(struct aws_allocator *allocator, bool should_compute_content_md5) {\\\\\\\\n\\\\\\\\n    aws_s3_library_init(allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n    /* base64 encoded md5 of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */\\\\\\\\n    struct aws_byte_cursor expected_content_md5 = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"+y3U+EY5uFXhVVmRoiJWyA==\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    uint32_t part_number = 1;\\\\\\\\n    struct aws_string *upload_id = aws_string_new_from_c_str(allocator, \\\\\\\\\\\\\"dummy_upload_id\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message = aws_s3_upload_part_message_new(\\\\\\\\n        allocator, base_message, &test_buffer, part_number, upload_id, should_compute_content_md5, NULL, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    if (should_compute_content_md5) {\\\\\\\\n        ASSERT_TRUE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n        struct aws_byte_cursor content_md5;\\\\\\\\n        aws_http_headers_get(new_headers, g_content_md5_header_name, &content_md5);\\\\\\\\n        ASSERT_BIN_ARRAYS_EQUALS(expected_content_md5.ptr, expected_content_md5.len, content_md5.ptr, content_md5.len);\\\\\\\\n    } else {\\\\\\\\n        ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(upload_id);\\\\\\\\n    upload_id = NULL;\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    aws_s3_library_clean_up();\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_part_message_with_content_md5, s_test_s3_upload_part_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_upload_part_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_upload_part_message_helper(allocator, true));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_part_message_without_content_md5, s_test_s3_upload_part_message_without_content_md5)\\\\\\\\nstatic int s_test_s3_upload_part_message_without_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_upload_part_message_helper(allocator, false));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_create_multipart_upload_message_with_content_md5,\\\\\\\\n    s_test_s3_create_multipart_upload_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_create_multipart_upload_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_md5_header = {\\\\\\\\n        .name = g_content_md5_header_name,\\\\\\\\n        .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_content_md5\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_http_message_add_header(base_message, content_md5_header));\\\\\\\\n\\\\\\\\n    struct aws_http_headers *base_headers = aws_http_message_get_headers(base_message);\\\\\\\\n    ASSERT_TRUE(aws_http_headers_has(base_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message = aws_s3_create_multipart_upload_message_new(allocator, base_message, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_complete_multipart_message_with_content_md5,\\\\\\\\n    s_test_s3_complete_multipart_message_with_content_md5)\\\\\\\\nstatic int s_test_s3_complete_multipart_message_with_content_md5(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_buf test_buffer;\\\\\\\\n    aws_s3_create_test_buffer(allocator, 19 /* size of \\\\\\\\\\\\\"This is an S3 test.\\\\\\\\\\\\\" */, &test_buffer);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_body_cursor = aws_byte_cursor_from_buf(&test_buffer);\\\\\\\\n    struct aws_input_stream *input_stream = aws_input_stream_new_from_cursor(allocator, &test_body_cursor);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Put Object request. */\\\\\\\\n    struct aws_http_message *base_message = aws_s3_test_put_object_request_new(\\\\\\\\n        allocator, &host_name, test_object_path, g_test_body_content_type, input_stream, AWS_S3_TESTER_SSE_NONE);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_md5_header = {\\\\\\\\n        .name = g_content_md5_header_name,\\\\\\\\n        .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_content_md5\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_http_message_add_header(base_message, content_md5_header));\\\\\\\\n\\\\\\\\n    struct aws_http_headers *base_headers = aws_http_message_get_headers(base_message);\\\\\\\\n    ASSERT_TRUE(aws_http_headers_has(base_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf body_buffer;\\\\\\\\n    aws_byte_buf_init(&body_buffer, allocator, 512);\\\\\\\\n\\\\\\\\n    struct aws_string *upload_id = aws_string_new_from_c_str(allocator, \\\\\\\\\\\\\"dummy_upload_id\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_array_list parts;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_init_dynamic(&parts, allocator, 0, sizeof(struct aws_s3_mpu_part_info *)));\\\\\\\\n\\\\\\\\n    struct aws_http_message *new_message =\\\\\\\\n        aws_s3_complete_multipart_message_new(allocator, base_message, &body_buffer, upload_id, &parts, NULL);\\\\\\\\n\\\\\\\\n    struct aws_http_headers *new_headers = aws_http_message_get_headers(new_message);\\\\\\\\n    ASSERT_FALSE(aws_http_headers_has(new_headers, g_content_md5_header_name));\\\\\\\\n\\\\\\\\n    aws_http_message_release(new_message);\\\\\\\\n    new_message = NULL;\\\\\\\\n\\\\\\\\n    aws_http_message_release(base_message);\\\\\\\\n    base_message = NULL;\\\\\\\\n\\\\\\\\n    aws_array_list_clean_up(&parts);\\\\\\\\n\\\\\\\\n    aws_string_destroy(upload_id);\\\\\\\\n    upload_id = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&body_buffer);\\\\\\\\n\\\\\\\\n    aws_input_stream_release(input_stream);\\\\\\\\n    input_stream = NULL;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&test_buffer);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_double_slashes, s_test_s3_put_object_double_slashes)\\\\\\\\nstatic int s_test_s3_put_object_double_slashes(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix//test.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip, s_test_s3_round_trip)\\\\\\\\nstatic int s_test_s3_round_trip(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get, s_test_s3_round_trip_default_get)\\\\\\\\nstatic int s_test_s3_round_trip_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_default.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_validate_headers_checksum_set(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)headers;\\\\\\\\n    struct aws_s3_meta_request_test_results *meta_request_test_results =\\\\\\\\n        (struct aws_s3_meta_request_test_results *)user_data;\\\\\\\\n    ASSERT_NOT_NULL(meta_request->meta_request_level_running_response_sum);\\\\\\\\n    ASSERT_INT_EQUALS(\\\\\\\\n        meta_request->meta_request_level_running_response_sum->algorithm, meta_request_test_results->algorithm);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_validate_headers_checksum_unset(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)user_data;\\\\\\\\n    ASSERT_NULL(meta_request->meta_request_level_running_response_sum);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nvoid s_s3_test_validate_checksum(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *result,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    struct aws_s3_meta_request_test_results *meta_request_test_results =\\\\\\\\n        (struct aws_s3_meta_request_test_results *)user_data;\\\\\\\\n    AWS_FATAL_ASSERT(result->did_validate);\\\\\\\\n    AWS_FATAL_ASSERT(result->validation_algorithm == meta_request_test_results->algorithm);\\\\\\\\n    AWS_FATAL_ASSERT(result->error_code == AWS_OP_SUCCESS);\\\\\\\\n}\\\\\\\\nvoid s_s3_test_no_validate_checksum(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *result,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)user_data;\\\\\\\\n    AWS_FATAL_ASSERT(!result->did_validate);\\\\\\\\n    AWS_FATAL_ASSERT(result->error_code == AWS_OP_SUCCESS);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* TODO: maybe refactor the fc -> flexible checksum tests to be less copy/paste */\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header,\\\\\\\\n    uint32_t object_size_mb,\\\\\\\\n    enum aws_s3_tester_full_object_checksum full_object_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    for (size_t i = 0; i < AWS_ARRAY_SIZE(s_checksum_algo_priority_list); i++) {\\\\\\\\n        enum aws_s3_checksum_algorithm algorithm = s_checksum_algo_priority_list[i];\\\\\\\\n        char object_path_sprintf_buffer[128] = \\\\\\\\\\\\\"\\\\\\\\\\\\\";\\\\\\\\n        snprintf(\\\\\\\\n            object_path_sprintf_buffer,\\\\\\\\n            sizeof(object_path_sprintf_buffer),\\\\\\\\n            \\\\\\\\\\\\\"/prefix/round_trip/test_default_fc_%d_%d.txt\\\\\\\\\\\\\",\\\\\\\\n            algorithm,\\\\\\\\n            object_size_mb);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n            allocator, &path_buf, aws_byte_cursor_from_c_str(object_path_sprintf_buffer)));\\\\\\\\n        struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n        /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n        struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n            .client = client,\\\\\\\\n            .checksum_algorithm = algorithm,\\\\\\\\n            .validate_get_response_checksum = false,\\\\\\\\n            .checksum_via_header = via_header,\\\\\\\\n            .put_options =\\\\\\\\n                {\\\\\\\\n                    .object_size_mb = object_size_mb,\\\\\\\\n                    .object_path_override = object_path,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n        if (algorithm != AWS_SCA_SHA1 && algorithm != AWS_SCA_SHA256) {\\\\\\\\n            /* Full object checksums doesn\\'t support SHA. */\\\\\\\\n            put_options.put_options.full_object_checksum = full_object_checksum;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n        /*** GET FILE ***/\\\\\\\\n\\\\\\\\n        struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .client = client,\\\\\\\\n            .expected_validate_checksum_alg = algorithm,\\\\\\\\n            .validate_get_response_checksum = true,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = object_path,\\\\\\\\n                },\\\\\\\\n            .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n            .headers_callback = s_s3_validate_headers_checksum_set,\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n        aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get_fc, s_test_s3_round_trip_default_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 1 /*object_size_mb*/, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_empty_fc, s_test_s3_round_trip_empty_fc)\\\\\\\\nstatic int s_test_s3_round_trip_empty_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 0, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_default_get_fc_header, s_test_s3_round_trip_default_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, true, 1, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_default_get_full_object_checksum_fc,\\\\\\\\n    s_test_s3_round_trip_default_get_full_object_checksum_fc)\\\\\\\\nstatic int s_test_s3_round_trip_default_get_full_object_checksum_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_default_get_fc_helper(allocator, ctx, false, 1, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc_helper(struct aws_allocator *allocator, void *ctx, bool via_header) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC64NVME,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC64NVME,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .headers_callback = s_s3_validate_headers_checksum_set,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_multipart_get_fc, s_test_s3_round_trip_multipart_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_multipart_get_fc_helper(allocator, ctx, false);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_multipart_get_fc_header, s_test_s3_round_trip_multipart_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_multipart_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_multipart_get_fc_helper(allocator, ctx, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test the multipart uploaded object was downloaded with same part size, which will download the object matches all the\\\\\\\\n * parts and validate the parts checksum. */\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header,\\\\\\\\n    enum aws_s3_tester_full_object_checksum full_object_checksum) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n    struct aws_byte_cursor object_name;\\\\\\\\n    /* Use different name to avoid collision when tests run concurrently. */\\\\\\\\n    switch (full_object_checksum) {\\\\\\\\n        case AWS_TEST_FOC_CALLBACK:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc_full_object_via_callback.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n        case AWS_TEST_FOC_HEADER:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc_full_object_via_header.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n        default:\\\\\\\\n            object_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc.txt\\\\\\\\\\\\\");\\\\\\\\n            break;\\\\\\\\n    }\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(allocator, &path_buf, object_name));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .full_object_checksum = full_object_checksum,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_multipart_get_fc, s_test_s3_round_trip_mpu_multipart_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_multipart_get_fc_header, s_test_s3_round_trip_mpu_multipart_get_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_fc_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, true, AWS_TEST_FOC_NONE);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_fc_header(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, true, AWS_TEST_FOC_HEADER);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_full_object_checksum_via_callback(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    return s_test_s3_round_trip_mpu_multipart_get_fc_helper(allocator, ctx, false, AWS_TEST_FOC_CALLBACK);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    bool via_header) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_s3_tester_upload_file_path_init(allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/empty-file-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .checksum_via_header = via_header,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 0,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE WITH GET_FIRST_PART ***/\\\\\\\\n    uint64_t small_object_size_hint = 1;\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .object_size_hint =\\\\\\\\n            &small_object_size_hint /* pass a object_size_hint > 0 so that the request goes through the getPart flow */,\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE WITH HEAD_OBJECT ***/\\\\\\\\n    get_options.object_size_hint = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_empty_file_with_checksum, s_test_s3_download_empty_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_download_empty_file_with_checksum_helper(allocator, ctx, false);\\\\\\\\n}\\\\\\\\nAWS_TEST_CASE(test_s3_download_empty_file_with_checksum_header, s_test_s3_download_empty_file_with_checksum_header)\\\\\\\\nstatic int s_test_s3_download_empty_file_with_checksum_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    return s_test_s3_download_empty_file_with_checksum_helper(allocator, ctx, true);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_single_part_file_with_checksum, s_test_s3_download_single_part_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_single_part_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(10),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/single-part-10Mb-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    uint64_t object_size_hint = MB_TO_BYTES(object_size_mb);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n        .object_size_hint = &object_size_hint,\\\\\\\\n    };\\\\\\\\n    uint64_t small_object_size_hint = MB_TO_BYTES(1);\\\\\\\\n\\\\\\\\n    /* will do headRequest */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(20);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n\\\\\\\\n    /* will do getPart */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /* will do getPart */\\\\\\\\n    /*** GET FILE with part_size = file_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(10);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < file_size and wrong object_size_hint ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.object_size_hint = &small_object_size_hint;\\\\\\\\n    /* will do getPart first, cancel it and then rangedGet */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_download_multipart_file_with_checksum, s_test_s3_download_multipart_file_with_checksum)\\\\\\\\nstatic int s_test_s3_download_multipart_file_with_checksum(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Upload the file */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/multipart-10Mb-CRC32.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n    uint32_t object_size_mb = 10;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    uint64_t object_size_hint = MB_TO_BYTES(object_size_mb);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .object_size_hint = &object_size_hint,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* will do HeadRequest first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(7);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    /* will do HeadObject first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size = first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(5);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    /* will do HeadObject First */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    uint64_t small_object_size_hint = 1;\\\\\\\\n\\\\\\\\n    /*** GET FILE with with wrong object_size_hint ***/\\\\\\\\n    get_options.object_size_hint = &small_object_size_hint;\\\\\\\\n    get_options.finish_callback = NULL;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size < first_part_size***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(3);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n\\\\\\\\n    /* will do GetPart, cancel the request and then do ranged Gets. */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(7);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n\\\\\\\\n    /* will do GetPart first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size = first_part_size ***/\\\\\\\\n    client_options.part_size = MB_TO_BYTES(5);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    /* will do GetPart first */\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n\\\\\\\\n    /*** GET FILE with part_size > fileSize ***/\\\\\\\\n    /* TODO: Enable this test once the checksum issue is resolved. Currently, when the S3 GetObject API is called with\\\\\\\\n     * the range 0-contentLength, it returns a checksum of checksums without the -numParts portion. This leads to a\\\\\\\\n     * checksum mismatch error, as it is incorrectly validated as a part checksum. */\\\\\\\\n    /*\\\\\\\\n    client_options.part_size = MB_TO_BYTES(20);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    get_options.client = client;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    tester.bound_to_client = false;\\\\\\\\n    */\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc,\\\\\\\\n    s_test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_multipart_get_with_list_algorithm_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_array_list response_checksum_list;\\\\\\\\n    /* Check for all algorithm but the CRC32 */\\\\\\\\n    ASSERT_SUCCESS(\\\\\\\\n        aws_array_list_init_dynamic(&response_checksum_list, allocator, 4, sizeof(enum aws_s3_checksum_algorithm)));\\\\\\\\n    enum aws_s3_checksum_algorithm alg = AWS_SCA_CRC32C;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    alg = AWS_SCA_SHA1;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    alg = AWS_SCA_SHA256;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .validate_checksum_algorithms = &response_checksum_list,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_no_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    /* Push all the algorithms to the list for validation, now we should have the checksum validated. */\\\\\\\\n    alg = AWS_SCA_CRC32;\\\\\\\\n    ASSERT_SUCCESS(aws_array_list_push_back(&response_checksum_list, &alg));\\\\\\\\n    get_options.finish_callback = s_s3_test_validate_checksum;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_array_list_clean_up(&response_checksum_list);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_default_get_fc, s_test_s3_round_trip_mpu_default_get_fc)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_default_get_fc(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/test_mpu_default_get_fc.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, NULL));\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_no_validate_checksum,\\\\\\\\n        .headers_callback = s_s3_validate_headers_checksum_unset,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor key,\\\\\\\\n    int object_size_mb,\\\\\\\\n    bool unknown_content_length) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(8),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    /*** PUT FILE ***/\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(allocator, &path_buf, key));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = object_size_mb,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n                .skip_content_length = unknown_content_length,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    /*** GET FILE ***/\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(\\\\\\\\n        MB_TO_BYTES(put_options.put_options.object_size_mb), test_results.progress.total_bytes_transferred);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_with_filepath, s_test_s3_round_trip_with_filepath)\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath\\\\\\\\\\\\\"), 1, false /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_mpu_with_filepath, s_test_s3_round_trip_mpu_with_filepath)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_with_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_mpu\\\\\\\\\\\\\"),\\\\\\\\n        50,\\\\\\\\n        false /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_round_trip_with_filepath_no_content_length, s_test_s3_round_trip_with_filepath_no_content_length)\\\\\\\\nstatic int s_test_s3_round_trip_with_filepath_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_no_content_length\\\\\\\\\\\\\"),\\\\\\\\n        1,\\\\\\\\n        true /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_round_trip_mpu_with_filepath_no_content_length,\\\\\\\\n    s_test_s3_round_trip_mpu_with_filepath_no_content_length)\\\\\\\\nstatic int s_test_s3_round_trip_mpu_with_filepath_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_test_s3_round_trip_with_filepath_helper(\\\\\\\\n        allocator,\\\\\\\\n        aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/round_trip/with_filepath_mpu_no_content_length\\\\\\\\\\\\\"),\\\\\\\\n        50,\\\\\\\\n        true /*unknown_content_length*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_chunked_then_unchunked, s_test_s3_chunked_then_unchunked)\\\\\\\\nstatic int s_test_s3_chunked_then_unchunked(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    /* Test to see if signed_body_value modified when signing chunked request */\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_buf path_buf;\\\\\\\\n    AWS_ZERO_STRUCT(path_buf);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/chunked_unchunked/test_chunked.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor chunked_object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options chunked_put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = chunked_object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &chunked_put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_upload_file_path_init(\\\\\\\\n        allocator, &path_buf, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/prefix/chunked_unchunked/test_unchunked.txt\\\\\\\\\\\\\")));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor unchunked_object_path = aws_byte_cursor_from_buf(&path_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options unchunked_put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_NONE,\\\\\\\\n        .validate_get_response_checksum = false,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = unchunked_object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &unchunked_put_options, NULL));\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&path_buf);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_meta_request_default, s_test_s3_meta_request_default)\\\\\\\\nstatic int s_test_s3_meta_request_default(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n\\\\\\\\n    /* Pass the request through as a default request so that it goes through as-is. */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code == AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    /* Check the size of the metrics should be the same as the number of\\\\\\\\n    requests, which should be 1 */\\\\\\\\n    ASSERT_UINT_EQUALS(1, aws_array_list_length(&meta_request_test_results.synced_data.metrics));\\\\\\\\n    struct aws_s3_request_metrics *metrics = NULL;\\\\\\\\n    aws_array_list_back(&meta_request_test_results.synced_data.metrics, (void **)&metrics);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_error_missing_file, s_test_s3_error_missing_file)\\\\\\\\nstatic int s_test_s3_error_missing_file(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor test_object_path =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/non-existing-file12345.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message =\\\\\\\\n        aws_s3_test_get_object_request_new(allocator, aws_byte_cursor_from_string(host_name), test_object_path);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_meta_request(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &options);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request != NULL);\\\\\\\\n\\\\\\\\n    /* Wait for the request to finish. */\\\\\\\\n    aws_s3_tester_wait_for_meta_request_finish(&tester);\\\\\\\\n\\\\\\\\n    aws_s3_tester_lock_synced_data(&tester);\\\\\\\\n    ASSERT_TRUE(tester.synced_data.finish_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n    aws_s3_tester_unlock_synced_data(&tester);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_response_status == 404);\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.error_response_headers != NULL);\\\\\\\\n\\\\\\\\n    ASSERT_NOT_NULL(meta_request_test_results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(meta_request_test_results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(meta_request_test_results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    meta_request = aws_s3_meta_request_release(meta_request);\\\\\\\\n\\\\\\\\n    aws_s3_tester_wait_for_meta_request_shutdown(&tester);\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    message = NULL;\\\\\\\\n\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    host_name = NULL;\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_test_s3_existing_host_entry_address_resolved_callback(\\\\\\\\n    struct aws_host_resolver *resolver,\\\\\\\\n    const struct aws_string *host_name,\\\\\\\\n    int err_code,\\\\\\\\n    const struct aws_array_list *host_addresses,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)resolver;\\\\\\\\n    (void)host_name;\\\\\\\\n    (void)err_code;\\\\\\\\n    (void)host_addresses;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = user_data;\\\\\\\\n    AWS_ASSERT(tester);\\\\\\\\n    aws_s3_tester_notify_signal(tester);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_existing_host_entry, s_test_s3_existing_host_entry)\\\\\\\\nstatic int s_test_s3_existing_host_entry(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_host_resolution_config host_resolver_config;\\\\\\\\n        AWS_ZERO_STRUCT(host_resolver_config);\\\\\\\\n        host_resolver_config.impl = aws_default_dns_resolve;\\\\\\\\n        host_resolver_config.max_ttl = 30;\\\\\\\\n        host_resolver_config.impl_data = NULL;\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_host_resolver_resolve_host(\\\\\\\\n            client_config.client_bootstrap->host_resolver,\\\\\\\\n            host_name,\\\\\\\\n            s_test_s3_existing_host_entry_address_resolved_callback,\\\\\\\\n            &host_resolver_config,\\\\\\\\n            &tester));\\\\\\\\n\\\\\\\\n        aws_s3_tester_wait_for_signal(&tester);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    /* Trigger accelerating of our Get Object request. */\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_bad_endpoint, s_test_s3_bad_endpoint)\\\\\\\\nstatic int s_test_s3_bad_endpoint(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor test_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"test_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    AWS_STATIC_STRING_FROM_LITERAL(invalid_host_name, \\\\\\\\\\\\\"invalid_host_name_totally_absolutely\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    /* Construct a message that points to an invalid host name. Key can be anything. */\\\\\\\\n    struct aws_http_message *message =\\\\\\\\n        aws_s3_test_get_object_request_new(allocator, aws_byte_cursor_from_string(invalid_host_name), test_key);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT;\\\\\\\\n    options.message = message;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(&tester, client, &options, &meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        meta_request_test_results.finished_error_code == AWS_IO_DNS_INVALID_NAME ||\\\\\\\\n        meta_request_test_results.finished_error_code == AWS_IO_DNS_QUERY_FAILED);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_raise_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_body_callback_raise_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)body;\\\\\\\\n    (void)range_start;\\\\\\\\n    (void)user_data;\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_fail_headers_callback, s_test_s3_put_object_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_put_object_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_fail_body_callback, s_test_s3_put_object_fail_body_callback)\\\\\\\\nstatic int s_test_s3_put_object_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n\\\\\\\\n        /* Put object currently never invokes the body callback, which means it should not fail. */\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, NULL));\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_fail_headers_callback, s_test_s3_get_object_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_get_object_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_fail_body_callback, s_test_s3_get_object_fail_body_callback)\\\\\\\\nstatic int s_test_s3_get_object_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_headers_callback, s_test_s3_default_fail_headers_callback)\\\\\\\\nstatic int s_test_s3_default_fail_headers_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_atomic_var s_test_headers_callback_invoked;\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_check_returns_success(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    /* increments counter to check if callback was invoked exactly once */\\\\\\\\n    aws_atomic_fetch_add(&s_test_headers_callback_invoked, 1);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_test_headers_callback_check_returns_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)headers;\\\\\\\\n    (void)response_status;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    /* increments counter to check if callback was invoked exactly once */\\\\\\\\n    aws_atomic_fetch_add(&s_test_headers_callback_invoked, 1);\\\\\\\\n\\\\\\\\n    aws_raise_error(AWS_ERROR_UNKNOWN);\\\\\\\\n    return AWS_OP_ERR;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_invoke_headers_callback_on_error, s_test_s3_default_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_default_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_default_invoke_headers_callback_cancels_on_error,\\\\\\\\n    s_test_s3_default_invoke_headers_callback_cancels_on_error)\\\\\\\\nstatic int s_test_s3_default_invoke_headers_callback_cancels_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_get_object_invoke_headers_callback_on_error,\\\\\\\\n    s_test_s3_get_object_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_get_object_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_invoke_headers_callback_on_error,\\\\\\\\n    s_test_s3_put_object_invoke_headers_callback_on_error)\\\\\\\\nstatic int s_test_s3_put_object_invoke_headers_callback_on_error(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_success,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .invalid_request = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INVALID_RESPONSE_STATUS, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation,\\\\\\\\n    s_test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation)\\\\\\\\nstatic int s_test_s3_put_object_invoke_headers_callback_on_error_with_user_cancellation(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    aws_atomic_init_int(&s_test_headers_callback_invoked, 0);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .headers_callback = s_s3_test_headers_callback_check_returns_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_INT_EQUALS(1, aws_atomic_load_int(&s_test_headers_callback_invoked));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_UNKNOWN, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_body_callback, s_test_s3_default_fail_body_callback)\\\\\\\\nstatic int s_test_s3_default_fail_body_callback(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n        .body_callback = s_s3_test_body_callback_raise_error,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_UNKNOWN);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that if a DEFAULt meta-request sets the operation_name, and gets an error response,\\\\\\\\n * then aws_s3_meta_request_result.error_response_operation_name is set. */\\\\\\\\nAWS_TEST_CASE(test_s3_default_fail_operation_name, s_test_s3_default_fail_operation_name)\\\\\\\\nstatic int s_test_s3_default_fail_operation_name(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor invalid_path = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"___INVALID_PATH___\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .default_type_options =\\\\\\\\n            {\\\\\\\\n                .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = invalid_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code == AWS_ERROR_S3_INVALID_RESPONSE_STATUS);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\", aws_string_c_str(meta_request_test_results.error_response_operation_name));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_invalid_request, s_test_s3_put_fail_object_invalid_request)\\\\\\\\nstatic int s_test_s3_put_fail_object_invalid_request(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .invalid_request = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INVALID_RESPONSE_STATUS, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    /* Since 1MB is under part_size, there will be a single PutObject request */\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"PutObject\\\\\\\\\\\\\", aws_string_c_str(meta_request_test_results.error_response_operation_name));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that we fail to create a metarequest when an invalid `send_filepath` is passed in */\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_invalid_send_filepath, s_test_s3_put_fail_object_invalid_send_filepath)\\\\\\\\nstatic int s_test_s3_put_fail_object_invalid_send_filepath(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor host_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_host\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor object_key = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"dummy_key\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = aws_s3_test_put_object_request_new_without_body(\\\\\\\\n        allocator, &host_name, g_test_body_content_type, object_key, 1024 /*content_length*/, 0 /*flags*/);\\\\\\\\n    ASSERT_NOT_NULL(message);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options meta_request_options = {\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .message = message,\\\\\\\\n        .send_filepath = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"obviously_invalid_file_path\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &meta_request_options);\\\\\\\\n    ASSERT_NULL(meta_request);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_ERROR_FILE_INVALID_PATH, aws_last_error());\\\\\\\\n\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that the parallel read stream failed to send read the second part. */\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_bad_parallel_read_stream, s_test_s3_put_fail_object_bad_parallel_read_stream)\\\\\\\\nstatic int s_test_s3_put_fail_object_bad_parallel_read_stream(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    /* Override the parallel input stream new function to create a bad parallel input stream */\\\\\\\\n    client->vtable->parallel_input_stream_new_from_file = aws_parallel_input_stream_new_from_file_failure_tester;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 100,\\\\\\\\n                .file_on_disk = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_UNIMPLEMENTED, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_single_part_fail_object_inputstream_fail_reading,\\\\\\\\n    s_test_s3_put_single_part_fail_object_inputstream_fail_reading)\\\\\\\\nstatic int s_test_s3_put_single_part_fail_object_inputstream_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n                .content_length = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_single_part_fail_object_inputstream_mismatch_content_length,\\\\\\\\n    s_test_s3_put_single_part_fail_object_inputstream_mismatch_content_length)\\\\\\\\nstatic int s_test_s3_put_single_part_fail_object_inputstream_mismatch_content_length(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .content_length = MB_TO_BYTES(2),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(meta_request_test_results.finished_error_code != AWS_ERROR_SUCCESS);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_fail_object_inputstream_fail_reading, s_test_s3_put_fail_object_inputstream_fail_reading)\\\\\\\\nstatic int s_test_s3_put_fail_object_inputstream_fail_reading(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = true,\\\\\\\\n                .invalid_input_stream = true,\\\\\\\\n                .content_length = 10 * 1024 * 1024,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_IO_STREAM_READ_FAILED, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_put_fail_object_inputstream_mismatch_content_length,\\\\\\\\n    s_test_s3_put_fail_object_inputstream_mismatch_content_length)\\\\\\\\nstatic int s_test_s3_put_fail_object_inputstream_mismatch_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .ensure_multipart = false,\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .content_length = 10 * 1024 * 1024,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &options, &meta_request_test_results));\\\\\\\\n\\\\\\\\n    ASSERT_UINT_EQUALS(AWS_ERROR_S3_INCORRECT_CONTENT_LENGTH, meta_request_test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_clamp_part_size, s_test_s3_put_object_clamp_part_size)\\\\\\\\nstatic int s_test_s3_put_object_clamp_part_size(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 64 * 1024,\\\\\\\\n        .max_part_size = 64 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client_config.part_size < g_s3_min_upload_part_size);\\\\\\\\n    ASSERT_TRUE(client_config.max_part_size < g_s3_min_upload_part_size);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    /* Upload should now succeed even when specifying a smaller than allowed part size. */\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(test_results.part_size == g_s3_min_upload_part_size);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_get_expected_user_agent(struct aws_allocator *allocator, struct aws_byte_buf *dest) {\\\\\\\\n    AWS_ASSERT(allocator);\\\\\\\\n    AWS_ASSERT(dest);\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor forward_slash = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/\\\\\\\\\\\\\");\\\\\\\\n    const struct aws_byte_cursor single_space = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\" \\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_init(dest, allocator, 32));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_product_name));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &forward_slash));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_s3_client_version));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &single_space));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_platform));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &forward_slash));\\\\\\\\n    ASSERT_SUCCESS(aws_byte_buf_append_dynamic(dest, &g_user_agent_header_unknown));\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_add_user_agent_header, s_test_add_user_agent_header)\\\\\\\\nstatic int s_test_add_user_agent_header(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor single_space = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\" \\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_buf expected_user_agent_value_buf;\\\\\\\\n    s_get_expected_user_agent(allocator, &expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor expected_user_agent_value = aws_byte_cursor_from_buf(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_byte_cursor user_agent_value;\\\\\\\\n        AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n\\\\\\\\n        struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n\\\\\\\\n        aws_s3_add_user_agent_header(allocator, message);\\\\\\\\n\\\\\\\\n        struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n\\\\\\\\n        ASSERT_TRUE(headers != NULL);\\\\\\\\n        ASSERT_SUCCESS(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value));\\\\\\\\n        ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n            user_agent_value.ptr, user_agent_value.len, expected_user_agent_value.ptr, expected_user_agent_value.len);\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        const struct aws_byte_cursor dummy_agent_header_value =\\\\\\\\n            AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"dummy_user_agent_product/dummy_user_agent_value\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        struct aws_byte_buf total_expected_user_agent_value_buf;\\\\\\\\n        aws_byte_buf_init(&total_expected_user_agent_value_buf, allocator, 64);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &dummy_agent_header_value);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &single_space);\\\\\\\\n        aws_byte_buf_append_dynamic(&total_expected_user_agent_value_buf, &expected_user_agent_value);\\\\\\\\n\\\\\\\\n        struct aws_byte_cursor total_expected_user_agent_value =\\\\\\\\n            aws_byte_cursor_from_buf(&total_expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n        struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n        struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n        ASSERT_TRUE(headers != NULL);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_http_headers_add(headers, g_user_agent_header_name, dummy_agent_header_value));\\\\\\\\n\\\\\\\\n        aws_s3_add_user_agent_header(allocator, message);\\\\\\\\n\\\\\\\\n        {\\\\\\\\n            struct aws_byte_cursor user_agent_value;\\\\\\\\n            AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n            ASSERT_SUCCESS(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value));\\\\\\\\n            ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n                user_agent_value.ptr,\\\\\\\\n                user_agent_value.len,\\\\\\\\n                total_expected_user_agent_value.ptr,\\\\\\\\n                total_expected_user_agent_value.len);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_byte_buf_clean_up(&total_expected_user_agent_value_buf);\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&expected_user_agent_value_buf);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic void s_s3_test_user_agent_meta_request_finished_request(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *results = meta_request->user_data;\\\\\\\\n    AWS_ASSERT(results != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = results->tester;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf expected_user_agent_value_buf;\\\\\\\\n    s_get_expected_user_agent(meta_request->allocator, &expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor expected_user_agent_value = aws_byte_cursor_from_buf(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = request->send_data.message;\\\\\\\\n    struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor user_agent_value;\\\\\\\\n    AWS_ZERO_STRUCT(user_agent_value);\\\\\\\\n\\\\\\\\n    AWS_FATAL_ASSERT(aws_http_headers_get(headers, g_user_agent_header_name, &user_agent_value) == AWS_OP_SUCCESS);\\\\\\\\n    AWS_FATAL_ASSERT(aws_byte_cursor_eq(&user_agent_value, &expected_user_agent_value));\\\\\\\\n    aws_byte_buf_clean_up(&expected_user_agent_value_buf);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *original_meta_request_vtable =\\\\\\\\n        aws_s3_tester_get_meta_request_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    original_meta_request_vtable->finished_request(meta_request, request, error_code);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_s3_meta_request *s_s3_meta_request_factory_override_finished_request(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    const struct aws_s3_meta_request_options *options) {\\\\\\\\n    AWS_ASSERT(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester *tester = client->shutdown_callback_user_data;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *original_client_vtable =\\\\\\\\n        aws_s3_tester_get_client_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = original_client_vtable->meta_request_factory(client, options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *patched_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(tester, meta_request, NULL);\\\\\\\\n    patched_meta_request_vtable->finished_request = s_s3_test_user_agent_meta_request_finished_request;\\\\\\\\n\\\\\\\\n    return meta_request;\\\\\\\\n}\\\\\\\\n\\\\\\\\nint s_s3_test_sending_user_agent_create_client(struct aws_s3_tester *tester, struct aws_s3_client **client) {\\\\\\\\n    AWS_ASSERT(tester);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(tester, &client_options, client));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(tester, *client, NULL);\\\\\\\\n    patched_client_vtable->meta_request_factory = s_s3_meta_request_factory_override_finished_request;\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_auto_ranged_get_sending_user_agent, s_test_s3_auto_ranged_get_sending_user_agent)\\\\\\\\nstatic int s_test_s3_auto_ranged_get_sending_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = g_pre_existing_object_1MB,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_auto_ranged_put_sending_user_agent, s_test_s3_auto_ranged_put_sending_user_agent)\\\\\\\\nstatic int s_test_s3_auto_ranged_put_sending_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .put_options =\\\\\\\\n                {\\\\\\\\n                    .ensure_multipart = true,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_sending_meta_request_user_agent, s_test_s3_default_sending_meta_request_user_agent)\\\\\\\\nstatic int s_test_s3_default_sending_meta_request_user_agent(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(s_s3_test_sending_user_agent_create_client(&tester, &client));\\\\\\\\n\\\\\\\\n    {\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .client = client,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .default_type_options =\\\\\\\\n                {\\\\\\\\n                    .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                    .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n                },\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = g_pre_existing_object_1MB,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct range_requests_test_user_data {\\\\\\\\n    struct aws_http_headers *headers;\\\\\\\\n    struct aws_byte_buf *body_buffer;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic int s_range_requests_headers_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_http_headers *headers,\\\\\\\\n    int response_status,\\\\\\\\n    void *user_data) {\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)response_status;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results = user_data;\\\\\\\\n    struct range_requests_test_user_data *test_user_data = test_results->tester->user_data;\\\\\\\\n\\\\\\\\n    if (test_user_data != NULL) {\\\\\\\\n        copy_http_headers(headers, test_user_data->headers);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_range_requests_receive_body_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)range_start;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results *test_results = user_data;\\\\\\\\n    struct range_requests_test_user_data *test_user_data = test_results->tester->user_data;\\\\\\\\n\\\\\\\\n    aws_byte_buf_append_dynamic(test_user_data->body_buffer, body);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_range_requests, s_test_s3_range_requests)\\\\\\\\nstatic int s_test_s3_range_requests(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor object_names[] = {\\\\\\\\n        g_pre_existing_object_1MB,\\\\\\\\n        g_pre_existing_object_kms_10MB,\\\\\\\\n        g_pre_existing_object_aes256_10MB,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    enum aws_s3_tester_sse_type object_sse_types[] = {\\\\\\\\n        AWS_S3_TESTER_SSE_NONE,\\\\\\\\n        AWS_S3_TESTER_SSE_KMS,\\\\\\\\n        AWS_S3_TESTER_SSE_AES256,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    const struct aws_byte_cursor ranges[] = {\\\\\\\\n        // No range at all.\\\\\\\\n        {0, NULL},\\\\\\\\n\\\\\\\\n        // Single byte range.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=8-8\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Single byte range (first byte).\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-0\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // First 8K.  8K < client\\'s 16K part size.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-8191\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // First 0.5 MB.  0.5 MB < 1 MB test file.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-524287\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // 0.5 MB - 2 MB range.  This overlaps and goes beyond the 1 MB test file size.\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=524288-2097151\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Get everything after the first 0.5 MB\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=524288-\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Last 0.5 MB\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=-524288\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Everything after first 8K\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=8192-\\\\\\\\\\\\\"),\\\\\\\\n\\\\\\\\n        // Last 8K\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=-8192\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* List of headers that should have matching values between the auto_ranged_get and default (which sends the HTTP\\\\\\\\n     * request as-is to S3) meta request.*/\\\\\\\\n    const struct aws_byte_cursor headers_that_should_match[] = {\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"ETag\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Accept-Ranges\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Range\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Type\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Content-Length\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Server\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"x-amz-server-side-encryption\\\\\\\\\\\\\"),\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"x-amz-server-side-encryption-aws-kms-key\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /* List of headers that are okay to be in the auto_ranged_get response and not in the default response, or vice\\\\\\\\n     * versa.*/\\\\\\\\n    const struct aws_byte_cursor headers_to_ignore[] = {\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"Connection\\\\\\\\\\\\\"),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    const size_t num_object_names = AWS_ARRAY_SIZE(object_names);\\\\\\\\n    const size_t num_ranges = AWS_ARRAY_SIZE(ranges);\\\\\\\\n\\\\\\\\n    for (size_t object_name_index = 0; object_name_index < num_object_names; ++object_name_index) {\\\\\\\\n        for (size_t range_index = 0; range_index < num_ranges; ++range_index) {\\\\\\\\n\\\\\\\\n            AWS_LOGF_INFO(\\\\\\\\n                AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Testing object name %d and range %d\\\\\\\\\\\\\", (int)object_name_index, (int)range_index);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf range_get_buffer;\\\\\\\\n            aws_byte_buf_init(&range_get_buffer, allocator, 256);\\\\\\\\n            struct aws_http_headers *range_get_headers = aws_http_headers_new(allocator);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf verify_range_get_buffer;\\\\\\\\n            aws_byte_buf_init(&verify_range_get_buffer, allocator, 256);\\\\\\\\n            struct aws_http_headers *verify_range_get_headers = aws_http_headers_new(allocator);\\\\\\\\n\\\\\\\\n            struct aws_s3_tester_meta_request_options options = {\\\\\\\\n                .allocator = allocator,\\\\\\\\n                .client = client,\\\\\\\\n                .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n                .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n                .headers_callback = s_range_requests_headers_callback,\\\\\\\\n                .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n                .get_options =\\\\\\\\n                    {\\\\\\\\n                        .object_path = object_names[object_name_index],\\\\\\\\n                        .object_range = ranges[range_index],\\\\\\\\n                    },\\\\\\\\n                .sse_type = object_sse_types[object_name_index],\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            {\\\\\\\\n                struct range_requests_test_user_data test_user_data = {\\\\\\\\n                    .headers = range_get_headers,\\\\\\\\n                    .body_buffer = &range_get_buffer,\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                tester.user_data = &test_user_data;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, NULL));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            /* Send a default meta request (which just pushes the request directly to S3) with the same options to\\\\\\\\n             * verify the format of each request. */\\\\\\\\n            struct aws_s3_tester_meta_request_options verify_options = {\\\\\\\\n                .allocator = allocator,\\\\\\\\n                .client = client,\\\\\\\\n                .meta_request_type = AWS_S3_META_REQUEST_TYPE_DEFAULT,\\\\\\\\n                .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n                .headers_callback = s_range_requests_headers_callback,\\\\\\\\n                .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n                .default_type_options =\\\\\\\\n                    {\\\\\\\\n                        .mode = AWS_S3_TESTER_DEFAULT_TYPE_MODE_GET,\\\\\\\\n                        .operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"),\\\\\\\\n                    },\\\\\\\\n                .get_options =\\\\\\\\n                    {\\\\\\\\n                        .object_path = object_names[object_name_index],\\\\\\\\n                        .object_range = ranges[range_index],\\\\\\\\n                    },\\\\\\\\n                .sse_type = object_sse_types[object_name_index],\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            {\\\\\\\\n                struct range_requests_test_user_data test_user_data = {\\\\\\\\n                    .headers = verify_range_get_headers,\\\\\\\\n                    .body_buffer = &verify_range_get_buffer,\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                tester.user_data = &test_user_data;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &verify_options, NULL));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            /* Compare headers. */\\\\\\\\n            for (size_t i = 0; i < aws_http_headers_count(verify_range_get_headers); ++i) {\\\\\\\\n                struct aws_http_header verify_header;\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get_index(verify_range_get_headers, i, &verify_header));\\\\\\\\n\\\\\\\\n                bool ignore_header = false;\\\\\\\\n\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_to_ignore); ++j) {\\\\\\\\n                    if (aws_byte_cursor_eq_ignore_case(&headers_to_ignore[j], &verify_header.name)) {\\\\\\\\n                        ignore_header = true;\\\\\\\\n                        break;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                if (ignore_header) {\\\\\\\\n                    aws_http_headers_erase(range_get_headers, verify_header.name);\\\\\\\\n                    continue;\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                AWS_LOGF_INFO(\\\\\\\\n                    AWS_LS_S3_GENERAL,\\\\\\\\n                    \\\\\\\\\\\\\"%d,%d Checking for header \\\\\\\\\\\\\" PRInSTR,\\\\\\\\n                    (int)object_name_index,\\\\\\\\n                    (int)range_index,\\\\\\\\n                    AWS_BYTE_CURSOR_PRI(verify_header.name));\\\\\\\\n\\\\\\\\n                struct aws_byte_cursor header_value;\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get(range_get_headers, verify_header.name, &header_value));\\\\\\\\n\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_that_should_match); ++j) {\\\\\\\\n                    if (!aws_byte_cursor_eq_ignore_case(&headers_that_should_match[j], &verify_header.name)) {\\\\\\\\n                        continue;\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    AWS_LOGF_INFO(\\\\\\\\n                        AWS_LS_S3_GENERAL,\\\\\\\\n                        \\\\\\\\\\\\\"%d,%d Header Contents \\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\" vs \\\\\\\\\\\\\" PRInSTR,\\\\\\\\n                        (int)object_name_index,\\\\\\\\n                        (int)range_index,\\\\\\\\n                        AWS_BYTE_CURSOR_PRI(verify_header.value),\\\\\\\\n                        AWS_BYTE_CURSOR_PRI(header_value));\\\\\\\\n\\\\\\\\n                    ASSERT_TRUE(aws_byte_cursor_eq(&verify_header.value, &header_value));\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_erase(range_get_headers, verify_header.name));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            for (size_t i = 0; i < aws_http_headers_count(range_get_headers); ++i) {\\\\\\\\n                struct aws_http_header header;\\\\\\\\n\\\\\\\\n                ASSERT_SUCCESS(aws_http_headers_get_index(range_get_headers, i, &header));\\\\\\\\n                bool ignore_header = false;\\\\\\\\n\\\\\\\\n                /* If the ignore header doesn\\'t exist in the verify_range_get_headers, ignore it here. */\\\\\\\\n                for (size_t j = 0; j < AWS_ARRAY_SIZE(headers_to_ignore); ++j) {\\\\\\\\n                    if (aws_byte_cursor_eq_ignore_case(&headers_to_ignore[j], &header.name)) {\\\\\\\\n                        ignore_header = true;\\\\\\\\n                        break;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                if (ignore_header) {\\\\\\\\n                    ASSERT_SUCCESS(aws_http_headers_erase(range_get_headers, header.name));\\\\\\\\n                    continue;\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                AWS_LOGF_INFO(AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Left over header: \\\\\\\\\\\\\" PRInSTR, AWS_BYTE_CURSOR_PRI(header.name));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            ASSERT_TRUE(aws_http_headers_count(range_get_headers) == 0);\\\\\\\\n\\\\\\\\n            /* Compare Body Contents */\\\\\\\\n            ASSERT_TRUE(aws_byte_buf_eq(&range_get_buffer, &verify_range_get_buffer));\\\\\\\\n\\\\\\\\n            aws_http_headers_release(range_get_headers);\\\\\\\\n            aws_byte_buf_clean_up(&range_get_buffer);\\\\\\\\n\\\\\\\\n            aws_http_headers_release(verify_range_get_headers);\\\\\\\\n            aws_byte_buf_clean_up(&verify_range_get_buffer);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_not_satisfiable_range, s_test_s3_not_satisfiable_range)\\\\\\\\nstatic int s_test_s3_not_satisfiable_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .headers_callback = s_range_requests_headers_callback,\\\\\\\\n        .body_callback = s_range_requests_receive_body_callback,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=2097151-\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_416_REQUESTED_RANGE_NOT_SATISFIABLE, results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_invalid_start_range_greator_than_end_range, s_test_s3_invalid_start_range_greator_than_end_range)\\\\\\\\nstatic int s_test_s3_invalid_start_range_greator_than_end_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=20-10\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n    ASSERT_INT_EQUALS(results.finished_error_code, AWS_ERROR_S3_INVALID_RANGE_HEADER);\\\\\\\\n    ASSERT_INT_EQUALS(0, tester.synced_data.meta_request_finish_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_invalid_empty_file_with_range, s_test_s3_invalid_empty_file_with_range)\\\\\\\\nstatic int s_test_s3_invalid_empty_file_with_range(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = 16 * 1024,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_empty_object,\\\\\\\\n                .object_range = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"bytes=0-0\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &results));\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_416_REQUESTED_RANGE_NOT_SATISFIABLE, results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(aws_string_eq_c_str(results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_copy_object_helper(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor source_key,\\\\\\\\n    struct aws_byte_cursor destination_key,\\\\\\\\n    int expected_error_code,\\\\\\\\n    int expected_response_status,\\\\\\\\n    uint64_t expected_size) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    struct aws_byte_buf encoded_path;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n    AWS_ZERO_STRUCT(encoded_path);\\\\\\\\n\\\\\\\\n    aws_byte_buf_init(&encoded_path, allocator, source_key.len);\\\\\\\\n    aws_byte_buf_append_encoding_uri_path(&encoded_path, &source_key);\\\\\\\\n\\\\\\\\n    /* without copy_source_uri */\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    /* with path style copy_source_uri */\\\\\\\\n    char source_url[1024];\\\\\\\\n    snprintf(\\\\\\\\n        source_url,\\\\\\\\n        sizeof(source_url),\\\\\\\\n        \\\\\\\\\\\\\"https://s3.%s.amazonaws.com/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"\\\\\\\\\\\\\",\\\\\\\\n        g_test_s3_region.ptr,\\\\\\\\n        AWS_BYTE_CURSOR_PRI(source_bucket),\\\\\\\\n        AWS_BYTE_BUF_PRI(encoded_path));\\\\\\\\n    copy_source_uri = aws_byte_cursor_from_c_str(source_url);\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    /* with virtual style copy_source_uri */\\\\\\\\n    snprintf(\\\\\\\\n        source_url,\\\\\\\\n        sizeof(source_url),\\\\\\\\n        \\\\\\\\\\\\\"https://\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\".s3.%s.amazonaws.com/\\\\\\\\\\\\\" PRInSTR \\\\\\\\\\\\\"\\\\\\\\\\\\\",\\\\\\\\n        AWS_BYTE_CURSOR_PRI(source_bucket),\\\\\\\\n        g_test_s3_region.ptr,\\\\\\\\n        AWS_BYTE_BUF_PRI(encoded_path));\\\\\\\\n    copy_source_uri = aws_byte_cursor_from_c_str(source_url);\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        source_bucket,\\\\\\\\n        source_key,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        expected_error_code,\\\\\\\\n        expected_response_status,\\\\\\\\n        expected_size,\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    aws_byte_buf_clean_up(&encoded_path);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_small_object, s_test_s3_copy_small_object)\\\\\\\\nstatic int s_test_s3_copy_small_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, MB_TO_BYTES(1));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_small_object_special_char, s_test_s3_copy_small_object_special_char)\\\\\\\\nstatic int s_test_s3_copy_small_object_special_char(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB-@\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB_@\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, MB_TO_BYTES(1));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_copy_large_object_special_char, s_test_s3_multipart_copy_large_object_special_char)\\\\\\\\nstatic int s_test_s3_multipart_copy_large_object_special_char(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-2GB-@\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_2GB-@\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, GB_TO_BYTES(2));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_multipart_copy_large_object, s_test_s3_multipart_copy_large_object)\\\\\\\\nstatic int s_test_s3_multipart_copy_large_object(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-2GB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_2GB\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator, source_key, destination_key, AWS_ERROR_SUCCESS, AWS_HTTP_STATUS_CODE_200_OK, GB_TO_BYTES(2));\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_object_invalid_source_key, s_test_s3_copy_object_invalid_source_key)\\\\\\\\nstatic int s_test_s3_copy_object_invalid_source_key(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"__INVALID__\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/__INVALID__\\\\\\\\\\\\\");\\\\\\\\n    return s_test_s3_copy_object_helper(\\\\\\\\n        allocator,\\\\\\\\n        source_key,\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_S3_INVALID_RESPONSE_STATUS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_404_NOT_FOUND,\\\\\\\\n        0 /* expected_size is ignored */);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test a bypass Copy Object meta request using a slash prefix in the x_amz_copy_source header.\\\\\\\\n * S3 supports both bucket/key and /bucket/key\\\\\\\\n * This test validates the fix for the bug described in https://sim.amazon.com/issues/AWSCRT-730\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_copy_source_prefixed_by_slash, s_test_s3_copy_source_prefixed_by_slash)\\\\\\\\nstatic int s_test_s3_copy_source_prefixed_by_slash(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK,\\\\\\\\n        MB_TO_BYTES(1),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_copy_invalid_source_uri, s_test_s3_copy_invalid_source_uri)\\\\\\\\nstatic int s_test_s3_copy_invalid_source_uri(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-1MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_1MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"http://invalid-uri.com:80:80/path\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_MALFORMED_INPUT_STRING,\\\\\\\\n        0,\\\\\\\\n        MB_TO_BYTES(1),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Test multipart Copy Object meta request using a slash prefix in the x_amz_copy_source header.\\\\\\\\n * S3 supports both bucket/key and /bucket/key\\\\\\\\n * This test validates the fix for the bug described in https://sim.amazon.com/issues/AWSCRT-730\\\\\\\\n */\\\\\\\\nAWS_TEST_CASE(test_s3_copy_source_prefixed_by_slash_multipart, s_test_s3_copy_source_prefixed_by_slash_multipart)\\\\\\\\nstatic int s_test_s3_copy_source_prefixed_by_slash_multipart(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"pre-existing-256MB\\\\\\\\\\\\\");\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"copies/destination_256MB\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor source_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char copy_source_value[1024];\\\\\\\\n    snprintf(\\\\\\\\n        copy_source_value,\\\\\\\\n        sizeof(copy_source_value),\\\\\\\\n        \\\\\\\\\\\\\"/%.*s/%.*s\\\\\\\\\\\\\",\\\\\\\\n        (int)source_bucket.len,\\\\\\\\n        source_bucket.ptr,\\\\\\\\n        (int)source_key.len,\\\\\\\\n        source_key.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor x_amz_copy_source = aws_byte_cursor_from_c_str(copy_source_value);\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor copy_source_uri;\\\\\\\\n    AWS_ZERO_STRUCT(copy_source_uri);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_test_s3_copy_object_from_x_amz_copy_source(\\\\\\\\n        allocator,\\\\\\\\n        &tester,\\\\\\\\n        x_amz_copy_source,\\\\\\\\n        aws_byte_cursor_from_c_str(endpoint),\\\\\\\\n        destination_key,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK,\\\\\\\\n        MB_TO_BYTES(256),\\\\\\\\n        false,\\\\\\\\n        copy_source_uri));\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_get_object_mrap_helper(struct aws_allocator *allocator, bool multipart) {\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_signing_config_aws signing_config = tester.default_signing_config;\\\\\\\\n    /* Use Sigv4A for signing */\\\\\\\\n    signing_config.algorithm = AWS_SIGNING_ALGORITHM_V4_ASYMMETRIC;\\\\\\\\n    /* Use * for region to sign */\\\\\\\\n    signing_config.region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = multipart ? 64 * 1024 : 20 * 1024 * 1024,\\\\\\\\n        .region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\"),\\\\\\\\n        .signing_config = &signing_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0 /*flag*/));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .mrap_test = true,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = g_pre_existing_object_1MB,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test single-part get object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_less_than_part_size_mrap, s_test_s3_get_object_less_than_part_size_mrap)\\\\\\\\nstatic int s_test_s3_get_object_less_than_part_size_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_get_object_mrap_helper(allocator, false /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test multi-part get object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_get_object_multipart_mrap, s_test_s3_get_object_multipart_mrap)\\\\\\\\nstatic int s_test_s3_get_object_multipart_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_get_object_mrap_helper(allocator, true /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_s3_put_object_mrap_helper(struct aws_allocator *allocator, bool multipart) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_signing_config_aws signing_config = tester.default_signing_config;\\\\\\\\n    /* Use Sigv4A for signing */\\\\\\\\n    signing_config.algorithm = AWS_SIGNING_ALGORITHM_V4_ASYMMETRIC;\\\\\\\\n    /* Use * for region to sign */\\\\\\\\n    signing_config.region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config = {\\\\\\\\n        .part_size = 5 * 1024 * 1024,\\\\\\\\n        .region = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"*\\\\\\\\\\\\\"),\\\\\\\\n        .signing_config = &signing_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(&tester, &client_config, 0 /*flag*/));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(client != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .mrap_test = true,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = multipart ? 10 : 1,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &options, &meta_request_test_results));\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test single-part put object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_less_than_part_size_mrap, s_test_s3_put_object_less_than_part_size_mrap)\\\\\\\\nstatic int s_test_s3_put_object_less_than_part_size_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_put_object_mrap_helper(allocator, false /*multipart*/);\\\\\\\\n}\\\\\\\\n/* Test multi-part put object through MRAP (multi-region access point) */\\\\\\\\nAWS_TEST_CASE(test_s3_put_object_multipart_mrap, s_test_s3_put_object_multipart_mrap)\\\\\\\\nstatic int s_test_s3_put_object_multipart_mrap(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    return s_s3_put_object_mrap_helper(allocator, true /*multipart*/);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_http_message *s_put_object_request_new(\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    struct aws_byte_cursor key,\\\\\\\\n    struct aws_byte_cursor endpoint,\\\\\\\\n    struct aws_input_stream *body_stream,\\\\\\\\n    uint64_t content_length) {\\\\\\\\n\\\\\\\\n    AWS_PRECONDITION(allocator);\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = aws_http_message_new_request(allocator);\\\\\\\\n\\\\\\\\n    if (message == NULL) {\\\\\\\\n        return NULL;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if (aws_http_message_set_request_path(message, key)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_http_header host_header = {\\\\\\\\n        .name = g_host_header_name,\\\\\\\\n        .value = endpoint,\\\\\\\\n    };\\\\\\\\n    if (aws_http_message_add_header(message, host_header)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    char content_length_c_str[1024];\\\\\\\\n    snprintf(content_length_c_str, sizeof(content_length_c_str), \\\\\\\\\\\\\"%\\\\\\\\\\\\\" PRIu64, content_length);\\\\\\\\n\\\\\\\\n    struct aws_http_header content_length_header = {\\\\\\\\n        .name = g_content_length_header_name,\\\\\\\\n        .value = aws_byte_cursor_from_c_str(content_length_c_str),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    if (aws_http_message_add_header(message, content_length_header)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if (aws_http_message_set_request_method(message, aws_http_method_put)) {\\\\\\\\n        goto error_clean_up_message;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_http_message_set_body_stream(message, body_stream);\\\\\\\\n\\\\\\\\n    return message;\\\\\\\\n\\\\\\\\nerror_clean_up_message:\\\\\\\\n\\\\\\\\n    if (message != NULL) {\\\\\\\\n        aws_http_message_release(message);\\\\\\\\n        message = NULL;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return NULL;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct put_object_pause_resume_test_data {\\\\\\\\n    struct aws_mutex mutex;\\\\\\\\n    struct aws_condition_variable c_var;\\\\\\\\n\\\\\\\\n    /* execution of the test meta request completed */\\\\\\\\n    bool execution_completed;\\\\\\\\n\\\\\\\\n    /* accumulator of amount of bytes uploaded */\\\\\\\\n    struct aws_atomic_var total_bytes_uploaded;\\\\\\\\n\\\\\\\\n    /* the offset where upload should be paused */\\\\\\\\n    struct aws_atomic_var request_pause_offset;\\\\\\\\n\\\\\\\\n    struct aws_atomic_var pause_requested;\\\\\\\\n\\\\\\\\n    struct aws_atomic_var pause_result;\\\\\\\\n\\\\\\\\n    /* the persistable state of the paused request */\\\\\\\\n    struct aws_atomic_var persistable_state_ptr;\\\\\\\\n\\\\\\\\n    int meta_request_error_code;\\\\\\\\n    int response_status_code;\\\\\\\\n\\\\\\\\n    /* (Optional) content_length to send. If not set, use the length of the input stream. */\\\\\\\\n    uint64_t content_length;\\\\\\\\n};\\\\\\\\n\\\\\\\\nstatic void s_put_pause_resume_meta_request_finish(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_meta_request_result *meta_request_result,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    struct aws_s3_tester *tester = user_data;\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = tester->user_data;\\\\\\\\n\\\\\\\\n    /* if error response body is available, dump it to test result to help investigation of failed tests */\\\\\\\\n    if (meta_request_result->error_response_body != NULL && meta_request_result->error_response_body->len > 0) {\\\\\\\\n        AWS_LOGF_ERROR(\\\\\\\\n            AWS_LS_S3_GENERAL,\\\\\\\\n            \\\\\\\\\\\\\"Response error body: %.*s\\\\\\\\\\\\\",\\\\\\\\n            (int)meta_request_result->error_response_body->len,\\\\\\\\n            meta_request_result->error_response_body->buffer);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_mutex_lock(&test_data->mutex);\\\\\\\\n    test_data->meta_request_error_code = meta_request_result->error_code;\\\\\\\\n    test_data->response_status_code = meta_request_result->response_status;\\\\\\\\n    test_data->execution_completed = true;\\\\\\\\n    aws_mutex_unlock(&test_data->mutex);\\\\\\\\n    aws_condition_variable_notify_one(&test_data->c_var);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic bool s_put_pause_resume_test_completion_predicate(void *arg) {\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = arg;\\\\\\\\n    return test_data->execution_completed;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Patched version of aws_s3_meta_request_vtable->finished_request() for pause/resume tests.\\\\\\\\n * It can pause the meta-request immediately after a part completes.\\\\\\\\n * We use a patched vtable, instead of the progress_callback, because\\\\\\\\n * the progress_callback fires on another thread, which might be too late to\\\\\\\\n * prevent more parts from being sent. */\\\\\\\\nstatic void s_meta_request_finished_request_patched_for_pause_resume_tests(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    struct aws_s3_request *request,\\\\\\\\n    int error_code) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(meta_request);\\\\\\\\n    struct aws_s3_tester *tester = meta_request->user_data;\\\\\\\\n    struct put_object_pause_resume_test_data *test_data = tester->user_data;\\\\\\\\n    AWS_ASSERT(test_data);\\\\\\\\n\\\\\\\\n    if ((error_code == AWS_ERROR_SUCCESS) && (meta_request->type == AWS_S3_META_REQUEST_TYPE_PUT_OBJECT) &&\\\\\\\\n        (request->request_tag == AWS_S3_AUTO_RANGED_PUT_REQUEST_TAG_PART)) {\\\\\\\\n\\\\\\\\n        if (!request->is_noop) {\\\\\\\\n            /* If the request is noop, we are not really uploading the part */\\\\\\\\n            aws_atomic_fetch_add(&test_data->total_bytes_uploaded, request->request_body.len);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        size_t total_bytes_uploaded = aws_atomic_load_int(&test_data->total_bytes_uploaded);\\\\\\\\n        uint64_t offset_to_pause = aws_atomic_load_int(&test_data->request_pause_offset);\\\\\\\\n\\\\\\\\n        if (total_bytes_uploaded >= offset_to_pause) {\\\\\\\\n            /* offset of the upload at which we should pause was reached. let\\'s pause the upload */\\\\\\\\n            /* if the meta request has already been paused previously, do nothing. */\\\\\\\\n            size_t expected = false;\\\\\\\\n            bool request_pause = aws_atomic_compare_exchange_int(&test_data->pause_requested, &expected, true);\\\\\\\\n            if (request_pause) {\\\\\\\\n                struct aws_s3_meta_request_resume_token *resume_token = NULL;\\\\\\\\n                int pause_result = aws_s3_meta_request_pause(meta_request, &resume_token);\\\\\\\\n                struct aws_byte_cursor upload_id = aws_s3_meta_request_resume_token_upload_id(resume_token);\\\\\\\\n                /* Make Sure we have upload ID */\\\\\\\\n                AWS_FATAL_ASSERT(aws_byte_cursor_eq_c_str(&upload_id, \\\\\\\\\\\\\"\\\\\\\\\\\\\") == false);\\\\\\\\n                aws_atomic_store_int(&test_data->pause_result, pause_result);\\\\\\\\n                aws_atomic_store_ptr(&test_data->persistable_state_ptr, resume_token);\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /* Continue with original vtable function... */\\\\\\\\n    struct aws_s3_meta_request_vtable *original_meta_request_vtable =\\\\\\\\n        aws_s3_tester_get_meta_request_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    original_meta_request_vtable->finished_request(meta_request, request, error_code);\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_s3_meta_request *s_meta_request_factory_patch_for_pause_resume_tests(\\\\\\\\n    struct aws_s3_client *client,\\\\\\\\n    const struct aws_s3_meta_request_options *options) {\\\\\\\\n\\\\\\\\n    AWS_ASSERT(client != NULL);\\\\\\\\n    struct aws_s3_tester *tester = client->shutdown_callback_user_data;\\\\\\\\n    AWS_ASSERT(tester != NULL);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *original_client_vtable =\\\\\\\\n        aws_s3_tester_get_client_vtable_patch(tester, 0)->original_vtable;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = original_client_vtable->meta_request_factory(client, options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_vtable *patched_meta_request_vtable =\\\\\\\\n        aws_s3_tester_patch_meta_request_vtable(tester, meta_request, NULL);\\\\\\\\n    patched_meta_request_vtable->finished_request = s_meta_request_finished_request_patched_for_pause_resume_tests;\\\\\\\\n\\\\\\\\n    return meta_request;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* total length of the object to simulate for upload */\\\\\\\\nstatic const size_t s_pause_resume_object_length_128MB = 128 * 1024 * 1024;\\\\\\\\n\\\\\\\\n/* this runs when a RESUMED upload is about to successfully complete */\\\\\\\\nstatic int s_pause_resume_upload_review_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_upload_review *review,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)user_data;\\\\\\\\n    struct aws_allocator *allocator = meta_request->allocator;\\\\\\\\n\\\\\\\\n    /* A bit hacky, but stream the same data that the test always uploads, and ensure the checksums match */\\\\\\\\n\\\\\\\\n    struct aws_input_stream *reread_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    for (size_t part_index = 0; part_index < review->part_count; ++part_index) {\\\\\\\\n        const struct aws_s3_upload_part_review *part_review = &review->part_array[part_index];\\\\\\\\n        struct aws_byte_buf reread_part_buf;\\\\\\\\n        ASSERT_TRUE(part_review->size <= SIZE_MAX);\\\\\\\\n        aws_byte_buf_init(&reread_part_buf, allocator, (size_t)part_review->size);\\\\\\\\n        ASSERT_SUCCESS(aws_input_stream_read(reread_stream, &reread_part_buf));\\\\\\\\n\\\\\\\\n        /* part sizes should match */\\\\\\\\n        ASSERT_UINT_EQUALS(part_review->size, reread_part_buf.len);\\\\\\\\n\\\\\\\\n        if (review->checksum_algorithm != AWS_SCA_NONE) {\\\\\\\\n            struct aws_byte_cursor reread_part_cursor = aws_byte_cursor_from_buf(&reread_part_buf);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf checksum_buf;\\\\\\\\n            aws_byte_buf_init(&checksum_buf, allocator, 128);\\\\\\\\n            ASSERT_SUCCESS(\\\\\\\\n                aws_checksum_compute(allocator, review->checksum_algorithm, &reread_part_cursor, &checksum_buf));\\\\\\\\n            struct aws_byte_cursor checksum_cursor = aws_byte_cursor_from_buf(&checksum_buf);\\\\\\\\n\\\\\\\\n            struct aws_byte_buf encoded_checksum_buf;\\\\\\\\n            aws_byte_buf_init(&encoded_checksum_buf, allocator, 128);\\\\\\\\n\\\\\\\\n            ASSERT_SUCCESS(aws_base64_encode(&checksum_cursor, &encoded_checksum_buf));\\\\\\\\n\\\\\\\\n            /* part checksums should match */\\\\\\\\n            ASSERT_BIN_ARRAYS_EQUALS(\\\\\\\\n                encoded_checksum_buf.buffer,\\\\\\\\n                encoded_checksum_buf.len,\\\\\\\\n                part_review->checksum.ptr,\\\\\\\\n                part_review->checksum.len);\\\\\\\\n\\\\\\\\n            aws_byte_buf_clean_up(&checksum_buf);\\\\\\\\n            aws_byte_buf_clean_up(&encoded_checksum_buf);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        aws_byte_buf_clean_up(&reread_part_buf);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    aws_input_stream_release(reread_stream);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_pause_resume_receive_body_callback(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_byte_cursor *body,\\\\\\\\n    uint64_t range_start,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)range_start;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    // TODO: this is a bit hacky, as it will try to compare every partial get result we receive to the input stream.\\\\\\\\n    // Something better?\\\\\\\\n\\\\\\\\n    struct aws_input_stream *input_stream =\\\\\\\\n        aws_s3_test_input_stream_new(meta_request->allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    struct aws_byte_buf buf;\\\\\\\\n    aws_byte_buf_init(&buf, meta_request->allocator, (size_t)range_start);\\\\\\\\n    aws_input_stream_read(input_stream, &buf);\\\\\\\\n\\\\\\\\n    aws_byte_buf_clean_up(&buf);\\\\\\\\n    aws_byte_buf_init(&buf, meta_request->allocator, body->len);\\\\\\\\n    aws_input_stream_read(input_stream, &buf);\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor input_cur = aws_byte_cursor_from_buf(&buf);\\\\\\\\n\\\\\\\\n    bool body_matches_expected = aws_byte_cursor_eq(&input_cur, body);\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(input_stream);\\\\\\\\n    aws_byte_buf_clean_up(&buf);\\\\\\\\n\\\\\\\\n    ASSERT_TRUE(body_matches_expected);\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_test_s3_put_pause_resume_helper(\\\\\\\\n    struct aws_s3_tester *tester,\\\\\\\\n    struct aws_allocator *allocator,\\\\\\\\n    void *ctx,\\\\\\\\n    struct put_object_pause_resume_test_data *test_data,\\\\\\\\n    struct aws_byte_cursor destination_key,\\\\\\\\n    struct aws_input_stream *upload_body_stream,\\\\\\\\n    struct aws_s3_meta_request_resume_token *resume_state,\\\\\\\\n    enum aws_s3_checksum_algorithm checksum_algorithm,\\\\\\\\n    int expected_error_code,\\\\\\\\n    int expected_response_status) {\\\\\\\\n\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n\\\\\\\\n    if (resume_state == NULL) {\\\\\\\\n        /* If we\\'re going to cancel this operation, limit the client to 1 HTTP connection.\\\\\\\\n         * That way, we don\\'t end up \\\\\\\\\\\\\"cancelling\\\\\\\\\\\\\" but all the parts actually\\\\\\\\n         * succeed anyway on other connections */\\\\\\\\n        client_config.max_active_connections_override = 1;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(tester, client, NULL);\\\\\\\\n    patched_client_vtable->meta_request_factory = s_meta_request_factory_patch_for_pause_resume_tests;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_bucket = g_test_bucket_name;\\\\\\\\n\\\\\\\\n    char endpoint[1024];\\\\\\\\n    snprintf(\\\\\\\\n        endpoint,\\\\\\\\n        sizeof(endpoint),\\\\\\\\n        \\\\\\\\\\\\\"%.*s.s3.%s.amazonaws.com\\\\\\\\\\\\\",\\\\\\\\n        (int)destination_bucket.len,\\\\\\\\n        destination_bucket.ptr,\\\\\\\\n        g_test_s3_region.ptr);\\\\\\\\n\\\\\\\\n    /* creates a PutObject request */\\\\\\\\n    int64_t content_length = test_data->content_length;\\\\\\\\n    if (content_length == 0) {\\\\\\\\n        /* If not set, use the length of the input stream */\\\\\\\\n        aws_input_stream_get_length(upload_body_stream, &content_length);\\\\\\\\n    }\\\\\\\\n    struct aws_http_message *message = s_put_object_request_new(\\\\\\\\n        allocator, destination_key, aws_byte_cursor_from_c_str(endpoint), upload_body_stream, content_length);\\\\\\\\n\\\\\\\\n    test_data->c_var = (struct aws_condition_variable)AWS_CONDITION_VARIABLE_INIT;\\\\\\\\n    aws_mutex_init(&test_data->mutex);\\\\\\\\n    test_data->execution_completed = false;\\\\\\\\n\\\\\\\\n    tester->user_data = test_data;\\\\\\\\n\\\\\\\\n    struct aws_s3_checksum_config checksum_config = {\\\\\\\\n        .checksum_algorithm = checksum_algorithm,\\\\\\\\n        .location = checksum_algorithm == AWS_SCA_NONE ? AWS_SCL_NONE : AWS_SCL_TRAILER,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options meta_request_options = {\\\\\\\\n        .user_data = tester,\\\\\\\\n        .body_callback = NULL,\\\\\\\\n        .signing_config = client_config.signing_config,\\\\\\\\n        .finish_callback = s_put_pause_resume_meta_request_finish,\\\\\\\\n        .headers_callback = NULL,\\\\\\\\n        .upload_review_callback = s_pause_resume_upload_review_callback,\\\\\\\\n        .message = message,\\\\\\\\n        .shutdown_callback = NULL,\\\\\\\\n        .resume_token = NULL,\\\\\\\\n        .type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_config = &checksum_config,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    if (resume_state) {\\\\\\\\n        meta_request_options.resume_token = resume_state;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request *meta_request = aws_s3_client_make_meta_request(client, &meta_request_options);\\\\\\\\n    ASSERT_NOT_NULL(meta_request);\\\\\\\\n\\\\\\\\n    /* wait completion of the meta request */\\\\\\\\n    aws_mutex_lock(&test_data->mutex);\\\\\\\\n    aws_condition_variable_wait_pred(\\\\\\\\n        &test_data->c_var, &test_data->mutex, s_put_pause_resume_test_completion_predicate, test_data);\\\\\\\\n    aws_mutex_unlock(&test_data->mutex);\\\\\\\\n\\\\\\\\n    /* assert error_code and response_status_code */\\\\\\\\n    ASSERT_INT_EQUALS(expected_error_code, test_data->meta_request_error_code);\\\\\\\\n    ASSERT_INT_EQUALS(expected_response_status, test_data->response_status_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_release(meta_request);\\\\\\\\n    aws_mutex_clean_up(&test_data->mutex);\\\\\\\\n    aws_http_message_destroy(message);\\\\\\\\n\\\\\\\\n    /* release this client with its crazy patched vtables */\\\\\\\\n    client = aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_wait_for_client_shutdown(tester);\\\\\\\\n    tester->bound_to_client = false;\\\\\\\\n\\\\\\\\n    if (expected_error_code == AWS_ERROR_SUCCESS) {\\\\\\\\n        /* get the file and verify it matches what we uploaded */\\\\\\\\n        struct aws_s3_tester_meta_request_options options = {\\\\\\\\n            .allocator = allocator,\\\\\\\\n            .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n            .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n            .body_callback = s_pause_resume_receive_body_callback,\\\\\\\\n            .get_options =\\\\\\\\n                {\\\\\\\\n                    .object_path = destination_key,\\\\\\\\n                },\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        struct aws_s3_meta_request_test_results results;\\\\\\\\n        aws_s3_meta_request_test_results_init(&results, allocator);\\\\\\\\n\\\\\\\\n        ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(tester, &options, &results));\\\\\\\\n        aws_s3_meta_request_test_results_clean_up(&results);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_happy_path, s_test_s3_put_pause_resume_happy_path)\\\\\\\\nstatic int s_test_s3_put_pause_resume_happy_path(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded < s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_all_parts_done, s_test_s3_put_pause_resume_all_parts_done)\\\\\\\\nstatic int s_test_s3_put_pause_resume_all_parts_done(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_all_parts_done.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 128 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_NONE,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    AWS_LOGF_INFO(AWS_LS_S3_GENERAL, \\\\\\\\\\\\\"Persistable state %p\\\\\\\\\\\\\", persistable_state);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_NONE,\\\\\\\\n        AWS_ERROR_SUCCESS,\\\\\\\\n        AWS_HTTP_STATUS_CODE_200_OK));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_INT_EQUALS(0, bytes_uploaded);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_resume_data, s_test_s3_put_pause_resume_invalid_resume_data)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_resume_data(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_resume_data.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_destroy(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* new stream used to resume upload. it begins at the offset specified in the persistable state */\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_s3_test_input_stream_new_with_value_type(\\\\\\\\n        allocator, s_pause_resume_object_length_128MB, TEST_STREAM_VALUE_2);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_RESUMED_PART_CHECKSUM_MISMATCH,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* bytes uploaded is smaller since we are skipping uploaded parts */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded < s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_destroy(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_resume_stream, s_test_s3_put_pause_resume_invalid_resume_stream)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_resume_stream(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_bad_resume_stream.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_release(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* a bad input stream to resume from */\\\\\\\\n    struct aws_input_stream_tester_options stream_options = {\\\\\\\\n        .autogen_length = s_pause_resume_object_length_128MB,\\\\\\\\n        .fail_on_nth_read = 1,\\\\\\\\n        .fail_with_error_code = AWS_IO_STREAM_READ_FAILED,\\\\\\\\n    };\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_input_stream_new_tester(allocator, &stream_options);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    /* Each failed resume will delete the MPU */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_IO_STREAM_READ_FAILED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* resume didn\\'t read any bytes because the bad input stream failed to read. */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded == 0);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_release(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_put_pause_resume_invalid_content_length, s_test_s3_put_pause_resume_invalid_content_length)\\\\\\\\nstatic int s_test_s3_put_pause_resume_invalid_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    AWS_ZERO_STRUCT(tester);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor destination_key =\\\\\\\\n        AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(\\\\\\\\\\\\\"/upload/test_pause_resume_bad_resume_stream.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct put_object_pause_resume_test_data test_data;\\\\\\\\n    AWS_ZERO_STRUCT(test_data);\\\\\\\\n\\\\\\\\n    /* initialize the atomic members */\\\\\\\\n    aws_atomic_init_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.request_pause_offset, 0);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_requested, false);\\\\\\\\n    aws_atomic_init_int(&test_data.pause_result, 0);\\\\\\\\n    aws_atomic_init_ptr(&test_data.persistable_state_ptr, NULL);\\\\\\\\n\\\\\\\\n    /* offset of the upload where pause should be requested by test client */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, 8 * 1024 * 1024);\\\\\\\\n    test_data.content_length = s_pause_resume_object_length_128MB;\\\\\\\\n\\\\\\\\n    /* stream used to initiate upload */\\\\\\\\n    struct aws_input_stream *initial_upload_stream =\\\\\\\\n        aws_s3_test_input_stream_new(allocator, s_pause_resume_object_length_128MB);\\\\\\\\n\\\\\\\\n    /* starts the upload request that will be paused */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        initial_upload_stream,\\\\\\\\n        NULL,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_PAUSED,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    aws_input_stream_release(initial_upload_stream);\\\\\\\\n\\\\\\\\n    /* a small input stream to resume with */\\\\\\\\n    struct aws_input_stream *resume_upload_stream = aws_s3_test_input_stream_new(allocator, 8 * 1024 * 1024);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_resume_token *persistable_state = aws_atomic_load_ptr(&test_data.persistable_state_ptr);\\\\\\\\n\\\\\\\\n    size_t bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* offset where pause should be requested is set to a value greater than content length,\\\\\\\\n     * to avoid any more pause when resuming the upload */\\\\\\\\n    aws_atomic_store_int(&test_data.request_pause_offset, s_pause_resume_object_length_128MB * 2);\\\\\\\\n    aws_atomic_store_int(&test_data.total_bytes_uploaded, 0);\\\\\\\\n\\\\\\\\n    /* Each failed resume will delete the MPU */\\\\\\\\n    ASSERT_SUCCESS(s_test_s3_put_pause_resume_helper(\\\\\\\\n        &tester,\\\\\\\\n        allocator,\\\\\\\\n        ctx,\\\\\\\\n        &test_data,\\\\\\\\n        destination_key,\\\\\\\\n        resume_upload_stream,\\\\\\\\n        persistable_state,\\\\\\\\n        AWS_SCA_CRC32,\\\\\\\\n        AWS_ERROR_S3_INCORRECT_CONTENT_LENGTH,\\\\\\\\n        0));\\\\\\\\n\\\\\\\\n    bytes_uploaded = aws_atomic_load_int(&test_data.total_bytes_uploaded);\\\\\\\\n\\\\\\\\n    /* resume didn\\'t read any bytes because the bad input stream failed to read. */\\\\\\\\n    ASSERT_TRUE(bytes_uploaded == 0);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_resume_token_release(persistable_state);\\\\\\\\n    aws_input_stream_release(resume_upload_stream);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Most basic test of the upload_review_callback */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review, s_test_s3_upload_review)\\\\\\\\nstatic int s_test_s3_upload_review(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_CRC32.txt\\\\\\\\\\\\\"),\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(2, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(8), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(10) - MB_TO_BYTES(8), test_results.upload_review.part_sizes_array[1]);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_SCA_CRC32, test_results.upload_review.checksum_algorithm);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"9J8ZNA==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"BNjxzQ==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[1]));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test upload_review_callback when Content-Length is not declared */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_no_content_length, s_test_s3_upload_review_no_content_length)\\\\\\\\nstatic int s_test_s3_upload_review_no_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_1MB_CRC32.txt\\\\\\\\\\\\\"),\\\\\\\\n                .object_size_mb = 1,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(NULL, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(1), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"4hP4ig==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic int s_upload_review_raise_canceled_error(\\\\\\\\n    struct aws_s3_meta_request *meta_request,\\\\\\\\n    const struct aws_s3_upload_review *review,\\\\\\\\n    void *user_data) {\\\\\\\\n\\\\\\\\n    (void)meta_request;\\\\\\\\n    (void)review;\\\\\\\\n    (void)user_data;\\\\\\\\n\\\\\\\\n    return aws_raise_error(AWS_ERROR_S3_CANCELED);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that if upload_review_callback raises an error, then the upload is canceled. */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_rejection, s_test_s3_upload_review_rejection)\\\\\\\\nstatic int s_test_s3_upload_review_rejection(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_rejection.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client_config client_config;\\\\\\\\n    AWS_ZERO_STRUCT(client_config);\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_bind_client(\\\\\\\\n        &tester, &client_config, AWS_S3_TESTER_BIND_CLIENT_REGION | AWS_S3_TESTER_BIND_CLIENT_SIGNING));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = aws_s3_client_new(allocator, &client_config);\\\\\\\\n    ASSERT_NOT_NULL(client);\\\\\\\\n\\\\\\\\n    /* Send meta-request that will raise an error from the review_upload_callback */\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .upload_review_callback = s_upload_review_raise_canceled_error,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* Check that meta-request failed with the error raised by the upload_review_callback */\\\\\\\\n    ASSERT_INT_EQUALS(AWS_ERROR_S3_CANCELED, test_results.finished_error_code);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n\\\\\\\\n    /*\\\\\\\\n     * Now check that the upload did not complete on the server either\\\\\\\\n     * (server should have received AbortMultipartUpload).\\\\\\\\n     * Check by attempting to GET the object, which should fail with 404 NOT FOUND.\\\\\\\\n     */\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .client = client,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_FAILURE,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, &test_results));\\\\\\\\n    ASSERT_INT_EQUALS(AWS_HTTP_STATUS_CODE_404_NOT_FOUND, test_results.finished_response_status);\\\\\\\\n    ASSERT_NOT_NULL(test_results.error_response_operation_name);\\\\\\\\n    ASSERT_TRUE(\\\\\\\\n        aws_string_eq_c_str(test_results.error_response_operation_name, \\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\") ||\\\\\\\\n        aws_string_eq_c_str(test_results.error_response_operation_name, \\\\\\\\\\\\\"HeadObject\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Test that an MPU can be done with checksum location = NONE as long as an upload review callback\\\\\\\\n * is used, and the resulting object doesn\\'t have checksums uploaded. */\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_checksum_location_none, s_test_s3_upload_review_checksum_location_none)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n\\\\\\\\n    /* The tester always registers an upload_review_callback.\\\\\\\\n     * Check that it got what we expect */\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n    ASSERT_UINT_EQUALS(2, test_results.upload_review.part_count);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(5), test_results.upload_review.part_sizes_array[0]);\\\\\\\\n    ASSERT_UINT_EQUALS(MB_TO_BYTES(5), test_results.upload_review.part_sizes_array[1]);\\\\\\\\n    ASSERT_INT_EQUALS(AWS_SCA_CRC32, test_results.upload_review.checksum_algorithm);\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"7/xUXw==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[0]));\\\\\\\\n    ASSERT_STR_EQUALS(\\\\\\\\\\\\\"PCOjcw==\\\\\\\\\\\\\", aws_string_c_str(test_results.upload_review.part_checksums_array[1]));\\\\\\\\n\\\\\\\\n    /* S3 will store the crc64 checksum for the whole object, and we can still have validate the checksum, but the algo\\\\\\\\n     * be validated will be crc64, instead of the crc32 we get from the client. */\\\\\\\\n    struct aws_s3_tester_meta_request_options get_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_GET_OBJECT,\\\\\\\\n        .validate_type = AWS_S3_TESTER_VALIDATE_TYPE_EXPECT_SUCCESS,\\\\\\\\n        .client = client,\\\\\\\\n        .expected_validate_checksum_alg = AWS_SCA_CRC64NVME,\\\\\\\\n        .validate_get_response_checksum = true,\\\\\\\\n        .get_options =\\\\\\\\n            {\\\\\\\\n                .object_path = object_path,\\\\\\\\n            },\\\\\\\\n        .finish_callback = s_s3_test_validate_checksum,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &get_options, NULL));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_upload_review_checksum_location_none_async, s_test_s3_upload_review_checksum_location_none_async)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none_async(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/* Trying to reach the noop case of async read */\\\\\\\\nAWS_TEST_CASE(\\\\\\\\n    test_s3_upload_review_checksum_location_none_async_noop_part,\\\\\\\\n    s_test_s3_upload_review_checksum_location_none_async_noop_part)\\\\\\\\nstatic int s_test_s3_upload_review_checksum_location_none_async_noop_part(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_byte_cursor object_path = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"/upload/review_10MB_no_CRC32.txt\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n    struct aws_s3_tester_client_options client_options = {\\\\\\\\n        .part_size = MB_TO_BYTES(5),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n\\\\\\\\n    struct aws_s3_tester_meta_request_options put_options = {\\\\\\\\n        .allocator = allocator,\\\\\\\\n        .meta_request_type = AWS_S3_META_REQUEST_TYPE_PUT_OBJECT,\\\\\\\\n        .client = client,\\\\\\\\n        .checksum_algorithm = AWS_SCA_CRC32,\\\\\\\\n        .disable_put_trailing_checksum = true,\\\\\\\\n        .put_options =\\\\\\\\n            {\\\\\\\\n                .object_size_mb = 10,\\\\\\\\n                .object_path_override = object_path,\\\\\\\\n                .async_input_stream = true,\\\\\\\\n                .skip_content_length = true,\\\\\\\\n                .eof_requires_extra_read = true, /* don\\'t report EOF until it tries to read 2nd part */\\\\\\\\n            },\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&test_results, allocator);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request_with_options(&tester, &put_options, &test_results));\\\\\\\\n    ASSERT_UINT_EQUALS(1, test_results.upload_review.invoked_count);\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&test_results);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n    return 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstatic struct aws_http_stream *s_http_connection_make_request_patch(\\\\\\\\n    struct aws_http_connection *client_connection,\\\\\\\\n    const struct aws_http_make_request_options *options) {\\\\\\\\n\\\\\\\\n    struct aws_http_message *message = options->request;\\\\\\\\n    struct aws_http_headers *headers = aws_http_message_get_headers(message);\\\\\\\\n    struct aws_byte_cursor out_value;\\\\\\\\n    int e = aws_http_headers_get(headers, aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"Content-Length\\\\\\\\\\\\\"), &out_value);\\\\\\\\n    AWS_FATAL_ASSERT(e == AWS_OP_ERR); // Assert that the header is not present\\\\\\\\n    AWS_FATAL_ASSERT(aws_last_error() == AWS_ERROR_HTTP_HEADER_NOT_FOUND);\\\\\\\\n\\\\\\\\n    return aws_http_connection_make_request(client_connection, options);\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_get_without_content_length, s_test_s3_default_get_without_content_length)\\\\\\\\nstatic int s_test_s3_default_get_without_content_length(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(host_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    /* Send default type */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.message = message;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    aws_string_destroy(host_name);\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\\\\nstruct aws_string *test_helper(struct aws_allocator *allocator) {\\\\\\\\n    struct aws_string *host_name =\\\\\\\\n        aws_s3_tester_build_endpoint_string(allocator, &g_test_public_bucket_name, &g_test_s3_region);\\\\\\\\n    return host_name;\\\\\\\\n}\\\\\\\\n\\\\\\\\nAWS_TEST_CASE(test_s3_default_get, aws_test_s3_default_get)\\\\\\\\nstatic int aws_test_s3_default_get(struct aws_allocator *allocator, void *ctx) {\\\\\\\\n    (void)ctx;\\\\\\\\n\\\\\\\\n    struct aws_s3_tester tester;\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester));\\\\\\\\n\\\\\\\\n    struct aws_s3_client *client = NULL;\\\\\\\\n    struct aws_s3_tester_client_options client_options;\\\\\\\\n    AWS_ZERO_STRUCT(client_options);\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_client_new(&tester, &client_options, &client));\\\\\\\\n    struct aws_s3_client_vtable *patched_client_vtable = aws_s3_tester_patch_client_vtable(&tester, client, NULL);\\\\\\\\n    patched_client_vtable->http_connection_make_request = s_http_connection_make_request_patch;\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_test_results meta_request_test_results;\\\\\\\\n    aws_s3_meta_request_test_results_init(&meta_request_test_results, allocator);\\\\\\\\n\\\\\\\\n    struct aws_string *hsot_name = test_helper(allocator);\\\\\\\\n\\\\\\\\n    /* Put together a simple S3 Get Object request. */\\\\\\\\n    struct aws_http_message *message = aws_s3_test_get_object_request_new(\\\\\\\\n        allocator, aws_byte_cursor_from_string(hsot_name), g_pre_existing_object_1MB);\\\\\\\\n\\\\\\\\n    struct aws_s3_meta_request_options options;\\\\\\\\n    AWS_ZERO_STRUCT(options);\\\\\\\\n    /* Send default type */\\\\\\\\n    options.type = AWS_S3_META_REQUEST_TYPE_DEFAULT;\\\\\\\\n    options.message = message;\\\\\\\\n    options.operation_name = aws_byte_cursor_from_c_str(\\\\\\\\\\\\\"GetObject\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_send_meta_request(\\\\\\\\n        &tester, client, &options, &meta_request_test_results, AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS));\\\\\\\\n    ASSERT_SUCCESS(aws_s3_tester_validate_get_object_results(&meta_request_test_results, 0));\\\\\\\\n\\\\\\\\n    aws_s3_meta_request_test_results_clean_up(&meta_request_test_results);\\\\\\\\n    aws_http_message_release(message);\\\\\\\\n    aws_s3_client_release(client);\\\\\\\\n    aws_s3_tester_clean_up(&tester);\\\\\\\\n\\\\\\\\n    return AWS_OP_SUCCESS;\\\\\\\\n}\\\\\\\\n\\\\\",\\\\n  \\\\\"encoding\\\\\": \\\\\"base64\\\\\",\\\\n  \\\\\"_links\\\\\": {\\\\n    \\\\\"self\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/contents/tests/s3_data_plane_tests.c?ref=dummy-delete-me\\\\\",\\\\n    \\\\\"git\\\\\": \\\\\"https://api.github.com/repos/awslabs/aws-c-s3/git/blobs/dacbffee8596e65af525c01b86d694a178cf88a7\\\\\",\\\\n    \\\\\"html\\\\\": \\\\\"https://github.com/awslabs/aws-c-s3/blob/dummy-delete-me/tests/s3_data_plane_tests.c\\\\\"\\\\n  }\\\\n}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Let me also look at the comments_styles.md file to understand how I should format my review:\"},{\"type\":\"tool_use\",\"name\":\"filesystem-read_file\",\"input\":{\"path\":\"/Users/dengket/project/hackthon/fast-agent/crt_c_reviewer/summarization/comments_styles.md\"},\"id\":\"toolu_bdrk_01Ch4NEy2ZvyztRufB3XjQKm\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01Ch4NEy2ZvyztRufB3XjQKm\",\"content\":[{\"type\":\"text\",\"text\":\"# Effective Code Review Comment Guidelines\\\\n\\\\nBased on an analysis of multiple GitHub Pull Request reviews, this document summarizes key patterns and best practices for writing effective code review comments.\\\\n\\\\n## General Principles\\\\n\\\\n### 1. Comment Classification\\\\n\\\\n* **Use clear prefixes to indicate severity:**\\\\n  + `trivial:` - Minor issues that should be fixed but don\\'t block approval\\\\n  + `debatable:` or `extremely debatable:` - Suggestions open to discussion\\\\n  + `nit:` - Extremely minor stylistic preferences\\\\n  + `important:` - Issues that should be addressed before merging\\\\n  + `blocking:` - Critical issues that must be resolved\\\\n\\\\n* **Be explicit about expectations:**\\\\n  + Distinguish between mandatory changes and optional suggestions\\\\n  + Indicate when comments are informational rather than requesting changes\\\\n\\\\n### 2. Comment Structure\\\\n\\\\n* **Be specific and actionable:**\\\\n  + Refer to specific lines or sections of code\\\\n  + Explain both what the issue is and why it matters\\\\n  + Provide concrete solutions when possible\\\\n\\\\n* **Use GitHub suggestion blocks for direct code changes:**\\\\n  \\\\n\\\\n```\\\\n  ```suggestion\\\\n  actual code change goes here\\\\n  ```\\\\n\\\\n  \\\\n\\\\n```\\\\n\\\\n- **Group related issues together:**\\\\n  - Number multiple points for clarity\\\\n  - Address similar issues in a single comment when possible\\\\n\\\\n- **Provide context:**\\\\n  - Link to relevant documentation, PRs, or issues\\\\n  - Reference cross-repository standards when applicable\\\\n  - Explain reasoning behind suggestions, not just what to change\\\\n\\\\n### 3. Comment Scope\\\\n\\\\n- **Focus on the right level of detail:**\\\\n  - For simple PRs: Brief approvals may be sufficient\\\\n  - For complex PRs: Detailed, organized feedback is necessary\\\\n\\\\n- **Consider multiple aspects of code quality:**\\\\n  - Functional correctness\\\\n  - Error handling and edge cases\\\\n  - Performance implications\\\\n  - Security considerations\\\\n  - Consistency with existing patterns\\\\n  - Documentation and readability\\\\n  - Cross-platform compatibility\\\\n  - API design and usability\\\\n\\\\n## Technical Focus Areas\\\\n\\\\n### 1. Code Architecture and Design\\\\n\\\\n- **API Usability:**\\\\n  - Consider the developer experience of using the API\\\\n  - Question potentially confusing or redundant API requirements\\\\n  - Think about cross-language compatibility\\\\n\\\\n- **Error Handling:**\\\\n  - Verify proper cleanup in error cases\\\\n  - Ensure appropriate error propagation\\\\n  - Check for consistent error handling patterns\\\\n  - In C code, prefer unified error paths with consolidated cleanup\\\\n\\\\n- **Consistency:**\\\\n  - Flag inconsistent naming conventions\\\\n  - Highlight deviations from established patterns\\\\n  - Ensure consistency across related repositories\\\\n\\\\n### 2. Code Style and Readability\\\\n\\\\n- **Prioritize clear organization:**\\\\n  - Suggest clearer code structure when logic is hard to follow\\\\n  - Flag complex conditionals that could be simplified\\\\n  - Recommend extracting complex logic into well-named helper functions\\\\n\\\\n- **Comment on documentation:**\\\\n  - Ensure comments accurately describe behavior\\\\n  - Request documentation for parameters with specific usage requirements\\\\n  - Verify public API documentation clarity\\\\n\\\\n- **Focus on maintainability:**\\\\n  - Consider how code might evolve in the future\\\\n  - Identify fragile patterns that could break with future changes\\\\n  - Suggest explicit guards against potential future bugs\\\\n\\\\n### 3. Cross-Team and Ecosystem Considerations\\\\n\\\\n- **Coordinate across teams:**\\\\n  - Flag changes that might affect other teams or services\\\\n  - Recommend cross-team communication when necessary\\\\n\\\\n- **Verify ecosystem consistency:**\\\\n  - Check if behavior matches related SDKs or libraries\\\\n  - Confirm conformance to broader project standards\\\\n\\\\n## Review Process\\\\n\\\\n### 1. Reviewing Approach\\\\n\\\\n- **Progressive reviews:**\\\\n  - Start with critical issues and architectural concerns\\\\n  - Follow up on remaining issues after major concerns are addressed\\\\n  - Provide final approval once all necessary changes are made\\\\n\\\\n- **Approval comments:**\\\\n  - Use \\\\\"fix & ship\\\\\" for PRs with only minor issues\\\\n  - Include verification steps if needed before merging\\\\n  - Acknowledge when previous feedback has been addressed\\\\n\\\\n### 2. Review Tone\\\\n\\\\n- **Be direct but constructive:**\\\\n  - Focus on the code, not the person\\\\n  - Frame feedback as improvements rather than criticisms\\\\n  - Use a professional, collaborative tone\\\\n\\\\n- **Acknowledge good work:**\\\\n  - Provide positive feedback on well-implemented features\\\\n  - Recognize when authors have addressed previous feedback well\\\\n  - Use phrases like \\\\\"nice job\\\\\" or \\\\\"this looks good\\\\\" where appropriate\\\\n\\\\n- **Balance criticism with encouragement:**\\\\n  - Point out both strengths and areas for improvement\\\\n  - Recognize the effort that went into the implementation\\\\n\\\\n## Comment Examples by Category\\\\n\\\\n### Effective Trivial Comments\\\\n\\\\n```\\\\n\\\\ntrivial: undoing needless changes to whitespace\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\ntrivial: it\\'s weird to use the `_10MB` and then upload 5MB\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\ntrivial: I found this if-statement confusing, and the helper function that did different things depending on how it\\'s called...\\\\n\\\\n```\\\\n\\\\n### Effective Technical Suggestions\\\\n\\\\n```\\\\n\\\\nif there\\'s an error, we need to cleanup out_checksum\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nSo, if users already added a checksum header, they ALSO need to set this enum?\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nInstead of the `on_error:` label sharing 90% the same cleanup code as `s_s3_client_finish_destroy_default()` , have them share code\\\\n\\\\n```\\\\n\\\\n### Effective Process Comments\\\\n\\\\n```\\\\n\\\\nI\\'d advise checking this branch from aws-crt-cpp, and making sure it all works nicely, before merging\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nChecked the C++ SDK and Java SDK and they also retry on TLS errors.\\\\n\\\\n```\\\\n\\\\n```\\\\n\\\\nneed to coordinate with python teams on this...\\\\n```\\\\n\\\\n### Silent Approvals (When Appropriate)\\\\n\\\\nSilent approvals (no comments, just approval) are appropriate for:\\\\n* Simple, straightforward changes\\\\n* Well-understood code\\\\n* Follow-up to previous discussions\\\\n* Self-explanatory code\\\\n* Trivial fixes\\\\n* When there\\'s an established trust relationship between reviewer and author\\\\n\\\\n## Special Cases\\\\n\\\\n### 1. Automated/Routine Changes\\\\n\\\\n* **Minimize comments for routine updates:**\\\\n  + For automated changes or version bumps, simple approvals may be sufficient\\\\n  + Focus comments on any unexpected deviations from expected patterns\\\\n\\\\n### 2. Cross-Repository Changes\\\\n\\\\n* **Consider broader impacts:**\\\\n  + For changes affecting multiple repositories, test across all affected codebases\\\\n  + Verify consistency with related repositories\\' standards\\\\n\\\\n### 3. Documentation Changes\\\\n\\\\n* **Focus on accuracy and clarity:**\\\\n  + Ensure documentation correctly describes behavior\\\\n  + Verify examples work as described\\\\n  + Check for consistent formatting and terminology\\\\n\\\\n## Conclusion\\\\n\\\\nEffective code review comments are specific, actionable, appropriately categorized, and delivered in a constructive tone. They focus on technical accuracy while maintaining readability and consistency with project standards. The level of detail should match the complexity of the change, ranging from brief approvals for simple changes to detailed, structured feedback for complex modifications.\\\\n\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Now, let me also check if there\\'s any relevant information in the AWS Knowledge Base about this code:\"},{\"type\":\"tool_use\",\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"input\":{\"knowledge_base_id\":\"8BRIG4RFWU\",\"query\":\"What does test_helper function do in aws-c-s3? What is the code and naming convention in aws-c tests?\"},\"id\":\"toolu_bdrk_015UTkdEAkaqbBY4oZsnvRgY\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_015UTkdEAkaqbBY4oZsnvRgY\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3express_credentials_provider_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3express_credentials_provider.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/atomics.h> #include <aws/common/clock.h> #include <aws/common/encoding.h> #include <aws/common/lru_cache.h> #include <aws/io/stream.h> #include <aws/io/uri.h> #include <aws/testing/aws_test_harness.h> #include <inttypes.h>  #define TEST_CASE(NAME)                                                                                                \\\\\\\\\\\\\\\\     AWS_TEST_CASE(NAME, s_test_##NAME);                                                                                \\\\\\\\\\\\\\\\     static int s_test_##NAME(struct aws_allocator *allocator, void *ctx)  #define DEFINE_HEADER(NAME, VALUE)                                                                                     \\\\\\\\\\\\\\\\     {                                                                                                                  \\\\\\\\\\\\\\\\         .name = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(NAME),                                                           \\\\\\\\\\\\\\\\         .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(VALUE),                                                         \\\\\\\\\\\\\\\\     }  struct aws_s3express_client_tester {     struct aws_allocator *allocator;     struct aws_hash_table saver_cache;     struct aws_atomic_var provider_requests_made; };  static struct aws_s3express_client_tester\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_s3express_client_test.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.57874686}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"# Helper script to setup your S3 structure to run the tests for aws-c-s3 To use this script, you must have AWS credentials with permission to create and delete buckets. To create the S3 buckets and objects that tests will use: ```sh pip3 install boto3 export CRT_S3_TEST_BUCKET_NAME=<bucket_name> python3 test_helper.py init # change directory to the build/tests cd aws-c-s3/build/tests && ctest ``` To clean up the S3 buckets created ```sh export CRT_S3_TEST_BUCKET_NAME=<bucket_name> python3 test_helper.py clean ``` ## Actions ### `init` action * Create `<BUCKET_NAME>` in us-west-2. + Add the lifecycle to automatic clean up the `upload/` and clean up incomplete multipart uploads after one day. + Upload files: - `pre-existing-10MB-aes256-c` [SSE-C](https://docs.aws.amazon.com/AmazonS3/latest/userguide/ServerSideEncryptionCustomerKeys.html#sse-c-highlights) encrypted fille - `pre-existing-10MB-aes256` [SSE-S3](https://docs.aws.amazon.com/AmazonS3/latest/userguide/specifying-s3-encryption.html) encrypted fille - `pre-existing-10MB-kms` [SSE-KMS](https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html) encrypted fille - `pre-existing-10MB` -\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/test_helper/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5644728}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_checksums.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/byte_buf.h> #include <aws/common/clock.h> #include <aws/common/common.h> #include <aws/common/encoding.h> #include <aws/common/environment.h> #include <aws/common/ref_count.h> #include <aws/http/request_response.h> #include <aws/http/status_code.h> #include <aws/io/channel_bootstrap.h> #include <aws/io/event_loop.h> #include <aws/io/host_resolver.h> #include <aws/io/stream.h> #include <aws/io/tls_channel_handler.h> #include <aws/io/uri.h> #include <aws/testing/aws_test_harness.h> #include <aws/testing/stream_tester.h> #include <inttypes.h>  AWS_TEST_CASE(test_s3_client_create_destroy, s_test_s3_client_create_destroy) static int s_test_s3_client_create_destroy(struct aws_allocator *allocator, void *ctx) {     (\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_data_plane_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.56113476}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */ #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\"  #include <aws/checksums/crc.h> #include <aws/common/byte_order.h> #include <aws/common/clock.h> #include <aws/common/device_random.h> #include <aws/common/encoding.h> #include <aws/s3/private/s3_util.h> #include <aws/testing/aws_test_harness.h>  #define TIMEOUT_NANOS ((uint64_t)AWS_TIMESTAMP_NANOS * 10) /* 10secs */ #define PART_SIZE MB_TO_BYTES(5)  struct asyncwrite_tester {     struct aws_allocator *allocator;     struct aws_s3_tester s3_tester;     struct aws_s3_client *client;     struct aws_s3_meta_request *meta_request;     struct aws_s3_meta_request_test_results test_results;     struct aws_byte_buf source_buf; };  static int s_asyncwrite_tester_init(     struct asyncwrite_tester *tester,     struct aws_allocator *allocator,     size_t object_size) {      AWS_ZERO_STRUCT(*tester);     tester->allocator = allocator;      ASSERT_SUCCESS(aws_s3_tester_init(allocator, &tester->s3_tester));      /* Create S3 client */     struct aws_s3_client_config client_config\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_asyncwrite_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5513765}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"\\\\\\\\\\\\\\\\     };                                                                                                                 \\\\\\\\\\\\\\\\     int name(int argc, char *argv[]) {                                                                                 \\\\\\\\\\\\\\\\         (void)argc;                                                                                                    \\\\\\\\\\\\\\\\         (void)argv;                                                                                                    \\\\\\\\\\\\\\\\         return s_aws_run_test_case(&name##_test);                                                                      \\\\\\\\\\\\\\\\     }  #define AWS_TEST_CASE(name, fn) AWS_TEST_CASE_SUPRESSION(name, fn, 0) #define AWS_TEST_CASE_FIXTURE(name, b, fn, af, c) AWS_TEST_CASE_FIXTURE_SUPPRESSION(name, b, fn, af, c, 0)  #endif /* AWS_TESTING_AWS_TEST_HARNESS_H */\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/include/aws/testing/aws_test_harness.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5501521}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"#ifndef AWS_S3_TESTER_H #define AWS_S3_TESTER_H  /**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_request_messages.h\\\\\\\\\\\\\" #include <aws/s3/private/s3_auto_ranged_put.h> #include <aws/s3/private/s3_client_impl.h> #include <aws/s3/private/s3_meta_request_impl.h> #include <aws/s3/s3.h> #include <aws/s3/s3_client.h> #include <aws/s3/s3express_credentials_provider.h>  #include <aws/common/common.h> #include <aws/common/condition_variable.h> #include <aws/common/file.h> #include <aws/common/logging.h> #include <aws/common/mutex.h> #include <aws/common/string.h> #include <aws/testing/async_stream_tester.h>  struct aws_client_bootstrap; struct aws_credentials_provider; struct aws_event_loop_group; struct aws_host_resolver; struct aws_input_stream;  enum AWS_S3_TESTER_BIND_CLIENT_FLAGS {     AWS_S3_TESTER_BIND_CLIENT_REGION = 0x00000001,     AWS_S3_TESTER_BIND_CLIENT_SIGNING = 0x00000002, };  enum AWS_S3_TESTER_SEND_META_REQUEST_FLAGS {     AWS_S3_TESTER_SEND_META_REQUEST_EXPECT_SUCCESS =\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_tester.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.54924184}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"};  struct aws_s3_client_vtable_patch {     struct aws_s3_client_vtable *original_vtable;     struct aws_s3_client_vtable patched_vtable; };  struct aws_s3_meta_request_vtable_patch {     struct aws_s3_meta_request_vtable *original_vtable;     struct aws_s3_meta_request_vtable patched_vtable; };  /* Utility for setting up commonly needed resources for tests. */ struct aws_s3_tester {     struct aws_allocator *allocator;     struct aws_event_loop_group *el_group;     struct aws_host_resolver *host_resolver;     struct aws_client_bootstrap *client_bootstrap;     struct aws_credentials_provider *credentials_provider;     struct aws_signing_config_aws default_signing_config;     struct aws_credentials *anonymous_creds;     struct aws_signing_config_aws anonymous_signing_config;      struct aws_condition_variable signal;     bool bound_to_client;      struct aws_array_list client_vtable_patches;     struct aws_array_list meta_request_vtable_patches;     void *user_data;      struct aws_string *bucket_name;     struct aws_string *public_bucket_name;     struct aws_string *s3express_bucket_usw2_az1_endpoint;     struct aws_string *s3express_bucket_use1_az4_endpoint;      struct {         struct aws_mutex lock;          size_t desired_meta_request_finish_count;         size_t meta_request_finish_count;          size_t desired_meta_request_shutdown_count;\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_tester.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5489566}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3express_credentials_provider_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3express_credentials_provider.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/clock.h> #include <aws/common/lru_cache.h> #include <aws/io/stream.h> #include <aws/io/uri.h> #include <aws/testing/aws_test_harness.h> #include <inttypes.h>  #define TEST_CASE(NAME)                                                                                                \\\\\\\\\\\\\\\\     AWS_TEST_CASE(NAME, s_test_##NAME);                                                                                \\\\\\\\\\\\\\\\     static int s_test_##NAME(struct aws_allocator *allocator, void *ctx)  #define DEFINE_HEADER(NAME, VALUE)                                                                                     \\\\\\\\\\\\\\\\     {                                                                                                                  \\\\\\\\\\\\\\\\         .name = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(NAME),                                                           \\\\\\\\\\\\\\\\         .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(VALUE),                                                         \\\\\\\\\\\\\\\\     }  static uint64_t s_bg_refresh_secs_override = 60;  struct aws_s3express_provider_tester {     struct aws_allocator *allocator;      struct aws_mutex lock;     struct aws_condition_variable signal;      size_t credentials_callbacks_received;     bool has_received_shutdown_callback;      /* Last received credentials */\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_mock_server_s3express_provider_test.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5385748}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_client_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_meta_request_impl.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/byte_buf.h> #include <aws/common/clock.h> #include <aws/common/common.h> #include <aws/common/environment.h> #include <aws/common/ref_count.h> #include <aws/http/request_response.h> #include <aws/io/channel_bootstrap.h> #include <aws/io/event_loop.h> #include <aws/io/host_resolver.h> #include <aws/io/stream.h> #include <aws/io/tls_channel_handler.h> #include <aws/testing/aws_test_harness.h> #include <inttypes.h> #include <stdio.h>  /* Ensure the library can go through the init/cleanup cycle multiple times */ AWS_TEST_CASE(test_s3_library_init_cleanup_init_cleanup, s_test_s3_library_init_cleanup_init_cleanup) static int s_test_s3_library_init_cleanup_init_cleanup(struct aws_allocator *allocator, void *ctx) {     (void)ctx;      aws_s3_library_init(allocator);     aws_s3_library_clean_up();      aws_s3_library_init(allocator);\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_util_tests.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.53787583}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"#ifndef AWS_TESTING_AWS_TEST_HARNESS_H #define AWS_TESTING_AWS_TEST_HARNESS_H /**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include <aws/common/common.h> #include <aws/common/error.h> #include <aws/common/logging.h> #include <aws/common/mutex.h> #include <aws/common/system_info.h>  #include <stdarg.h> #include <stdio.h> #include <stdlib.h> #include <string.h>  /**  * The return code for skipped tests. Use the return code if the test should be skipped.  */ #define AWS_OP_SKIP (-2)  #ifndef AWS_UNSTABLE_TESTING_API #    error The AWS Test Fixture is designed only for use by AWS owned libraries for the AWS C99 SDK. You are welcome to use it,   \\\\\\\\\\\\\\\\ but you should be aware we make no promises on the stability of this API.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/include/aws/testing/aws_test_harness.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.53592694}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Let me also check if there is any information about naming conventions:\"},{\"type\":\"tool_use\",\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"input\":{\"knowledge_base_id\":\"8BRIG4RFWU\",\"query\":\"What are the naming conventions in aws-c projects for variables, functions and unit tests?\"},\"id\":\"toolu_bdrk_01Gsit3KbRdmFWt6DRt8mXNE\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_01Gsit3KbRdmFWt6DRt8mXNE\",\"content\":[{\"type\":\"text\",\"text\":\"{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"Example: #ifdef FOO do_something(); #   ifdef BAR do_something_else(); #   endif #endif * For all error code names with the exception of aws-c-common, use `AWS_ERROR_<lib name>_<error name>`. * All error strings should be written using correct English grammar. * SNAKE_UPPER_CASE constants, macros, and enum members. * snake_lower_case everything else. * `static` (local file scope) variables that are not `const` are prefixed by `s_` and lower snake case. * Global variables not prefixed as `const` are prefixed by `g_` and lower snake case. * Thread local variables are prefixed as `tl_` and lower snake case. * Macros and `const` variables are upper snake case. * For constants, prefer anonymous enums. * Don\\'t typedef structs. It breaks forward declaration ability. * Don\\'t typedef enums. It breaks forward declaration ability. * typedef function definitions for use as function pointers as values and suffixed with _fn. Do this: typedef int(fn_name_fn)(void *); Not this: typedef int(*fn_name_fn)(void *); * If a callback may be async, then always have it be async. Callbacks that are sometimes async and sometimes sync are hard to code around and lead to bugs (see [this blog post](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)).\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.5241461}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"Each library should begin its error and log subject values at the beginning of its range and follow in sequence (don\\'t skip codes). Upon adding an AWS maintained library, a new enum range must be approved and added to the above table. ### Testing We have a high bar for test coverage, and PRs fixing bugs or introducing new functionality need to have tests before they will be accepted. A couple of tips: #### Aws Test Harness We provide a test harness for writing unit tests. This includes an allocator that will fail your test if you have any memory leaks, as well as some `ASSERT` macros. To write a test: * Create a *.c test file in the tests directory of the project. * Implement one or more tests with the signature `int test_case_name(struct aws_allocator *, void *ctx)` * Use the `AWS_TEST_CASE` macro to declare the test. * Include your test in the `tests/main.c` file. * Include your test in the `tests/CMakeLists.txt` file. ### Coding Style * No Tabs. * Indent is 4 spaces. * K & R style for braces. * Space after if, before the `(`. * `else` and `else if` stay on the same line as the closing brace. Example: if (condition) { do_something(); } else { do_something_else(); } * Avoid C99 features in header files.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.50717956}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"We\\'ll outline them here. These conventions are followed in every library in the AWS C SDK ecosystem. #### Error handling Every function that returns an `int` type, returns `AWS_OP_SUCCESS` ( 0 ) or `AWS_OP_ERR` (-1) on failure. To retrieve the error code, use the function `aws_last_error()`. Each error code also has a corresponding error string that can be accessed via the `aws_error_str()` function. In addition, you can install both a global and a thread local error handler by using the `aws_set_global_error_handler_fn()` and `aws_set_thread_local_error_handler_fn()` functions. All error functions are in the `include/aws/common/error.h` header file. #### Naming Any function that allocates and initializes an object will be suffixed with `new` (e.g. `aws_myobj_new()`). Similarly, these objects will always have a corresponding function with a `destroy` suffix. The `new` functions will return the allocated object on success and `NULL` on failure. To respond to the error, call `aws_last_error()`. If several `new` or `destroy` functions are available, the variants should be named like `new_x` or `destroy_x` (e.g. `aws_myobj_new_copy()` or `aws_myobj_destroy_secure()`). Any function that initializes an existing object will be suffixed with `init` (e.g.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.4982677}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"Lib name is not always required if a conflict is not likely and it provides better ergonomics. * `init`, `clean_up`, `new`, `destroy` are suffixed to the function names for their object. Example: AWS_COMMON_API int aws_module_init(aws_module_t *module); AWS_COMMON_API void aws_module_clean_up(aws_module_t *module); AWS_COMMON_API aws_module_t *aws_module_new(aws_allocator_t *allocator); AWS_COMMON_API void aws_module_destroy(aws_module_t *module); * Avoid c-strings, and don\\'t write code that depends on `NULL` terminators. * Pass strings via `struct aws_byte_cursor`. This is a non-owning view type. Pass it by value. Strings passed this way do not need a `NULL` terminator. * Only pass `const char *` when thinly wrapping an OS function that *requires* a `NULL` terminator. * Store const strings as `struct aws_string *` * Store mutable string buffers as `struct aws_byte_buf` * There is only one valid character encoding-- UTF-8.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/README.md\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.48667943}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"You are welcome to use it,   \\\\\\\\\\\\\\\\ but you should be aware we make no promises on the stability of this API.  To enable use of the aws test fixtures, set \\\\\\\\\\\\\\\\ the AWS_UNSTABLE_TESTING_API compiler flag #endif  #ifndef AWS_TESTING_REPORT_FD #    define AWS_TESTING_REPORT_FD stderr #endif  #ifdef _MSC_VER #    pragma warning(disable : 4221) /* aggregate initializer using local variable addresses */ #    pragma warning(disable : 4204) /* non-constant aggregate initializer */ #endif  #if defined(__clang__) #    pragma clang diagnostic ignored \\\\\\\\\\\\\"-Wgnu-zero-variadic-macro-arguments\\\\\\\\\\\\\" #endif  /** Prints a message to AWS_TESTING_REPORT_FD using printf format that appends the function, file and line number.  * If format is null, returns 0 without printing anything; otherwise returns 1.  * If function or file are null, the function, file and line number are not appended.  */ static int s_cunit_failure_message0(     const char *prefix,     const char *function,     const char *file,     int line,     const char *format,     ...) {     if (!\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/include/aws/testing/aws_test_harness.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.46653557}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include \\\\\\\\\\\\\"aws/s3/private/s3_parallel_input_stream.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/private/s3_util.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"aws/s3/s3_client.h\\\\\\\\\\\\\" #include \\\\\\\\\\\\\"s3_tester.h\\\\\\\\\\\\\" #include <aws/common/clock.h> #include <aws/common/file.h> #include <aws/common/string.h> #include <aws/io/event_loop.h> #include <aws/io/future.h> #include <aws/io/stream.h> #include <aws/io/uri.h> #include <aws/testing/aws_test_harness.h> #include <inttypes.h>  #include <sys/stat.h>  #define TEST_CASE(NAME)                                                                                                \\\\\\\\\\\\\\\\     AWS_TEST_CASE(NAME, s_test_##NAME);                                                                                \\\\\\\\\\\\\\\\     static int s_test_##NAME(struct aws_allocator *allocator, void *ctx)  #define DEFINE_HEADER(NAME, VALUE)                                                                                     \\\\\\\\\\\\\\\\     {                                                                                                                  \\\\\\\\\\\\\\\\         .name = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(NAME),                                                           \\\\\\\\\\\\\\\\         .value = AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL(VALUE),                                                         \\\\\\\\\\\\\\\\     }  #define ONE_SEC_IN_NS ((uint64_t)AWS_TIMESTAMP_NANOS) #define MAX_TIMEOUT_NS (600 * ONE_SEC_IN_NS)  AWS_STATIC_STRING_FROM_LITERAL(s_parallel_stream_test, \\\\\\\\\\\\\"SimpleParallelStreamTest\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-s3/tests/s3_parallel_read_stream_test.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.46571377}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"cmake_minimum_required(VERSION 3.9...3.31)  # AWS lib set(path_to_common \\\\\\\\\\\\\"${CMAKE_CURRENT_LIST_DIR}/../../../../..\\\\\\\\\\\\\") get_filename_component(path_to_common ${path_to_common} ABSOLUTE)  # This is required in order to append /lib/cmake to each element in CMAKE_PREFIX_PATH set(AWS_MODULE_DIR \\\\\\\\\\\\\"/${CMAKE_INSTALL_LIBDIR}/cmake\\\\\\\\\\\\\") string(REPLACE \\\\\\\\\\\\\";\\\\\\\\\\\\\" \\\\\\\\\\\\\"${AWS_MODULE_DIR};\\\\\\\\\\\\\" AWS_MODULE_PATH \\\\\\\\\\\\\"${CMAKE_PREFIX_PATH}${AWS_MODULE_DIR}\\\\\\\\\\\\\") # Append that generated list to the module search path list(APPEND CMAKE_MODULE_PATH ${AWS_MODULE_PATH})  list(APPEND CMAKE_MODULE_PATH \\\\\\\\\\\\\"${path_to_common}/cmake\\\\\\\\\\\\\") include(AwsFindPackage) set(IN_SOURCE_BUILD ON) set(BUILD_SHARED_LIBS ON)  # We will generate our own tests, the tests that are there depend on CTest set(ALLOW_CROSS_COMPILED_TESTS ON) set(BUILD_TESTING ON) add_subdirectory(${path_to_common} ${CMAKE_CURRENT_BINARY_DIR}/aws-c-common) aws_use_package(aws-c-common)  function(import_tests test_cmakelists)     get_property(TEST_CASES GLOBAL PROPERTY AWS_TEST_CASES)      # Generate Kotlin test classes     get_filename_component(testrunner_path \\\\\\\\\\\\\"../..\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/AWSCRTAndroidTestRunner/app/src/main/cpp/CMakeLists.txt\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.46179938}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"\\\\\\\\\\\\\\\\     };                                                                                                                 \\\\\\\\\\\\\\\\     int name(int argc, char *argv[]) {                                                                                 \\\\\\\\\\\\\\\\         (void)argc;                                                                                                    \\\\\\\\\\\\\\\\         (void)argv;                                                                                                    \\\\\\\\\\\\\\\\         return s_aws_run_test_case(&name##_test);                                                                      \\\\\\\\\\\\\\\\     }  #define AWS_TEST_CASE(name, fn) AWS_TEST_CASE_SUPRESSION(name, fn, 0) #define AWS_TEST_CASE_FIXTURE(name, b, fn, af, c) AWS_TEST_CASE_FIXTURE_SUPPRESSION(name, b, fn, af, c, 0)  #endif /* AWS_TESTING_AWS_TEST_HARNESS_H */\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-common/include/aws/testing/aws_test_harness.h\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.45955497}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  /**  * See PKCS11.md for instructions on running these tests  */  #include <aws/io/pkcs11.h>  #include \\\\\\\\\\\\\"../source/pkcs11_private.h\\\\\\\\\\\\\"  #include <aws/common/clock.h> #include <aws/common/condition_variable.h> #include <aws/common/environment.h> #include <aws/common/file.h> #include <aws/common/mutex.h> #include <aws/common/process.h> #include <aws/common/string.h> #include <aws/common/uuid.h> #include <aws/io/channel_bootstrap.h> #include <aws/io/event_loop.h> #include <aws/io/logging.h> #include <aws/io/socket.h> #include <aws/io/tls_channel_handler.h> #include <aws/testing/aws_test_harness.h>  #ifdef _MSC_VER #    pragma warning(disable : 4996) /* allow strncpy() */ #endif  AWS_STATIC_STRING_FROM_LITERAL(TEST_PKCS11_LIB, \\\\\\\\\\\\\"TEST_PKCS11_LIB\\\\\\\\\\\\\"); AWS_STATIC_STRING_FROM_LITERAL(TEST_PKCS11_TOKEN_DIR, \\\\\\\\\\\\\"TEST_PKCS11_TOKEN_DIR\\\\\\\\\\\\\");  /* Singleton that stores env-var values */ struct pkcs11_tester {     struct aws_allocator *allocator;     struct aws_string *shared_lib_path;     struct aws_string *\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-io/tests/pkcs11_test.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.4586537}\\\\n\\\\n{\\\\\"content\\\\\": {\\\\\"text\\\\\": \\\\\"/**  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  * SPDX-License-Identifier: Apache-2.0.  */  #include <aws/testing/aws_test_harness.h>  #include <aws/io/io.h>  /* Initialize this library and its dependencies.  * This will fail if:  * - the error info list is out of sync with the error enums.\\\\\", \\\\\"type\\\\\": \\\\\"TEXT\\\\\"}, \\\\\"location\\\\\": {\\\\\"s3Location\\\\\": {\\\\\"uri\\\\\": \\\\\"s3://aws-c-kb/aws-c-kb/aws-c-io/tests/io_lib_test.c\\\\\"}, \\\\\"type\\\\\": \\\\\"S3\\\\\"}, \\\\\"score\\\\\": 0.45784262}\"}],\"is_error\":false}]},{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Based on my analysis of the PR and the style guide information, I\\'ll review the code focusing on function and variable naming conventions. \\\\n\\\\nLet me prepare my comments:\"},{\"type\":\"tool_use\",\"name\":\"filesystem-create_directory\",\"input\":{\"path\":\"./new_comments_s3_PR519\"},\"id\":\"toolu_bdrk_019K6xCjYMRug2ysfepWw6dD\"}]},{\"role\":\"user\",\"content\":[{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_bdrk_019K6xCjYMRug2ysfepWw6dD\",\"content\":[{\"type\":\"text\",\"text\":\"Successfully created directory ./new_comments_s3_PR519\"}],\"is_error\":false}]}],\"stop_sequences\":null,\"system\":\"Given a github pull request.         The code in the pull request is very related to the knowledge base, fetch the details of the code base you want to learn about the code from the knowledge base.             Use 8BRIG4RFWU as Knowledge Base ID and aws profile as bedrock, region us-east-1                But if the code is just added by the pull request, then the knowledge base will not help         and follow the guidance in /Users/dengket/project/hackthon/fast-agent/crt_c_reviewer/summarization/comments_styles.md to be how you will make comments then make your comments             as details as you can for each specific lines about the function and variable naming on the pull request,                 save your comments about the specific line or lines with the number of the lines to a folder naming followed by ./new_comments_s3_PR<the PR number> with name related to the Pull request like PR454_Comments_Naming.md.                     And then, generates the comments only if needed and keep the positive comments out for the specific line or lines as the input for create_pull_request_review,                         save it to a file to the same folder with naming like `input_PR454_comments_naming.json`, but don\\'t really submit the comments\",\"tools\":[{\"name\":\"github-create_or_update_file\",\"description\":\"Create or update a single file in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"path\":{\"type\":\"string\",\"description\":\"Path where to create/update the file\"},\"content\":{\"type\":\"string\",\"description\":\"Content of the file\"},\"message\":{\"type\":\"string\",\"description\":\"Commit message\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to create/update the file in\"},\"sha\":{\"type\":\"string\",\"description\":\"SHA of the file being replaced (required when updating existing files)\"}},\"required\":[\"owner\",\"repo\",\"path\",\"content\",\"message\",\"branch\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_repositories\",\"description\":\"Search for GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"query\":{\"type\":\"string\",\"description\":\"Search query (see GitHub search syntax)\"},\"page\":{\"type\":\"number\",\"description\":\"Page number for pagination (default: 1)\"},\"perPage\":{\"type\":\"number\",\"description\":\"Number of results per page (default: 30, max: 100)\"}},\"required\":[\"query\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_repository\",\"description\":\"Create a new GitHub repository in your account\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\",\"description\":\"Repository name\"},\"description\":{\"type\":\"string\",\"description\":\"Repository description\"},\"private\":{\"type\":\"boolean\",\"description\":\"Whether the repository should be private\"},\"autoInit\":{\"type\":\"boolean\",\"description\":\"Initialize with README.md\"}},\"required\":[\"name\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_file_contents\",\"description\":\"Get the contents of a file or directory from a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"path\":{\"type\":\"string\",\"description\":\"Path to the file or directory\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to get contents from\"}},\"required\":[\"owner\",\"repo\",\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-push_files\",\"description\":\"Push multiple files to a GitHub repository in a single commit\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"branch\":{\"type\":\"string\",\"description\":\"Branch to push to (e.g., \\'main\\' or \\'master\\')\"},\"files\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"content\":{\"type\":\"string\"}},\"required\":[\"path\",\"content\"],\"additionalProperties\":false},\"description\":\"Array of files to push\"},\"message\":{\"type\":\"string\",\"description\":\"Commit message\"}},\"required\":[\"owner\",\"repo\",\"branch\",\"files\",\"message\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_issue\",\"description\":\"Create a new issue in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"body\":{\"type\":\"string\"},\"assignees\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"milestone\":{\"type\":\"number\"},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"owner\",\"repo\",\"title\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_pull_request\",\"description\":\"Create a new pull request in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"title\":{\"type\":\"string\",\"description\":\"Pull request title\"},\"body\":{\"type\":\"string\",\"description\":\"Pull request body/description\"},\"head\":{\"type\":\"string\",\"description\":\"The name of the branch where your changes are implemented\"},\"base\":{\"type\":\"string\",\"description\":\"The name of the branch you want the changes pulled into\"},\"draft\":{\"type\":\"boolean\",\"description\":\"Whether to create the pull request as a draft\"},\"maintainer_can_modify\":{\"type\":\"boolean\",\"description\":\"Whether maintainers can modify the pull request\"}},\"required\":[\"owner\",\"repo\",\"title\",\"head\",\"base\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-fork_repository\",\"description\":\"Fork a GitHub repository to your account or specified organization\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"organization\":{\"type\":\"string\",\"description\":\"Optional: organization to fork to (defaults to your personal account)\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_branch\",\"description\":\"Create a new branch in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"branch\":{\"type\":\"string\",\"description\":\"Name for the new branch\"},\"from_branch\":{\"type\":\"string\",\"description\":\"Optional: source branch to create from (defaults to the repository\\'s default branch)\"}},\"required\":[\"owner\",\"repo\",\"branch\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_commits\",\"description\":\"Get list of commits of a branch in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"sha\":{\"type\":\"string\"},\"page\":{\"type\":\"number\"},\"perPage\":{\"type\":\"number\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_issues\",\"description\":\"List issues in a GitHub repository with filtering options\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"direction\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"page\":{\"type\":\"number\"},\"per_page\":{\"type\":\"number\"},\"since\":{\"type\":\"string\"},\"sort\":{\"type\":\"string\",\"enum\":[\"created\",\"updated\",\"comments\"]},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\",\"all\"]}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-update_issue\",\"description\":\"Update an existing issue in a GitHub repository\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"},\"title\":{\"type\":\"string\"},\"body\":{\"type\":\"string\"},\"assignees\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"milestone\":{\"type\":\"number\"},\"labels\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\"]}},\"required\":[\"owner\",\"repo\",\"issue_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-add_issue_comment\",\"description\":\"Add a comment to an existing issue\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"},\"body\":{\"type\":\"string\"}},\"required\":[\"owner\",\"repo\",\"issue_number\",\"body\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_code\",\"description\":\"Search for code across GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_issues\",\"description\":\"Search for issues and pull requests across GitHub repositories\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100},\"sort\":{\"type\":\"string\",\"enum\":[\"comments\",\"reactions\",\"reactions-+1\",\"reactions--1\",\"reactions-smile\",\"reactions-thinking_face\",\"reactions-heart\",\"reactions-tada\",\"interactions\",\"created\",\"updated\"]}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-search_users\",\"description\":\"Search for users on GitHub\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"q\":{\"type\":\"string\"},\"order\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"]},\"page\":{\"type\":\"number\",\"minimum\":1},\"per_page\":{\"type\":\"number\",\"minimum\":1,\"maximum\":100},\"sort\":{\"type\":\"string\",\"enum\":[\"followers\",\"repositories\",\"joined\"]}},\"required\":[\"q\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_issue\",\"description\":\"Get details of a specific issue in a GitHub repository.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\"},\"repo\":{\"type\":\"string\"},\"issue_number\":{\"type\":\"number\"}},\"required\":[\"owner\",\"repo\",\"issue_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request\",\"description\":\"Get details of a specific pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-list_pull_requests\",\"description\":\"List and filter repository pull requests\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"state\":{\"type\":\"string\",\"enum\":[\"open\",\"closed\",\"all\"],\"description\":\"State of the pull requests to return\"},\"head\":{\"type\":\"string\",\"description\":\"Filter by head user or head organization and branch name\"},\"base\":{\"type\":\"string\",\"description\":\"Filter by base branch name\"},\"sort\":{\"type\":\"string\",\"enum\":[\"created\",\"updated\",\"popularity\",\"long-running\"],\"description\":\"What to sort results by\"},\"direction\":{\"type\":\"string\",\"enum\":[\"asc\",\"desc\"],\"description\":\"The direction of the sort\"},\"per_page\":{\"type\":\"number\",\"description\":\"Results per page (max 100)\"},\"page\":{\"type\":\"number\",\"description\":\"Page number of the results\"}},\"required\":[\"owner\",\"repo\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-create_pull_request_review\",\"description\":\"Create a review on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"commit_id\":{\"type\":\"string\",\"description\":\"The SHA of the commit that needs a review\"},\"body\":{\"type\":\"string\",\"description\":\"The body text of the review\"},\"event\":{\"type\":\"string\",\"enum\":[\"APPROVE\",\"REQUEST_CHANGES\",\"COMMENT\"],\"description\":\"The review action to perform\"},\"comments\":{\"type\":\"array\",\"items\":{\"anyOf\":[{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\",\"description\":\"The relative path to the file being commented on\"},\"position\":{\"type\":\"number\",\"description\":\"The position in the diff where you want to add a review comment\"},\"body\":{\"type\":\"string\",\"description\":\"Text of the review comment\"}},\"required\":[\"path\",\"position\",\"body\"],\"additionalProperties\":false},{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\",\"description\":\"The relative path to the file being commented on\"},\"line\":{\"type\":\"number\",\"description\":\"The line number in the file where you want to add a review comment\"},\"body\":{\"type\":\"string\",\"description\":\"Text of the review comment\"}},\"required\":[\"path\",\"line\",\"body\"],\"additionalProperties\":false}]},\"description\":\"Comments to post as part of the review (specify either position or line, not both)\"}},\"required\":[\"owner\",\"repo\",\"pull_number\",\"body\",\"event\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-merge_pull_request\",\"description\":\"Merge a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"commit_title\":{\"type\":\"string\",\"description\":\"Title for the automatic commit message\"},\"commit_message\":{\"type\":\"string\",\"description\":\"Extra detail to append to automatic commit message\"},\"merge_method\":{\"type\":\"string\",\"enum\":[\"merge\",\"squash\",\"rebase\"],\"description\":\"Merge method to use\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_files\",\"description\":\"Get the list of files changed in a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_status\",\"description\":\"Get the combined status of all status checks for a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-update_pull_request_branch\",\"description\":\"Update a pull request branch with the latest changes from the base branch\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"},\"expected_head_sha\":{\"type\":\"string\",\"description\":\"The expected SHA of the pull request\\'s HEAD ref\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_comments\",\"description\":\"Get the review comments on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"github-get_pull_request_reviews\",\"description\":\"Get the reviews on a pull request\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"owner\":{\"type\":\"string\",\"description\":\"Repository owner (username or organization)\"},\"repo\":{\"type\":\"string\",\"description\":\"Repository name\"},\"pull_number\":{\"type\":\"number\",\"description\":\"Pull request number\"}},\"required\":[\"owner\",\"repo\",\"pull_number\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-read_file\",\"description\":\"Read the complete contents of a file from the file system. Handles various text encodings and provides detailed error messages if the file cannot be read. Use this tool when you need to examine the contents of a single file. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-read_multiple_files\",\"description\":\"Read the contents of multiple files simultaneously. This is more efficient than reading files one by one when you need to analyze or compare multiple files. Each file\\'s content is returned with its path as a reference. Failed reads for individual files won\\'t stop the entire operation. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"paths\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"paths\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-write_file\",\"description\":\"Create a new file or completely overwrite an existing file with new content. Use with caution as it will overwrite existing files without warning. Handles text content with proper encoding. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"content\":{\"type\":\"string\"}},\"required\":[\"path\",\"content\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-edit_file\",\"description\":\"Make line-based edits to a text file. Each edit replaces exact line sequences with new content. Returns a git-style diff showing the changes made. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"edits\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"oldText\":{\"type\":\"string\",\"description\":\"Text to search for - must match exactly\"},\"newText\":{\"type\":\"string\",\"description\":\"Text to replace with\"}},\"required\":[\"oldText\",\"newText\"],\"additionalProperties\":false}},\"dryRun\":{\"type\":\"boolean\",\"default\":false,\"description\":\"Preview changes using git-style diff format\"}},\"required\":[\"path\",\"edits\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-create_directory\",\"description\":\"Create a new directory or ensure a directory exists. Can create multiple nested directories in one operation. If the directory already exists, this operation will succeed silently. Perfect for setting up directory structures for projects or ensuring required paths exist. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-list_directory\",\"description\":\"Get a detailed listing of all files and directories in a specified path. Results clearly distinguish between files and directories with [FILE] and [DIR] prefixes. This tool is essential for understanding directory structure and finding specific files within a directory. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-directory_tree\",\"description\":\"Get a recursive tree view of files and directories as a JSON structure. Each entry includes \\'name\\', \\'type\\' (file/directory), and \\'children\\' for directories. Files have no children array, while directories always have a children array (which may be empty). The output is formatted with 2-space indentation for readability. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-move_file\",\"description\":\"Move or rename files and directories. Can move files between directories and rename them in a single operation. If the destination exists, the operation will fail. Works across different directories and can be used for simple renaming within the same directory. Both source and destination must be within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"source\":{\"type\":\"string\"},\"destination\":{\"type\":\"string\"}},\"required\":[\"source\",\"destination\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-search_files\",\"description\":\"Recursively search for files and directories matching a pattern. Searches through all subdirectories from the starting path. The search is case-insensitive and matches partial names. Returns full paths to all matching items. Great for finding files when you don\\'t know their exact location. Only searches within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"},\"pattern\":{\"type\":\"string\"},\"excludePatterns\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"default\":[]}},\"required\":[\"path\",\"pattern\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-get_file_info\",\"description\":\"Retrieve detailed metadata about a file or directory. Returns comprehensive information including size, creation time, last modified time, permissions, and type. This tool is perfect for understanding file characteristics without reading the actual content. Only works within allowed directories.\",\"input_schema\":{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}},{\"name\":\"filesystem-list_allowed_directories\",\"description\":\"Returns the list of directories that this server is allowed to access. Use this to understand which directories are available before trying to access files.\",\"input_schema\":{\"type\":\"object\",\"properties\":{},\"required\":[]}},{\"name\":\"bedrock-kb-QueryKnowledgeBases\",\"description\":\"Query an Amazon Bedrock Knowledge Base using natural language.\\\\n\\\\n    ## Usage Requirements\\\\n    - You MUST first use the `resource://knowledgebases` resource to get valid knowledge base IDs\\\\n    - You can query different knowledge bases or make multiple queries to the same knowledge base\\\\n\\\\n    ## Query Tips\\\\n    - Use clear, specific natural language queries for best results\\\\n    - You can use this tool MULTIPLE TIMES with different queries to gather comprehensive information\\\\n    - Break complex questions into multiple focused queries\\\\n    - Consider querying for factual information and explanations separately\\\\n\\\\n    ## Tool output format\\\\n    The response contains multiple JSON objects (one per line), each representing a retrieved document with:\\\\n    - content: The text content of the document\\\\n    - location: The source location of the document\\\\n    - score: The relevance score of the document\\\\n\\\\n\\\\n    ## Interpretation Best Practices\\\\n    1. Extract and combine key information from multiple results\\\\n    2. Consider the source and relevance score when evaluating information\\\\n    3. Use follow-up queries to clarify ambiguous or incomplete information\\\\n    4. If the response is not relevant, try a different query, knowledge base, and/or data source\\\\n    5. After a few attempts, ask the user for clarification or a different query.\\\\n    \",\"input_schema\":{\"properties\":{\"query\":{\"description\":\"A natural language query to search the knowledge base with\",\"title\":\"Query\",\"type\":\"string\"},\"knowledge_base_id\":{\"description\":\"The knowledge base ID to query. It must be a valid ID from the resource://knowledgebases MCP resource\",\"title\":\"Knowledge Base Id\",\"type\":\"string\"},\"number_of_results\":{\"default\":10,\"description\":\"The number of results to return. Use smaller values for focused results and larger values for broader coverage.\",\"title\":\"Number Of Results\",\"type\":\"integer\"},\"reranking\":{\"default\":false,\"description\":\"Whether to rerank the results. Useful for improving relevance and sorting. Can be globally configured with BEDROCK_KB_RERANKING_ENABLED environment variable.\",\"title\":\"Reranking\",\"type\":\"boolean\"},\"reranking_model_name\":{\"default\":\"AMAZON\",\"description\":\"The name of the reranking model to use. Options: \\'COHERE\\', \\'AMAZON\\'\",\"enum\":[\"COHERE\",\"AMAZON\"],\"title\":\"Reranking Model Name\",\"type\":\"string\"},\"data_source_ids\":{\"anyOf\":[{\"items\":{\"type\":\"string\"},\"type\":\"array\"},{\"type\":\"null\"}],\"default\":null,\"description\":\"The data source IDs to filter the knowledge base by. It must be a list of valid data source IDs from the resource://knowledgebases MCP resource\",\"title\":\"Data Source Ids\"}},\"required\":[\"query\",\"knowledge_base_id\"],\"title\":\"query_knowledge_bases_toolArguments\",\"type\":\"object\"}}],\"anthropic_version\":\"bedrock-2023-05-31\"}'"},"message":"Error code: 429 - {'message': 'Too many tokens, please wait before trying again.'}","body":{"message":"Too many tokens, please wait before trying again."},"response":"<httpx.Response [429] https://bedrock-runtime.us-west-2.amazonaws.com/model/us.anthropic.claude-3-7-sonnet-20250219-v1:0/invoke>","status_code":429,"request_id":null}]}}
